! function(t, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.echarts = {}) }(this, function(t) {
    "use strict";

    function e(t) { var e = {},
            n = {},
            i = t.match(/Firefox\/([\d.]+)/),
            r = t.match(/MSIE\s([\d.]+)/) || t.match(/Trident\/.+?rv:(([\d.]+))/),
            a = t.match(/Edge\/([\d.]+)/),
            o = /micromessenger/i.test(t); return i && (n.firefox = !0, n.version = i[1]), r && (n.ie = !0, n.version = r[1]), a && (n.edge = !0, n.version = a[1]), o && (n.weChat = !0), { browser: n, os: e, node: !1, canvasSupported: !!document.createElement("canvas").getContext, svgSupported: "undefined" != typeof SVGRect, touchEventsSupported: "ontouchstart" in window && !n.ie && !n.edge, pointerEventsSupported: "onpointerdown" in window && (n.edge || n.ie && n.version >= 11), domSupported: "undefined" != typeof document } }

    function n(t, e) { "createCanvas" === t && (Rx = null), zx[t] = e }

    function i(t) { if (null == t || "object" != typeof t) return t; var e = t,
            n = Cx.call(t); if ("[object Array]" === n) { if (!R(t)) { e = []; for (var r = 0, a = t.length; a > r; r++) e[r] = i(t[r]) } } else if (Tx[n]) { if (!R(t)) { var o = t.constructor; if (t.constructor.from) e = o.from(t);
                else { e = new o(t.length); for (var r = 0, a = t.length; a > r; r++) e[r] = i(t[r]) } } } else if (!Ix[n] && !R(t) && !T(t)) { e = {}; for (var s in t) t.hasOwnProperty(s) && (e[s] = i(t[s])) } return e }

    function r(t, e, n) { if (!M(e) || !M(t)) return n ? i(e) : t; for (var a in e)
            if (e.hasOwnProperty(a)) { var o = t[a],
                    s = e[a];!M(s) || !M(o) || _(s) || _(o) || T(s) || T(o) || S(s) || S(o) || R(s) || R(o) ? !n && a in t || (t[a] = i(e[a], !0)) : r(o, s, n) }
        return t }

    function a(t, e) { for (var n = t[0], i = 1, a = t.length; a > i; i++) n = r(n, t[i], e); return n }

    function o(t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]); return t }

    function s(t, e, n) { for (var i in e) e.hasOwnProperty(i) && (n ? null != e[i] : null == t[i]) && (t[i] = e[i]); return t }

    function l() { return Rx || (Rx = Ex().getContext("2d")), Rx }

    function u(t, e) { if (t) { if (t.indexOf) return t.indexOf(e); for (var n = 0, i = t.length; i > n; n++)
                if (t[n] === e) return n } return -1 }

    function h(t, e) {
        function n() {} var i = t.prototype;
        n.prototype = e.prototype, t.prototype = new n; for (var r in i) i.hasOwnProperty(r) && (t.prototype[r] = i[r]);
        t.prototype.constructor = t, t.superClass = e }

    function c(t, e, n) { t = "prototype" in t ? t.prototype : t, e = "prototype" in e ? e.prototype : e, s(t, e, n) }

    function d(t) { return t ? "string" == typeof t ? !1 : "number" == typeof t.length : void 0 }

    function f(t, e, n) { if (t && e)
            if (t.forEach && t.forEach === Dx) t.forEach(e, n);
            else if (t.length === +t.length)
            for (var i = 0, r = t.length; r > i; i++) e.call(n, t[i], i, t);
        else
            for (var a in t) t.hasOwnProperty(a) && e.call(n, t[a], a, t) }

    function p(t, e, n) { if (t && e) { if (t.map && t.map === Lx) return t.map(e, n); for (var i = [], r = 0, a = t.length; a > r; r++) i.push(e.call(n, t[r], r, t)); return i } }

    function g(t, e, n, i) { if (t && e) { if (t.reduce && t.reduce === Ox) return t.reduce(e, n, i); for (var r = 0, a = t.length; a > r; r++) n = e.call(i, n, t[r], r, t); return n } }

    function v(t, e, n) { if (t && e) { if (t.filter && t.filter === kx) return t.filter(e, n); for (var i = [], r = 0, a = t.length; a > r; r++) e.call(n, t[r], r, t) && i.push(t[r]); return i } }

    function m(t, e, n) { if (t && e)
            for (var i = 0, r = t.length; r > i; i++)
                if (e.call(n, t[i], i, t)) return t[i] }

    function y(t, e) { var n = Px.call(arguments, 2); return function() { return t.apply(e, n.concat(Px.call(arguments))) } }

    function x(t) { var e = Px.call(arguments, 1); return function() { return t.apply(this, e.concat(Px.call(arguments))) } }

    function _(t) { return "[object Array]" === Cx.call(t) }

    function b(t) { return "function" == typeof t }

    function w(t) { return "[object String]" === Cx.call(t) }

    function M(t) { var e = typeof t; return "function" === e || !!t && "object" === e }

    function S(t) { return !!Ix[Cx.call(t)] }

    function I(t) { return !!Tx[Cx.call(t)] }

    function T(t) { return "object" == typeof t && "number" == typeof t.nodeType && "object" == typeof t.ownerDocument }

    function C(t) { return t !== t }

    function A() { for (var t = 0, e = arguments.length; e > t; t++)
            if (null != arguments[t]) return arguments[t] }

    function D(t, e) { return null != t ? t : e }

    function k(t, e, n) { return null != t ? t : null != e ? e : n }

    function P() { return Function.call.apply(Px, arguments) }

    function L(t) { if ("number" == typeof t) return [t, t, t, t]; var e = t.length; return 2 === e ? [t[0], t[1], t[0], t[1]] : 3 === e ? [t[0], t[1], t[2], t[1]] : t }

    function O(t, e) { if (!t) throw new Error(e) }

    function z(t) { return null == t ? null : "function" == typeof t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "") }

    function E(t) { t[Bx] = !0 }

    function R(t) { return t[Bx] }

    function B(t) {
        function e(t, e) { n ? i.set(t, e) : i.set(e, t) } var n = _(t);
        this.data = {}; var i = this;
        t instanceof B ? t.each(e) : t && f(t, e) }

    function N(t) { return new B(t) }

    function V(t, e) { for (var n = new t.constructor(t.length + e.length), i = 0; i < t.length; i++) n[i] = t[i]; var r = t.length; for (i = 0; i < e.length; i++) n[i + r] = e[i]; return n }

    function F() {}

    function H(t, e) { var n = new Vx(2); return null == t && (t = 0), null == e && (e = 0), n[0] = t, n[1] = e, n }

    function G(t, e) { return t[0] = e[0], t[1] = e[1], t }

    function W(t) { var e = new Vx(2); return e[0] = t[0], e[1] = t[1], e }

    function Z(t, e, n) { return t[0] = e, t[1] = n, t }

    function U(t, e, n) { return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t }

    function X(t, e, n, i) { return t[0] = e[0] + n[0] * i, t[1] = e[1] + n[1] * i, t }

    function Y(t, e, n) { return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t }

    function j(t) { return Math.sqrt(q(t)) }

    function q(t) { return t[0] * t[0] + t[1] * t[1] }

    function K(t, e, n) { return t[0] = e[0] * n[0], t[1] = e[1] * n[1], t }

    function $(t, e, n) { return t[0] = e[0] / n[0], t[1] = e[1] / n[1], t }

    function Q(t, e) { return t[0] * e[0] + t[1] * e[1] }

    function J(t, e, n) { return t[0] = e[0] * n, t[1] = e[1] * n, t }

    function te(t, e) { var n = j(e); return 0 === n ? (t[0] = 0, t[1] = 0) : (t[0] = e[0] / n, t[1] = e[1] / n), t }

    function ee(t, e) { return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])) }

    function ne(t, e) { return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]) }

    function ie(t, e) { return t[0] = -e[0], t[1] = -e[1], t }

    function re(t, e, n, i) { return t[0] = e[0] + i * (n[0] - e[0]), t[1] = e[1] + i * (n[1] - e[1]), t }

    function ae(t, e, n) { var i = e[0],
            r = e[1]; return t[0] = n[0] * i + n[2] * r + n[4], t[1] = n[1] * i + n[3] * r + n[5], t }

    function oe(t, e, n) { return t[0] = Math.min(e[0], n[0]), t[1] = Math.min(e[1], n[1]), t }

    function se(t, e, n) { return t[0] = Math.max(e[0], n[0]), t[1] = Math.max(e[1], n[1]), t }

    function le() { this.on("mousedown", this._dragStart, this), this.on("mousemove", this._drag, this), this.on("mouseup", this._dragEnd, this) }

    function ue(t, e) { return { target: t, topTarget: e && e.topTarget } }

    function he(t, e) { var n = t._$eventProcessor; return null != e && n && n.normalizeQuery && (e = n.normalizeQuery(e)), e }

    function ce(t, e, n, i, r, a) { var o = t._$handlers; if ("function" == typeof n && (r = i, i = n, n = null), !i || !e) return t;
        n = he(t, n), o[e] || (o[e] = []); for (var s = 0; s < o[e].length; s++)
            if (o[e][s].h === i) return t;
        var l = { h: i, one: a, query: n, ctx: r || t, callAtLast: i.zrEventfulCallAtLast },
            u = o[e].length - 1,
            h = o[e][u]; return h && h.callAtLast ? o[e].splice(u, 0, l) : o[e].push(l), t }

    function de(t, e, n, i, r, a) { var o = i + "-" + r,
            s = t.length; if (a.hasOwnProperty(o)) return a[o]; if (1 === e) { var l = Math.round(Math.log((1 << s) - 1 & ~r) / Yx); return t[n][l] } for (var u = i | 1 << n, h = n + 1; i & 1 << h;) h++; for (var c = 0, d = 0, f = 0; s > d; d++) { var p = 1 << d;
            p & r || (c += (f % 2 ? -1 : 1) * t[n][d] * de(t, e - 1, h, u, r | p, a), f++) } return a[o] = c, c }

    function fe(t, e) { var n = [
                [t[0], t[1], 1, 0, 0, 0, -e[0] * t[0], -e[0] * t[1]],
                [0, 0, 0, t[0], t[1], 1, -e[1] * t[0], -e[1] * t[1]],
                [t[2], t[3], 1, 0, 0, 0, -e[2] * t[2], -e[2] * t[3]],
                [0, 0, 0, t[2], t[3], 1, -e[3] * t[2], -e[3] * t[3]],
                [t[4], t[5], 1, 0, 0, 0, -e[4] * t[4], -e[4] * t[5]],
                [0, 0, 0, t[4], t[5], 1, -e[5] * t[4], -e[5] * t[5]],
                [t[6], t[7], 1, 0, 0, 0, -e[6] * t[6], -e[6] * t[7]],
                [0, 0, 0, t[6], t[7], 1, -e[7] * t[6], -e[7] * t[7]]
            ],
            i = {},
            r = de(n, 8, 0, 0, 0, i); if (0 !== r) { for (var a = [], o = 0; 8 > o; o++)
                for (var s = 0; 8 > s; s++) null == a[s] && (a[s] = 0), a[s] += ((o + s) % 2 ? -1 : 1) * de(n, 7, 0 === o ? 1 : 0, 1 << o, 1 << s, i) / r * e[o]; return function(t, e, n) { var i = e * a[6] + n * a[7] + 1;
                t[0] = (e * a[0] + n * a[1] + a[2]) / i, t[1] = (e * a[3] + n * a[4] + a[5]) / i } } }

    function pe(t, e, n, i, r) { return ge(qx, e, i, r, !0) && ge(t, n, qx[0], qx[1]) }

    function ge(t, e, n, i, r) { if (e.getBoundingClientRect && Sx.domSupported && !ye(e)) { var a = e[jx] || (e[jx] = {}),
                o = ve(e, a),
                s = me(o, a, r); if (s) return s(t, n, i), !0 } return !1 }

    function ve(t, e) { var n = e.markers; if (n) return n;
        n = e.markers = []; for (var i = ["left", "right"], r = ["top", "bottom"], a = 0; 4 > a; a++) { var o = document.createElement("div"),
                s = o.style,
                l = a % 2,
                u = (a >> 1) % 2;
            s.cssText = ["position: absolute", "visibility: hidden", "padding: 0", "margin: 0", "border-width: 0", "user-select: none", "width:0", "height:0", i[l] + ":0", r[u] + ":0", i[1 - l] + ":auto", r[1 - u] + ":auto", ""].join("!important;"), t.appendChild(o), n.push(o) } return n }

    function me(t, e, n) { for (var i = n ? "invTrans" : "trans", r = e[i], a = e.srcCoords, o = !0, s = [], l = [], u = 0; 4 > u; u++) { var h = t[u].getBoundingClientRect(),
                c = 2 * u,
                d = h.left,
                f = h.top;
            s.push(d, f), o = o && a && d === a[c] && f === a[c + 1], l.push(t[u].offsetLeft, t[u].offsetTop) } return o && r ? r : (e.srcCoords = s, e[i] = n ? fe(l, s) : fe(s, l)) }

    function ye(t) { return "CANVAS" === t.nodeName.toUpperCase() }

    function xe(t, e, n, i) { return n = n || {}, i || !Sx.canvasSupported ? _e(t, e, n) : Sx.browser.firefox && null != e.layerX && e.layerX !== e.offsetX ? (n.zrX = e.layerX, n.zrY = e.layerY) : null != e.offsetX ? (n.zrX = e.offsetX, n.zrY = e.offsetY) : _e(t, e, n), n }

    function _e(t, e, n) { if (Sx.domSupported && t.getBoundingClientRect) { var i = e.clientX,
                r = e.clientY; if (ye(t)) { var a = t.getBoundingClientRect(); return n.zrX = i - a.left, void(n.zrY = r - a.top) } if (ge(Qx, t, i, r)) return n.zrX = Qx[0], void(n.zrY = Qx[1]) }
        n.zrX = n.zrY = 0 }

    function be(t) { return t || window.event }

    function we(t, e, n) { if (e = be(e), null != e.zrX) return e; var i = e.type,
            r = i && i.indexOf("touch") >= 0; if (r) { var a = "touchend" !== i ? e.targetTouches[0] : e.changedTouches[0];
            a && xe(t, a, e, n) } else xe(t, e, e, n), e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3; var o = e.button; return null == e.which && void 0 !== o && $x.test(e.type) && (e.which = 1 & o ? 1 : 2 & o ? 3 : 4 & o ? 2 : 0), e }

    function Me(t, e, n, i) { Kx ? t.addEventListener(e, n, i) : t.attachEvent("on" + e, n) }

    function Se(t, e, n, i) { Kx ? t.removeEventListener(e, n, i) : t.detachEvent("on" + e, n) }

    function Ie(t) { return 2 === t.which || 3 === t.which }

    function Te(t) { var e = t[1][0] - t[0][0],
            n = t[1][1] - t[0][1]; return Math.sqrt(e * e + n * n) }

    function Ce(t) { return [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2] }

    function Ae(t, e, n) { return { type: t, event: n, target: e.target, topTarget: e.topTarget, cancelBubble: !1, offsetX: n.zrX, offsetY: n.zrY, gestureEvent: n.gestureEvent, pinchX: n.pinchX, pinchY: n.pinchY, pinchScale: n.pinchScale, wheelDelta: n.zrDelta, zrByTouch: n.zrByTouch, which: n.which, stop: De } }

    function De() { Jx(this.event) }

    function ke() {}

    function Pe(t, e, n) { if (t[t.rectHover ? "rectContain" : "contain"](e, n)) { for (var i, r = t; r;) { if (r.clipPath && !r.clipPath.contain(e, n)) return !1;
                r.silent && (i = !0), r = r.parent } return i ? n_ : !0 } return !1 }

    function Le(t, e, n) { var i = t.painter; return 0 > e || e > i.getWidth() || 0 > n || n > i.getHeight() }

    function Oe() { var t = new a_(6); return ze(t), t }

    function ze(t) { return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t }

    function Ee(t, e) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t }

    function Re(t, e, n) { var i = e[0] * n[0] + e[2] * n[1],
            r = e[1] * n[0] + e[3] * n[1],
            a = e[0] * n[2] + e[2] * n[3],
            o = e[1] * n[2] + e[3] * n[3],
            s = e[0] * n[4] + e[2] * n[5] + e[4],
            l = e[1] * n[4] + e[3] * n[5] + e[5]; return t[0] = i, t[1] = r, t[2] = a, t[3] = o, t[4] = s, t[5] = l, t }

    function Be(t, e, n) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4] + n[0], t[5] = e[5] + n[1], t }

    function Ne(t, e, n) { var i = e[0],
            r = e[2],
            a = e[4],
            o = e[1],
            s = e[3],
            l = e[5],
            u = Math.sin(n),
            h = Math.cos(n); return t[0] = i * h + o * u, t[1] = -i * u + o * h, t[2] = r * h + s * u, t[3] = -r * u + h * s, t[4] = h * a + u * l, t[5] = h * l - u * a, t }

    function Ve(t, e, n) { var i = n[0],
            r = n[1]; return t[0] = e[0] * i, t[1] = e[1] * r, t[2] = e[2] * i, t[3] = e[3] * r, t[4] = e[4] * i, t[5] = e[5] * r, t }

    function Fe(t, e) { var n = e[0],
            i = e[2],
            r = e[4],
            a = e[1],
            o = e[3],
            s = e[5],
            l = n * o - a * i; return l ? (l = 1 / l, t[0] = o * l, t[1] = -a * l, t[2] = -i * l, t[3] = n * l, t[4] = (i * s - o * r) * l, t[5] = (a * r - n * s) * l, t) : null }

    function He(t) { var e = Oe(); return Ee(e, t), e }

    function Ge(t) { return t > l_ || -l_ > t }

    function We(t) { this._target = t.target, this._life = t.life || 1e3, this._delay = t.delay || 0, this._initialized = !1, this.loop = null == t.loop ? !1 : t.loop, this.gap = t.gap || 0, this.easing = t.easing || "Linear", this.onframe = t.onframe, this.ondestroy = t.ondestroy, this.onrestart = t.onrestart, this._pausedTime = 0, this._paused = !1 }

    function Ze(t) { return t = Math.round(t), 0 > t ? 0 : t > 255 ? 255 : t }

    function Ue(t) { return t = Math.round(t), 0 > t ? 0 : t > 360 ? 360 : t }

    function Xe(t) { return 0 > t ? 0 : t > 1 ? 1 : t }

    function Ye(t) { return Ze(t.length && "%" === t.charAt(t.length - 1) ? parseFloat(t) / 100 * 255 : parseInt(t, 10)) }

    function je(t) { return Xe(t.length && "%" === t.charAt(t.length - 1) ? parseFloat(t) / 100 : parseFloat(t)) }

    function qe(t, e, n) { return 0 > n ? n += 1 : n > 1 && (n -= 1), 1 > 6 * n ? t + (e - t) * n * 6 : 1 > 2 * n ? e : 2 > 3 * n ? t + (e - t) * (2 / 3 - n) * 6 : t }

    function Ke(t, e, n) { return t + (e - t) * n }

    function $e(t, e, n, i, r) { return t[0] = e, t[1] = n, t[2] = i, t[3] = r, t }

    function Qe(t, e) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t }

    function Je(t, e) { w_ && Qe(w_, e), w_ = b_.put(t, w_ || e.slice()) }

    function tn(t, e) { if (t) { e = e || []; var n = b_.get(t); if (n) return Qe(e, n);
            t += ""; var i = t.replace(/ /g, "").toLowerCase(); if (i in __) return Qe(e, __[i]), Je(t, e), e; if ("#" !== i.charAt(0)) { var r = i.indexOf("("),
                    a = i.indexOf(")"); if (-1 !== r && a + 1 === i.length) { var o = i.substr(0, r),
                        s = i.substr(r + 1, a - (r + 1)).split(","),
                        l = 1; switch (o) {
                        case "rgba":
                            if (4 !== s.length) return void $e(e, 0, 0, 0, 1);
                            l = je(s.pop());
                        case "rgb":
                            return 3 !== s.length ? void $e(e, 0, 0, 0, 1) : ($e(e, Ye(s[0]), Ye(s[1]), Ye(s[2]), l), Je(t, e), e);
                        case "hsla":
                            return 4 !== s.length ? void $e(e, 0, 0, 0, 1) : (s[3] = je(s[3]), en(s, e), Je(t, e), e);
                        case "hsl":
                            return 3 !== s.length ? void $e(e, 0, 0, 0, 1) : (en(s, e), Je(t, e), e);
                        default:
                            return } }
                $e(e, 0, 0, 0, 1) } else { if (4 === i.length) { var u = parseInt(i.substr(1), 16); return u >= 0 && 4095 >= u ? ($e(e, (3840 & u) >> 4 | (3840 & u) >> 8, 240 & u | (240 & u) >> 4, 15 & u | (15 & u) << 4, 1), Je(t, e), e) : void $e(e, 0, 0, 0, 1) } if (7 === i.length) { var u = parseInt(i.substr(1), 16); return u >= 0 && 16777215 >= u ? ($e(e, (16711680 & u) >> 16, (65280 & u) >> 8, 255 & u, 1), Je(t, e), e) : void $e(e, 0, 0, 0, 1) } } } }

    function en(t, e) { var n = (parseFloat(t[0]) % 360 + 360) % 360 / 360,
            i = je(t[1]),
            r = je(t[2]),
            a = .5 >= r ? r * (i + 1) : r + i - r * i,
            o = 2 * r - a; return e = e || [], $e(e, Ze(255 * qe(o, a, n + 1 / 3)), Ze(255 * qe(o, a, n)), Ze(255 * qe(o, a, n - 1 / 3)), 1), 4 === t.length && (e[3] = t[3]), e }

    function nn(t) { if (t) { var e, n, i = t[0] / 255,
                r = t[1] / 255,
                a = t[2] / 255,
                o = Math.min(i, r, a),
                s = Math.max(i, r, a),
                l = s - o,
                u = (s + o) / 2; if (0 === l) e = 0, n = 0;
            else { n = .5 > u ? l / (s + o) : l / (2 - s - o); var h = ((s - i) / 6 + l / 2) / l,
                    c = ((s - r) / 6 + l / 2) / l,
                    d = ((s - a) / 6 + l / 2) / l;
                i === s ? e = d - c : r === s ? e = 1 / 3 + h - d : a === s && (e = 2 / 3 + c - h), 0 > e && (e += 1), e > 1 && (e -= 1) } var f = [360 * e, n, u]; return null != t[3] && f.push(t[3]), f } }

    function rn(t, e) { var n = tn(t); if (n) { for (var i = 0; 3 > i; i++) n[i] = 0 > e ? n[i] * (1 - e) | 0 : (255 - n[i]) * e + n[i] | 0, n[i] > 255 ? n[i] = 255 : t[i] < 0 && (n[i] = 0); return hn(n, 4 === n.length ? "rgba" : "rgb") } }

    function an(t) { var e = tn(t); return e ? ((1 << 24) + (e[0] << 16) + (e[1] << 8) + +e[2]).toString(16).slice(1) : void 0 }

    function on(t, e, n) { if (e && e.length && t >= 0 && 1 >= t) { n = n || []; var i = t * (e.length - 1),
                r = Math.floor(i),
                a = Math.ceil(i),
                o = e[r],
                s = e[a],
                l = i - r; return n[0] = Ze(Ke(o[0], s[0], l)), n[1] = Ze(Ke(o[1], s[1], l)), n[2] = Ze(Ke(o[2], s[2], l)), n[3] = Xe(Ke(o[3], s[3], l)), n } }

    function sn(t, e, n) { if (e && e.length && t >= 0 && 1 >= t) { var i = t * (e.length - 1),
                r = Math.floor(i),
                a = Math.ceil(i),
                o = tn(e[r]),
                s = tn(e[a]),
                l = i - r,
                u = hn([Ze(Ke(o[0], s[0], l)), Ze(Ke(o[1], s[1], l)), Ze(Ke(o[2], s[2], l)), Xe(Ke(o[3], s[3], l))], "rgba"); return n ? { color: u, leftIndex: r, rightIndex: a, value: i } : u } }

    function ln(t, e, n, i) { return t = tn(t), t ? (t = nn(t), null != e && (t[0] = Ue(e)), null != n && (t[1] = je(n)), null != i && (t[2] = je(i)), hn(en(t), "rgba")) : void 0 }

    function un(t, e) { return t = tn(t), t && null != e ? (t[3] = Xe(e), hn(t, "rgba")) : void 0 }

    function hn(t, e) { if (t && t.length) { var n = t[0] + "," + t[1] + "," + t[2]; return ("rgba" === e || "hsva" === e || "hsla" === e) && (n += "," + t[3]), e + "(" + n + ")" } }

    function cn(t, e) { return t[e] }

    function dn(t, e, n) { t[e] = n }

    function fn(t, e, n) { return (e - t) * n + t }

    function pn(t, e, n) { return n > .5 ? e : t }

    function gn(t, e, n, i, r) { var a = t.length; if (1 === r)
            for (var o = 0; a > o; o++) i[o] = fn(t[o], e[o], n);
        else
            for (var s = a && t[0].length, o = 0; a > o; o++)
                for (var l = 0; s > l; l++) i[o][l] = fn(t[o][l], e[o][l], n) }

    function vn(t, e, n) { var i = t.length,
            r = e.length; if (i !== r) { var a = i > r; if (a) t.length = r;
            else
                for (var o = i; r > o; o++) t.push(1 === n ? e[o] : T_.call(e[o])) } for (var s = t[0] && t[0].length, o = 0; o < t.length; o++)
            if (1 === n) isNaN(t[o]) && (t[o] = e[o]);
            else
                for (var l = 0; s > l; l++) isNaN(t[o][l]) && (t[o][l] = e[o][l]) }

    function mn(t, e, n) { if (t === e) return !0; var i = t.length; if (i !== e.length) return !1; if (1 === n) { for (var r = 0; i > r; r++)
                if (t[r] !== e[r]) return !1 } else
            for (var a = t[0].length, r = 0; i > r; r++)
                for (var o = 0; a > o; o++)
                    if (t[r][o] !== e[r][o]) return !1; return !0 }

    function yn(t, e, n, i, r, a, o, s, l) { var u = t.length; if (1 === l)
            for (var h = 0; u > h; h++) s[h] = xn(t[h], e[h], n[h], i[h], r, a, o);
        else
            for (var c = t[0].length, h = 0; u > h; h++)
                for (var d = 0; c > d; d++) s[h][d] = xn(t[h][d], e[h][d], n[h][d], i[h][d], r, a, o) }

    function xn(t, e, n, i, r, a, o) { var s = .5 * (n - t),
            l = .5 * (i - e); return (2 * (e - n) + s + l) * o + (-3 * (e - n) - 2 * s - l) * a + s * r + e }

    function _n(t) { if (d(t)) { var e = t.length; if (d(t[0])) { for (var n = [], i = 0; e > i; i++) n.push(T_.call(t[i])); return n } return T_.call(t) } return t }

    function bn(t) { return t[0] = Math.floor(t[0]), t[1] = Math.floor(t[1]), t[2] = Math.floor(t[2]), "rgba(" + t.join(",") + ")" }

    function wn(t) { var e = t[t.length - 1].value; return d(e && e[0]) ? 2 : 1 }

    function Mn(t, e, n, i, r, a) { var o = t._getter,
            s = t._setter,
            l = "spline" === e,
            u = i.length; if (u) { var h, c = i[0].value,
                f = d(c),
                p = !1,
                g = !1,
                v = f ? wn(i) : 0;
            i.sort(function(t, e) { return t.time - e.time }), h = i[u - 1].time; for (var m = [], y = [], x = i[0].value, _ = !0, b = 0; u > b; b++) { m.push(i[b].time / h); var w = i[b].value; if (f && mn(w, x, v) || !f && w === x || (_ = !1), x = w, "string" == typeof w) { var M = tn(w);
                    M ? (w = M, p = !0) : g = !0 }
                y.push(w) } if (a || !_) { for (var S = y[u - 1], b = 0; u - 1 > b; b++) f ? vn(y[b], S, v) : !isNaN(y[b]) || isNaN(S) || g || p || (y[b] = S);
                f && vn(o(t._target, r), S, v); var I, T, C, A, D, k, P = 0,
                    L = 0; if (p) var O = [0, 0, 0, 0]; var z = function(t, e) { var n; if (0 > e) n = 0;
                        else if (L > e) { for (I = Math.min(P + 1, u - 1), n = I; n >= 0 && !(m[n] <= e); n--);
                            n = Math.min(n, u - 2) } else { for (n = P; u > n && !(m[n] > e); n++);
                            n = Math.min(n - 1, u - 2) }
                        P = n, L = e; var i = m[n + 1] - m[n]; if (0 !== i)
                            if (T = (e - m[n]) / i, l)
                                if (A = y[n], C = y[0 === n ? n : n - 1], D = y[n > u - 2 ? u - 1 : n + 1], k = y[n > u - 3 ? u - 1 : n + 2], f) yn(C, A, D, k, T, T * T, T * T * T, o(t, r), v);
                                else { var a; if (p) a = yn(C, A, D, k, T, T * T, T * T * T, O, 1), a = bn(O);
                                    else { if (g) return pn(A, D, T);
                                        a = xn(C, A, D, k, T, T * T, T * T * T) }
                                    s(t, r, a) }
                        else if (f) gn(y[n], y[n + 1], T, o(t, r), v);
                        else { var a; if (p) gn(y[n], y[n + 1], T, O, 1), a = bn(O);
                            else { if (g) return pn(y[n], y[n + 1], T);
                                a = fn(y[n], y[n + 1], T) }
                            s(t, r, a) } },
                    E = new We({ target: t._target, life: h, loop: t._loop, delay: t._delay, onframe: z, ondestroy: n }); return e && "spline" !== e && (E.easing = e), E } } }

    function Sn(t, e, n, i, r, a, o, s) {
        function l() { h--, h || a && a() }
        w(i) ? (a = r, r = i, i = 0) : b(r) ? (a = r, r = "linear", i = 0) : b(i) ? (a = i, i = 0) : b(n) ? (a = n, n = 500) : n || (n = 500), t.stopAnimation(), In(t, "", t, e, n, i, s); var u = t.animators.slice(),
            h = u.length;
        h || a && a(); for (var c = 0; c < u.length; c++) u[c].done(l).start(r, o) }

    function In(t, e, n, i, r, a, o) { var s = {},
            l = 0; for (var u in i) i.hasOwnProperty(u) && (null != n[u] ? M(i[u]) && !d(i[u]) ? In(t, e ? e + "." + u : u, n[u], i[u], r, a, o) : (o ? (s[u] = n[u], Tn(t, e, u, i[u])) : s[u] = i[u], l++) : null == i[u] || o || Tn(t, e, u, i[u]));
        l > 0 && t.animate(e, !1).when(null == r ? 500 : r, s).delay(a || 0) }

    function Tn(t, e, n, i) { if (e) { var r = {};
            r[e] = {}, r[e][n] = i, t.attr(r) } else t.attr(n, i) }

    function Cn(t, e, n, i) { 0 > n && (t += n, n = -n), 0 > i && (e += i, i = -i), this.x = t, this.y = e, this.width = n, this.height = i }

    function An(t) { for (var e = 0; t >= V_;) e |= 1 & t, t >>= 1; return t + e }

    function Dn(t, e, n, i) { var r = e + 1; if (r === n) return 1; if (i(t[r++], t[e]) < 0) { for (; n > r && i(t[r], t[r - 1]) < 0;) r++;
            kn(t, e, r) } else
            for (; n > r && i(t[r], t[r - 1]) >= 0;) r++; return r - e }

    function kn(t, e, n) { for (n--; n > e;) { var i = t[e];
            t[e++] = t[n], t[n--] = i } }

    function Pn(t, e, n, i, r) { for (i === e && i++; n > i; i++) { for (var a, o = t[i], s = e, l = i; l > s;) a = s + l >>> 1, r(o, t[a]) < 0 ? l = a : s = a + 1; var u = i - s; switch (u) {
                case 3:
                    t[s + 3] = t[s + 2];
                case 2:
                    t[s + 2] = t[s + 1];
                case 1:
                    t[s + 1] = t[s]; break;
                default:
                    for (; u > 0;) t[s + u] = t[s + u - 1], u-- }
            t[s] = o } }

    function Ln(t, e, n, i, r, a) { var o = 0,
            s = 0,
            l = 1; if (a(t, e[n + r]) > 0) { for (s = i - r; s > l && a(t, e[n + r + l]) > 0;) o = l, l = (l << 1) + 1, 0 >= l && (l = s);
            l > s && (l = s), o += r, l += r } else { for (s = r + 1; s > l && a(t, e[n + r - l]) <= 0;) o = l, l = (l << 1) + 1, 0 >= l && (l = s);
            l > s && (l = s); var u = o;
            o = r - l, l = r - u } for (o++; l > o;) { var h = o + (l - o >>> 1);
            a(t, e[n + h]) > 0 ? o = h + 1 : l = h } return l }

    function On(t, e, n, i, r, a) { var o = 0,
            s = 0,
            l = 1; if (a(t, e[n + r]) < 0) { for (s = r + 1; s > l && a(t, e[n + r - l]) < 0;) o = l, l = (l << 1) + 1, 0 >= l && (l = s);
            l > s && (l = s); var u = o;
            o = r - l, l = r - u } else { for (s = i - r; s > l && a(t, e[n + r + l]) >= 0;) o = l, l = (l << 1) + 1, 0 >= l && (l = s);
            l > s && (l = s), o += r, l += r } for (o++; l > o;) { var h = o + (l - o >>> 1);
            a(t, e[n + h]) < 0 ? l = h : o = h + 1 } return l }

    function zn(t, e) {
        function n(t, e) { l[c] = t, u[c] = e, c += 1 }

        function i() { for (; c > 1;) { var t = c - 2; if (t >= 1 && u[t - 1] <= u[t] + u[t + 1] || t >= 2 && u[t - 2] <= u[t] + u[t - 1]) u[t - 1] < u[t + 1] && t--;
                else if (u[t] > u[t + 1]) break;
                a(t) } }

        function r() { for (; c > 1;) { var t = c - 2;
                t > 0 && u[t - 1] < u[t + 1] && t--, a(t) } }

        function a(n) { var i = l[n],
                r = u[n],
                a = l[n + 1],
                h = u[n + 1];
            u[n] = r + h, n === c - 3 && (l[n + 1] = l[n + 2], u[n + 1] = u[n + 2]), c--; var d = On(t[a], t, i, r, 0, e);
            i += d, r -= d, 0 !== r && (h = Ln(t[i + r - 1], t, a, h, h - 1, e), 0 !== h && (h >= r ? o(i, r, a, h) : s(i, r, a, h))) }

        function o(n, i, r, a) { var o = 0; for (o = 0; i > o; o++) d[o] = t[n + o]; var s = 0,
                l = r,
                u = n; if (t[u++] = t[l++], 0 !== --a) { if (1 === i) { for (o = 0; a > o; o++) t[u + o] = t[l + o]; return void(t[u + a] = d[s]) } for (var c, f, p, g = h;;) { c = 0, f = 0, p = !1;
                    do
                        if (e(t[l], d[s]) < 0) { if (t[u++] = t[l++], f++, c = 0, 0 === --a) { p = !0; break } } else if (t[u++] = d[s++], c++, f = 0, 1 === --i) { p = !0; break } while (g > (c | f)); if (p) break;
                    do { if (c = On(t[l], d, s, i, 0, e), 0 !== c) { for (o = 0; c > o; o++) t[u + o] = d[s + o]; if (u += c, s += c, i -= c, 1 >= i) { p = !0; break } } if (t[u++] = t[l++], 0 === --a) { p = !0; break } if (f = Ln(d[s], t, l, a, 0, e), 0 !== f) { for (o = 0; f > o; o++) t[u + o] = t[l + o]; if (u += f, l += f, a -= f, 0 === a) { p = !0; break } } if (t[u++] = d[s++], 1 === --i) { p = !0; break }
                        g-- } while (c >= F_ || f >= F_); if (p) break;
                    0 > g && (g = 0), g += 2 } if (h = g, 1 > h && (h = 1), 1 === i) { for (o = 0; a > o; o++) t[u + o] = t[l + o];
                    t[u + a] = d[s] } else { if (0 === i) throw new Error; for (o = 0; i > o; o++) t[u + o] = d[s + o] } } else
                for (o = 0; i > o; o++) t[u + o] = d[s + o] }

        function s(n, i, r, a) { var o = 0; for (o = 0; a > o; o++) d[o] = t[r + o]; var s = n + i - 1,
                l = a - 1,
                u = r + a - 1,
                c = 0,
                f = 0; if (t[u--] = t[s--], 0 !== --i) { if (1 === a) { for (u -= i, s -= i, f = u + 1, c = s + 1, o = i - 1; o >= 0; o--) t[f + o] = t[c + o]; return void(t[u] = d[l]) } for (var p = h;;) { var g = 0,
                        v = 0,
                        m = !1;
                    do
                        if (e(d[l], t[s]) < 0) { if (t[u--] = t[s--], g++, v = 0, 0 === --i) { m = !0; break } } else if (t[u--] = d[l--], v++, g = 0, 1 === --a) { m = !0; break } while (p > (g | v)); if (m) break;
                    do { if (g = i - On(d[l], t, n, i, i - 1, e), 0 !== g) { for (u -= g, s -= g, i -= g, f = u + 1, c = s + 1, o = g - 1; o >= 0; o--) t[f + o] = t[c + o]; if (0 === i) { m = !0; break } } if (t[u--] = d[l--], 1 === --a) { m = !0; break } if (v = a - Ln(t[s], d, 0, a, a - 1, e), 0 !== v) { for (u -= v, l -= v, a -= v, f = u + 1, c = l + 1, o = 0; v > o; o++) t[f + o] = d[c + o]; if (1 >= a) { m = !0; break } } if (t[u--] = t[s--], 0 === --i) { m = !0; break }
                        p-- } while (g >= F_ || v >= F_); if (m) break;
                    0 > p && (p = 0), p += 2 } if (h = p, 1 > h && (h = 1), 1 === a) { for (u -= i, s -= i, f = u + 1, c = s + 1, o = i - 1; o >= 0; o--) t[f + o] = t[c + o];
                    t[u] = d[l] } else { if (0 === a) throw new Error; for (c = u - (a - 1), o = 0; a > o; o++) t[c + o] = d[o] } } else
                for (c = u - (a - 1), o = 0; a > o; o++) t[c + o] = d[o] } var l, u, h = F_,
            c = 0,
            d = [];
        l = [], u = [], this.mergeRuns = i, this.forceMergeRuns = r, this.pushRun = n }

    function En(t, e, n, i) { n || (n = 0), i || (i = t.length); var r = i - n; if (!(2 > r)) { var a = 0; if (V_ > r) return a = Dn(t, n, i, e), void Pn(t, n, i, n + a, e); var o = new zn(t, e),
                s = An(r);
            do { if (a = Dn(t, n, i, e), s > a) { var l = r;
                    l > s && (l = s), Pn(t, n, n + l, n + a, e), a = l }
                o.pushRun(n, a), o.mergeRuns(), r -= a, n += a } while (0 !== r);
            o.forceMergeRuns() } }

    function Rn(t, e) { return t.zlevel === e.zlevel ? t.z === e.z ? t.z2 - e.z2 : t.z - e.z : t.zlevel - e.zlevel }

    function Bn(t, e, n) { var i = null == e.x ? 0 : e.x,
            r = null == e.x2 ? 1 : e.x2,
            a = null == e.y ? 0 : e.y,
            o = null == e.y2 ? 0 : e.y2;
        e.global || (i = i * n.width + n.x, r = r * n.width + n.x, a = a * n.height + n.y, o = o * n.height + n.y), i = isNaN(i) ? 0 : i, r = isNaN(r) ? 1 : r, a = isNaN(a) ? 0 : a, o = isNaN(o) ? 0 : o; var s = t.createLinearGradient(i, a, r, o); return s }

    function Nn(t, e, n) { var i = n.width,
            r = n.height,
            a = Math.min(i, r),
            o = null == e.x ? .5 : e.x,
            s = null == e.y ? .5 : e.y,
            l = null == e.r ? .5 : e.r;
        e.global || (o = o * i + n.x, s = s * r + n.y, l *= a); var u = t.createRadialGradient(o, s, 0, o, s, l); return u }

    function Vn() { return !1 }

    function Fn(t, e, n) { var i = Ex(),
            r = e.getWidth(),
            a = e.getHeight(),
            o = i.style; return o && (o.position = "absolute", o.left = 0, o.top = 0, o.width = r + "px", o.height = a + "px", i.setAttribute("data-zr-dom-id", t)), i.width = r * n, i.height = a * n, i }

    function Hn(t) { if ("string" == typeof t) { var e = tb.get(t); return e && e.image } return t }

    function Gn(t, e, n, i, r) { if (t) { if ("string" == typeof t) { if (e && e.__zrImageSrc === t || !n) return e; var a = tb.get(t),
                    o = { hostEl: n, cb: i, cbPayload: r }; return a ? (e = a.image, !Zn(e) && a.pending.push(o)) : (e = new Image, e.onload = e.onerror = Wn, tb.put(t, e.__cachedImgObj = { image: e, pending: [o] }), e.src = e.__zrImageSrc = t), e } return t } return e }

    function Wn() { var t = this.__cachedImgObj;
        this.onload = this.onerror = this.__cachedImgObj = null; for (var e = 0; e < t.pending.length; e++) { var n = t.pending[e],
                i = n.cb;
            i && i(this, n.cbPayload), n.hostEl.dirty() }
        t.pending.length = 0 }

    function Zn(t) { return t && t.width && t.height }

    function Un(t, e) { ob[t] = e }

    function Xn(t, e) { e = e || ab; var n = t + ":" + e; if (eb[n]) return eb[n]; for (var i = (t + "").split("\n"), r = 0, a = 0, o = i.length; o > a; a++) r = Math.max(ri(i[a], e).width, r); return nb > ib && (nb = 0, eb = {}), nb++, eb[n] = r, r }

    function Yn(t, e, n, i, r, a, o, s) { return o ? qn(t, e, n, i, r, a, o, s) : jn(t, e, n, i, r, a, s) }

    function jn(t, e, n, i, r, a, o) { var s = ai(t, e, r, a, o),
            l = Xn(t, e);
        r && (l += r[1] + r[3]); var u = s.outerHeight,
            h = Kn(0, l, n),
            c = $n(0, u, i),
            d = new Cn(h, c, l, u); return d.lineHeight = s.lineHeight, d }

    function qn(t, e, n, i, r, a, o, s) { var l = oi(t, { rich: o, truncate: s, font: e, textAlign: n, textPadding: r, textLineHeight: a }),
            u = l.outerWidth,
            h = l.outerHeight,
            c = Kn(0, u, n),
            d = $n(0, h, i); return new Cn(c, d, u, h) }

    function Kn(t, e, n) { return "right" === n ? t -= e : "center" === n && (t -= e / 2), t }

    function $n(t, e, n) { return "middle" === n ? t -= e / 2 : "bottom" === n && (t -= e), t }

    function Qn(t, e, n) { var i = e.textPosition,
            r = e.textDistance,
            a = n.x,
            o = n.y;
        r = r || 0; var s = n.height,
            l = n.width,
            u = s / 2,
            h = "left",
            c = "top"; switch (i) {
            case "left":
                a -= r, o += u, h = "right", c = "middle"; break;
            case "right":
                a += r + l, o += u, c = "middle"; break;
            case "top":
                a += l / 2, o -= r, h = "center", c = "bottom"; break;
            case "bottom":
                a += l / 2, o += s + r, h = "center"; break;
            case "inside":
                a += l / 2, o += u, h = "center", c = "middle"; break;
            case "insideLeft":
                a += r, o += u, c = "middle"; break;
            case "insideRight":
                a += l - r, o += u, h = "right", c = "middle"; break;
            case "insideTop":
                a += l / 2, o += r, h = "center"; break;
            case "insideBottom":
                a += l / 2, o += s - r, h = "center", c = "bottom"; break;
            case "insideTopLeft":
                a += r, o += r; break;
            case "insideTopRight":
                a += l - r, o += r, h = "right"; break;
            case "insideBottomLeft":
                a += r, o += s - r, c = "bottom"; break;
            case "insideBottomRight":
                a += l - r, o += s - r, h = "right", c = "bottom" } return t = t || {}, t.x = a, t.y = o, t.textAlign = h, t.textVerticalAlign = c, t }

    function Jn(t, e, n, i, r) { if (!e) return ""; var a = (t + "").split("\n");
        r = ti(e, n, i, r); for (var o = 0, s = a.length; s > o; o++) a[o] = ei(a[o], r); return a.join("\n") }

    function ti(t, e, n, i) { i = o({}, i), i.font = e; var n = D(n, "...");
        i.maxIterations = D(i.maxIterations, 2); var r = i.minChar = D(i.minChar, 0);
        i.cnCharWidth = Xn("国", e); var a = i.ascCharWidth = Xn("a", e);
        i.placeholder = D(i.placeholder, ""); for (var s = t = Math.max(0, t - 1), l = 0; r > l && s >= a; l++) s -= a; var u = Xn(n, e); return u > s && (n = "", u = 0), s = t - u, i.ellipsis = n, i.ellipsisWidth = u, i.contentWidth = s, i.containerWidth = t, i }

    function ei(t, e) { var n = e.containerWidth,
            i = e.font,
            r = e.contentWidth; if (!n) return ""; var a = Xn(t, i); if (n >= a) return t; for (var o = 0;; o++) { if (r >= a || o >= e.maxIterations) { t += e.ellipsis; break } var s = 0 === o ? ni(t, r, e.ascCharWidth, e.cnCharWidth) : a > 0 ? Math.floor(t.length * r / a) : 0;
            t = t.substr(0, s), a = Xn(t, i) } return "" === t && (t = e.placeholder), t }

    function ni(t, e, n, i) { for (var r = 0, a = 0, o = t.length; o > a && e > r; a++) { var s = t.charCodeAt(a);
            r += s >= 0 && 127 >= s ? n : i } return a }

    function ii(t) { return Xn("国", t) }

    function ri(t, e) { return ob.measureText(t, e) }

    function ai(t, e, n, i, r) { null != t && (t += ""); var a = D(i, ii(e)),
            o = t ? t.split("\n") : [],
            s = o.length * a,
            l = s,
            u = !0; if (n && (l += n[0] + n[2]), t && r) { u = !1; var h = r.outerHeight,
                c = r.outerWidth; if (null != h && l > h) t = "", o = [];
            else if (null != c)
                for (var d = ti(c - (n ? n[1] + n[3] : 0), e, r.ellipsis, { minChar: r.minChar, placeholder: r.placeholder }), f = 0, p = o.length; p > f; f++) o[f] = ei(o[f], d) } return { lines: o, height: s, outerHeight: l, lineHeight: a, canCacheByTextString: u } }

    function oi(t, e) { var n = { lines: [], width: 0, height: 0 }; if (null != t && (t += ""), !t) return n; for (var i, r = rb.lastIndex = 0; null != (i = rb.exec(t));) { var a = i.index;
            a > r && si(n, t.substring(r, a)), si(n, i[2], i[1]), r = rb.lastIndex }
        r < t.length && si(n, t.substring(r, t.length)); var o = n.lines,
            s = 0,
            l = 0,
            u = [],
            h = e.textPadding,
            c = e.truncate,
            d = c && c.outerWidth,
            f = c && c.outerHeight;
        h && (null != d && (d -= h[1] + h[3]), null != f && (f -= h[0] + h[2])); for (var p = 0; p < o.length; p++) { for (var g = o[p], v = 0, m = 0, y = 0; y < g.tokens.length; y++) { var x = g.tokens[y],
                    _ = x.styleName && e.rich[x.styleName] || {},
                    b = x.textPadding = _.textPadding,
                    w = x.font = _.font || e.font,
                    M = x.textHeight = D(_.textHeight, ii(w)); if (b && (M += b[0] + b[2]), x.height = M, x.lineHeight = k(_.textLineHeight, e.textLineHeight, M), x.textAlign = _ && _.textAlign || e.textAlign, x.textVerticalAlign = _ && _.textVerticalAlign || "middle", null != f && s + x.lineHeight > f) return { lines: [], width: 0, height: 0 };
                x.textWidth = Xn(x.text, w); var S = _.textWidth,
                    I = null == S || "auto" === S; if ("string" == typeof S && "%" === S.charAt(S.length - 1)) x.percentWidth = S, u.push(x), S = 0;
                else { if (I) { S = x.textWidth; var T = _.textBackgroundColor,
                            C = T && T.image;
                        C && (C = Hn(C), Zn(C) && (S = Math.max(S, C.width * M / C.height))) } var A = b ? b[1] + b[3] : 0;
                    S += A; var P = null != d ? d - m : null;
                    null != P && S > P && (!I || A > P ? (x.text = "", x.textWidth = S = 0) : (x.text = Jn(x.text, P - A, w, c.ellipsis, { minChar: c.minChar }), x.textWidth = Xn(x.text, w), S = x.textWidth + A)) }
                m += x.width = S, _ && (v = Math.max(v, x.lineHeight)) }
            g.width = m, g.lineHeight = v, s += v, l = Math.max(l, m) }
        n.outerWidth = n.width = D(e.textWidth, l), n.outerHeight = n.height = D(e.textHeight, s), h && (n.outerWidth += h[1] + h[3], n.outerHeight += h[0] + h[2]); for (var p = 0; p < u.length; p++) { var x = u[p],
                L = x.percentWidth;
            x.width = parseInt(L, 10) / 100 * l } return n }

    function si(t, e, n) { for (var i = "" === e, r = e.split("\n"), a = t.lines, o = 0; o < r.length; o++) { var s = r[o],
                l = { styleName: n, text: s, isLineHolder: !s && !i }; if (o) a.push({ tokens: [l] });
            else { var u = (a[a.length - 1] || (a[0] = { tokens: [] })).tokens,
                    h = u.length;
                1 === h && u[0].isLineHolder ? u[0] = l : (s || !h || i) && u.push(l) } } }

    function li(t) { var e = (t.fontSize || t.fontFamily) && [t.fontStyle, t.fontWeight, (t.fontSize || 12) + "px", t.fontFamily || "sans-serif"].join(" "); return e && z(e) || t.textFont || t.font }

    function ui(t, e) { var n, i, r, a, o = e.x,
            s = e.y,
            l = e.width,
            u = e.height,
            h = e.r;
        0 > l && (o += l, l = -l), 0 > u && (s += u, u = -u), "number" == typeof h ? n = i = r = a = h : h instanceof Array ? 1 === h.length ? n = i = r = a = h[0] : 2 === h.length ? (n = r = h[0], i = a = h[1]) : 3 === h.length ? (n = h[0], i = a = h[1], r = h[2]) : (n = h[0], i = h[1], r = h[2], a = h[3]) : n = i = r = a = 0; var c;
        n + i > l && (c = n + i, n *= l / c, i *= l / c), r + a > l && (c = r + a, r *= l / c, a *= l / c), i + r > u && (c = i + r, i *= u / c, r *= u / c), n + a > u && (c = n + a, n *= u / c, a *= u / c), t.moveTo(o + n, s), t.lineTo(o + l - i, s), 0 !== i && t.arc(o + l - i, s + i, i, -Math.PI / 2, 0), t.lineTo(o + l, s + u - r), 0 !== r && t.arc(o + l - r, s + u - r, r, 0, Math.PI / 2), t.lineTo(o + a, s + u), 0 !== a && t.arc(o + a, s + u - a, a, Math.PI / 2, Math.PI), t.lineTo(o, s + n), 0 !== n && t.arc(o + n, s + n, n, Math.PI, 1.5 * Math.PI) }

    function hi(t) { return ci(t), f(t.rich, ci), t }

    function ci(t) { if (t) { t.font = li(t); var e = t.textAlign; "middle" === e && (e = "center"), t.textAlign = null == e || lb[e] ? e : "left"; var n = t.textVerticalAlign || t.textBaseline; "center" === n && (n = "middle"), t.textVerticalAlign = null == n || ub[n] ? n : "top"; var i = t.textPadding;
            i && (t.textPadding = L(t.textPadding)) } }

    function di(t, e, n, i, r, a) { i.rich ? pi(t, e, n, i, r, a) : fi(t, e, n, i, r, a) }

    function fi(t, e, n, i, r, a) { var o, s = yi(i),
            l = !1,
            u = e.__attrCachedBy === Z_.PLAIN_TEXT;
        a !== U_ ? (a && (o = a.style, l = !s && u && o), e.__attrCachedBy = s ? Z_.NONE : Z_.PLAIN_TEXT) : u && (e.__attrCachedBy = Z_.NONE); var h = i.font || sb;
        l && h === (o.font || sb) || (e.font = h); var c = t.__computedFont;
        t.__styleFont !== h && (t.__styleFont = h, c = t.__computedFont = e.font); var d = i.textPadding,
            f = i.textLineHeight,
            p = t.__textCotentBlock;
        (!p || t.__dirtyText) && (p = t.__textCotentBlock = ai(n, c, d, f, i.truncate)); var g = p.outerHeight,
            v = p.lines,
            m = p.lineHeight,
            y = bi(db, t, i, r),
            x = y.baseX,
            _ = y.baseY,
            b = y.textAlign || "left",
            w = y.textVerticalAlign;
        vi(e, i, r, x, _); var M = $n(_, g, w),
            S = x,
            I = M; if (s || d) { var T = Xn(n, c),
                C = T;
            d && (C += d[1] + d[3]); var A = Kn(x, C, b);
            s && xi(t, e, i, A, M, C, g), d && (S = Ti(x, b, d), I += d[0]) }
        e.textAlign = b, e.textBaseline = "middle", e.globalAlpha = i.opacity || 1; for (var D = 0; D < hb.length; D++) { var k = hb[D],
                P = k[0],
                L = k[1],
                O = i[P];
            l && O === o[P] || (e[L] = W_(e, L, O || k[2])) }
        I += m / 2; var z = i.textStrokeWidth,
            E = l ? o.textStrokeWidth : null,
            R = !l || z !== E,
            B = !l || R || i.textStroke !== o.textStroke,
            N = Mi(i.textStroke, z),
            V = Si(i.textFill); if (N && (R && (e.lineWidth = z), B && (e.strokeStyle = N)), V && (l && i.textFill === o.textFill || (e.fillStyle = V)), 1 === v.length) N && e.strokeText(v[0], S, I), V && e.fillText(v[0], S, I);
        else
            for (var D = 0; D < v.length; D++) N && e.strokeText(v[D], S, I), V && e.fillText(v[D], S, I), I += m }

    function pi(t, e, n, i, r, a) { a !== U_ && (e.__attrCachedBy = Z_.NONE); var o = t.__textCotentBlock;
        (!o || t.__dirtyText) && (o = t.__textCotentBlock = oi(n, i)), gi(t, e, o, i, r) }

    function gi(t, e, n, i, r) { var a = n.width,
            o = n.outerWidth,
            s = n.outerHeight,
            l = i.textPadding,
            u = bi(db, t, i, r),
            h = u.baseX,
            c = u.baseY,
            d = u.textAlign,
            f = u.textVerticalAlign;
        vi(e, i, r, h, c); var p = Kn(h, o, d),
            g = $n(c, s, f),
            v = p,
            m = g;
        l && (v += l[3], m += l[0]); var y = v + a;
        yi(i) && xi(t, e, i, p, g, o, s); for (var x = 0; x < n.lines.length; x++) { for (var _, b = n.lines[x], w = b.tokens, M = w.length, S = b.lineHeight, I = b.width, T = 0, C = v, A = y, D = M - 1; M > T && (_ = w[T], !_.textAlign || "left" === _.textAlign);) mi(t, e, _, i, S, m, C, "left"), I -= _.width, C += _.width, T++; for (; D >= 0 && (_ = w[D], "right" === _.textAlign);) mi(t, e, _, i, S, m, A, "right"), I -= _.width, A -= _.width, D--; for (C += (a - (C - v) - (y - A) - I) / 2; D >= T;) _ = w[T], mi(t, e, _, i, S, m, C + _.width / 2, "center"), C += _.width, T++;
            m += S } }

    function vi(t, e, n, i, r) { if (n && e.textRotation) { var a = e.textOrigin; "center" === a ? (i = n.width / 2 + n.x, r = n.height / 2 + n.y) : a && (i = a[0] + n.x, r = a[1] + n.y), t.translate(i, r), t.rotate(-e.textRotation), t.translate(-i, -r) } }

    function mi(t, e, n, i, r, a, o, s) {
        var l = i.rich[n.styleName] || {};
        l.text = n.text;
        var u = n.textVerticalAlign,
            h = a + r / 2;
        "top" === u ? h = a + n.height / 2 : "bottom" === u && (h = a + r - n.height / 2), !n.isLineHolder && yi(l) && xi(t, e, l, "right" === s ? o - n.width : "center" === s ? o - n.width / 2 : o, h - n.height / 2, n.width, n.height);
        var c = n.textPadding;
        c && (o = Ti(o, s, c), h -= n.height / 2 - c[2] - n.textHeight / 2), wi(e, "shadowBlur", k(l.textShadowBlur, i.textShadowBlur, 0)), wi(e, "shadowColor", l.textShadowColor || i.textShadowColor || "transparent"), wi(e, "shadowOffsetX", k(l.textShadowOffsetX, i.textShadowOffsetX, 0)), wi(e, "shadowOffsetY", k(l.textShadowOffsetY, i.textShadowOffsetY, 0)), wi(e, "textAlign", s), wi(e, "textBaseline", "middle"), wi(e, "font", n.font || sb);
        var d = Mi(l.textStroke || i.textStroke, p),
            f = Si(l.textFill || i.textFill),
            p = D(l.textStrokeWidth, i.textStrokeWidth);
        d && (wi(e, "lineWidth", p), wi(e, "strokeStyle", d), e.strokeText(n.text, o, h)), f && (wi(e, "fillStyle", f), e.fillText(n.text, o, h))
    }

    function yi(t) { return !!(t.textBackgroundColor || t.textBorderWidth && t.textBorderColor) }

    function xi(t, e, n, i, r, a, o) { var s = n.textBackgroundColor,
            l = n.textBorderWidth,
            u = n.textBorderColor,
            h = w(s); if (wi(e, "shadowBlur", n.textBoxShadowBlur || 0), wi(e, "shadowColor", n.textBoxShadowColor || "transparent"), wi(e, "shadowOffsetX", n.textBoxShadowOffsetX || 0), wi(e, "shadowOffsetY", n.textBoxShadowOffsetY || 0), h || l && u) { e.beginPath(); var c = n.textBorderRadius;
            c ? ui(e, { x: i, y: r, width: a, height: o, r: c }) : e.rect(i, r, a, o), e.closePath() } if (h)
            if (wi(e, "fillStyle", s), null != n.fillOpacity) { var d = e.globalAlpha;
                e.globalAlpha = n.fillOpacity * n.opacity, e.fill(), e.globalAlpha = d } else e.fill();
        else if (M(s)) { var f = s.image;
            f = Gn(f, null, t, _i, s), f && Zn(f) && e.drawImage(f, i, r, a, o) } if (l && u)
            if (wi(e, "lineWidth", l), wi(e, "strokeStyle", u), null != n.strokeOpacity) { var d = e.globalAlpha;
                e.globalAlpha = n.strokeOpacity * n.opacity, e.stroke(), e.globalAlpha = d } else e.stroke() }

    function _i(t, e) { e.image = t }

    function bi(t, e, n, i) { var r = n.x || 0,
            a = n.y || 0,
            o = n.textAlign,
            s = n.textVerticalAlign; if (i) { var l = n.textPosition; if (l instanceof Array) r = i.x + Ii(l[0], i.width), a = i.y + Ii(l[1], i.height);
            else { var u = e && e.calculateTextPosition ? e.calculateTextPosition(cb, n, i) : Qn(cb, n, i);
                r = u.x, a = u.y, o = o || u.textAlign, s = s || u.textVerticalAlign } var h = n.textOffset;
            h && (r += h[0], a += h[1]) } return t = t || {}, t.baseX = r, t.baseY = a, t.textAlign = o, t.textVerticalAlign = s, t }

    function wi(t, e, n) { return t[e] = W_(t, e, n), t[e] }

    function Mi(t, e) { return null == t || 0 >= e || "transparent" === t || "none" === t ? null : t.image || t.colorStops ? "#000" : t }

    function Si(t) { return null == t || "none" === t ? null : t.image || t.colorStops ? "#000" : t }

    function Ii(t, e) { return "string" == typeof t ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t }

    function Ti(t, e, n) { return "right" === e ? t - n[1] : "center" === e ? t + n[3] / 2 - n[1] / 2 : t + n[3] }

    function Ci(t, e) { return null != t && (t || e.textBackgroundColor || e.textBorderWidth && e.textBorderColor || e.textPadding) }

    function Ai(t) { t = t || {}, z_.call(this, t); for (var e in t) t.hasOwnProperty(e) && "style" !== e && (this[e] = t[e]);
        this.style = new Y_(t.style, this), this._rect = null, this.__clipPaths = null }

    function Di(t) { Ai.call(this, t) }

    function ki(t) { return parseInt(t, 10) }

    function Pi(t) { return t ? t.__builtin__ ? !0 : "function" != typeof t.resize || "function" != typeof t.refresh ? !1 : !0 : !1 }

    function Li(t, e, n) { return xb.copy(t.getBoundingRect()), t.transform && xb.applyTransform(t.transform), _b.width = e, _b.height = n, !xb.intersect(_b) }

    function Oi(t, e) { if (t === e) return !1; if (!t || !e || t.length !== e.length) return !0; for (var n = 0; n < t.length; n++)
            if (t[n] !== e[n]) return !0;
        return !1 }

    function zi(t, e) { for (var n = 0; n < t.length; n++) { var i = t[n];
            i.setTransform(e), e.beginPath(), i.buildPath(e, i.shape), e.clip(), i.restoreTransform(e) } }

    function Ei(t, e) { var n = document.createElement("div"); return n.style.cssText = ["position:relative", "width:" + t + "px", "height:" + e + "px", "padding:0", "margin:0", "border-width:0"].join(";") + ";", n }

    function Ri(t) { return "mousewheel" === t && Sx.browser.firefox ? "DOMMouseScroll" : t }

    function Bi(t) { var e = t.pointerType; return "pen" === e || "touch" === e }

    function Ni(t) { t.touching = !0, null != t.touchTimer && (clearTimeout(t.touchTimer), t.touchTimer = null), t.touchTimer = setTimeout(function() { t.touching = !1, t.touchTimer = null }, 700) }

    function Vi(t) { t && (t.zrByTouch = !0) }

    function Fi(t, e) { return we(t.dom, new Gi(t, e), !0) }

    function Hi(t, e) { for (var n = e, i = !1; n && 9 !== n.nodeType && !(i = n.domBelongToZr || n !== e && n === t.painterRoot);) n = n.parentNode; return i }

    function Gi(t, e) { this.type = e.type, this.target = this.currentTarget = t.dom, this.pointerType = e.pointerType, this.clientX = e.clientX, this.clientY = e.clientY }

    function Wi(t, e) { var n = e.domHandlers;
        Sx.pointerEventsSupported ? f(Ib.pointer, function(i) { Ui(e, i, function(e) { n[i].call(t, e) }) }) : (Sx.touchEventsSupported && f(Ib.touch, function(i) { Ui(e, i, function(r) { n[i].call(t, r), Ni(e) }) }), f(Ib.mouse, function(i) { Ui(e, i, function(r) { r = be(r), e.touching || n[i].call(t, r) }) })) }

    function Zi(t, e) {
        function n(n) {
            function i(i) { i = be(i), Hi(t, i.target) || (i = Fi(t, i), e.domHandlers[n].call(t, i)) }
            Ui(e, n, i, { capture: !0 }) }
        Sx.pointerEventsSupported ? f(Tb.pointer, n) : Sx.touchEventsSupported || f(Tb.mouse, n) }

    function Ui(t, e, n, i) { t.mounted[e] = n, t.listenerOpts[e] = i, Me(t.domTarget, Ri(e), n, i) }

    function Xi(t) { var e = t.mounted; for (var n in e) e.hasOwnProperty(n) && Se(t.domTarget, Ri(n), e[n], t.listenerOpts[n]);
        t.mounted = {} }

    function Yi(t, e) { if (t._mayPointerCapture = null, Sb && t._pointerCapturing ^ e) { t._pointerCapturing = e; var n = t._globalHandlerScope;
            e ? Zi(t, n) : Xi(n) } }

    function ji(t, e) { this.domTarget = t, this.domHandlers = e, this.mounted = {}, this.listenerOpts = {}, this.touchTimer = null, this.touching = !1 }

    function qi(t, e) { Xx.call(this), this.dom = t, this.painterRoot = e, this._localHandlerScope = new ji(t, Ab), Sb && (this._globalHandlerScope = new ji(document, Db)), this._pointerCapturing = !1, this._mayPointerCapture = null, Wi(this, this._localHandlerScope) }

    function Ki(t, e) { var n = new Eb(bx(), t, e); return Ob[n.id] = n, n }

    function $i(t) { if (t) t.dispose();
        else { for (var e in Ob) Ob.hasOwnProperty(e) && Ob[e].dispose();
            Ob = {} } return this }

    function Qi(t) { return Ob[t] }

    function Ji(t, e) { Lb[t] = e }

    function tr(t) { delete Ob[t] }

    function er(t) { return t instanceof Array ? t : null == t ? [] : [t] }

    function nr(t, e, n) { if (t) { t[e] = t[e] || {}, t.emphasis = t.emphasis || {}, t.emphasis[e] = t.emphasis[e] || {}; for (var i = 0, r = n.length; r > i; i++) { var a = n[i];!t.emphasis[e].hasOwnProperty(a) && t[e].hasOwnProperty(a) && (t.emphasis[e][a] = t[e][a]) } } }

    function ir(t) { return !Nb(t) || Vb(t) || t instanceof Date ? t : t.value }

    function rr(t) { return Nb(t) && !(t instanceof Array) }

    function ar(t, e) { e = (e || []).slice(); var n = p(t || [], function(t) { return { exist: t } }); return Bb(e, function(t, i) { if (Nb(t)) { for (var r = 0; r < n.length; r++)
                    if (!n[r].option && null != t.id && n[r].exist.id === t.id + "") return n[r].option = t, void(e[i] = null);
                for (var r = 0; r < n.length; r++) { var a = n[r].exist; if (!(n[r].option || null != a.id && null != t.id || null == t.name || lr(t) || lr(a) || a.name !== t.name + "")) return n[r].option = t, void(e[i] = null) } } }), Bb(e, function(t) { if (Nb(t)) { for (var e = 0; e < n.length; e++) { var i = n[e].exist; if (!n[e].option && !lr(i) && null == t.id) { n[e].option = t; break } }
                e >= n.length && n.push({ option: t }) } }), n }

    function or(t) { var e = N();
        Bb(t, function(t) { var n = t.exist;
            n && e.set(n.id, t) }), Bb(t, function(t) { var n = t.option;
            O(!n || null == n.id || !e.get(n.id) || e.get(n.id) === t, "id duplicates: " + (n && n.id)), n && null != n.id && e.set(n.id, t), !t.keyInfo && (t.keyInfo = {}) }), Bb(t, function(t, n) { var i = t.exist,
                r = t.option,
                a = t.keyInfo; if (Nb(r)) { if (a.name = null != r.name ? r.name + "" : i ? i.name : Fb + n, i) a.id = i.id;
                else if (null != r.id) a.id = r.id + "";
                else { var o = 0;
                    do a.id = "\x00" + a.name + "\x00" + o++; while (e.get(a.id)) }
                e.set(a.id, t) } }) }

    function sr(t) { var e = t.name; return !(!e || !e.indexOf(Fb)) }

    function lr(t) { return Nb(t) && t.id && 0 === (t.id + "").indexOf("\x00_ec_\x00") }

    function ur(t, e) {
        function n(t, e, n) { for (var i = 0, r = t.length; r > i; i++)
                for (var a = t[i].seriesId, o = er(t[i].dataIndex), s = n && n[a], l = 0, u = o.length; u > l; l++) { var h = o[l];
                    s && s[h] ? s[h] = null : (e[a] || (e[a] = {}))[h] = 1 } }

        function i(t, e) { var n = []; for (var r in t)
                if (t.hasOwnProperty(r) && null != t[r])
                    if (e) n.push(+r);
                    else { var a = i(t[r], !0);
                        a.length && n.push({ seriesId: r, dataIndex: a }) }
            return n } var r = {},
            a = {}; return n(t || [], r), n(e || [], a, r), [i(r), i(a)] }

    function hr(t, e) { return null != e.dataIndexInside ? e.dataIndexInside : null != e.dataIndex ? _(e.dataIndex) ? p(e.dataIndex, function(e) { return t.indexOfRawIndex(e) }) : t.indexOfRawIndex(e.dataIndex) : null != e.name ? _(e.name) ? p(e.name, function(e) { return t.indexOfName(e) }) : t.indexOfName(e.name) : void 0 }

    function cr() { var t = "__\x00ec_inner_" + Gb++ + "_" + Math.random().toFixed(5); return function(e) { return e[t] || (e[t] = {}) } }

    function dr(t, e, n) { if (w(e)) { var i = {};
            i[e + "Index"] = 0, e = i } var r = n && n.defaultMainType;!r || fr(e, r + "Index") || fr(e, r + "Id") || fr(e, r + "Name") || (e[r + "Index"] = 0); var a = {}; return Bb(e, function(i, r) { var i = e[r]; if ("dataIndex" === r || "dataIndexInside" === r) return void(a[r] = i); var o = r.match(/^(\w+)(Index|Id|Name)$/) || [],
                s = o[1],
                l = (o[2] || "").toLowerCase(); if (!(!s || !l || null == i || "index" === l && "none" === i || n && n.includeMainTypes && u(n.includeMainTypes, s) < 0)) { var h = { mainType: s };
                ("index" !== l || "all" !== i) && (h[l] = i); var c = t.queryComponents(h);
                a[s + "Models"] = c, a[s + "Model"] = c[0] } }), a }

    function fr(t, e) { return t && t.hasOwnProperty(e) }

    function pr(t, e, n) { t.setAttribute ? t.setAttribute(e, n) : t[e] = n }

    function gr(t, e) { return t.getAttribute ? t.getAttribute(e) : t[e] }

    function vr(t) { return "auto" === t ? Sx.domSupported ? "html" : "richText" : t || "html" }

    function mr(t) { var e = { main: "", sub: "" }; return t && (t = t.split(Wb), e.main = t[0] || "", e.sub = t[1] || ""), e }

    function yr(t) { O(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(t), 'componentType "' + t + '" illegal') }

    function xr(t) { t.$constructor = t, t.extend = function(t) { var e = this,
                n = function() { t.$constructor ? t.$constructor.apply(this, arguments) : e.apply(this, arguments) }; return o(n.prototype, t), n.extend = this.extend, n.superCall = br, n.superApply = wr, h(n, this), n.superClass = e, n } }

    function _r(t) { var e = ["__\x00is_clz", Ub++, Math.random().toFixed(3)].join("_");
        t.prototype[e] = !0, t.isInstance = function(t) { return !(!t || !t[e]) } }

    function br(t, e) { var n = P(arguments, 2); return this.superClass.prototype[e].apply(t, n) }

    function wr(t, e, n) { return this.superClass.prototype[e].apply(t, n) }

    function Mr(t, e) {
        function n(t) { var e = i[t.main]; return e && e[Zb] || (e = i[t.main] = {}, e[Zb] = !0), e }
        e = e || {}; var i = {}; if (t.registerClass = function(t, e) { if (e)
                    if (yr(e), e = mr(e), e.sub) { if (e.sub !== Zb) { var r = n(e);
                            r[e.sub] = t } } else i[e.main] = t;
                return t }, t.getClass = function(t, e, n) { var r = i[t]; if (r && r[Zb] && (r = e ? r[e] : null), n && !r) throw new Error(e ? "Component " + t + "." + (e || "") + " not exists. Load it first." : t + ".type should be specified."); return r }, t.getClassesByMainType = function(t) { t = mr(t); var e = [],
                    n = i[t.main]; return n && n[Zb] ? f(n, function(t, n) { n !== Zb && e.push(t) }) : e.push(n), e }, t.hasClass = function(t) { return t = mr(t), !!i[t.main] }, t.getAllClassMainTypes = function() { var t = []; return f(i, function(e, n) { t.push(n) }), t }, t.hasSubTypes = function(t) { t = mr(t); var e = i[t.main]; return e && e[Zb] }, t.parseClassType = mr, e.registerWhenExtend) { var r = t.extend;
            r && (t.extend = function(e) { var n = r.call(this, e); return t.registerClass(n, e.type) }) } return t }

    function Sr(t) { return t > -Jb && Jb > t }

    function Ir(t) { return t > Jb || -Jb > t }

    function Tr(t, e, n, i, r) { var a = 1 - r; return a * a * (a * t + 3 * r * e) + r * r * (r * i + 3 * a * n) }

    function Cr(t, e, n, i, r) { var a = 1 - r; return 3 * (((e - t) * a + 2 * (n - e) * r) * a + (i - n) * r * r) }

    function Ar(t, e, n, i, r, a) { var o = i + 3 * (e - n) - t,
            s = 3 * (n - 2 * e + t),
            l = 3 * (e - t),
            u = t - r,
            h = s * s - 3 * o * l,
            c = s * l - 9 * o * u,
            d = l * l - 3 * s * u,
            f = 0; if (Sr(h) && Sr(c))
            if (Sr(s)) a[0] = 0;
            else { var p = -l / s;
                p >= 0 && 1 >= p && (a[f++] = p) }
        else { var g = c * c - 4 * h * d; if (Sr(g)) { var v = c / h,
                    p = -s / o + v,
                    m = -v / 2;
                p >= 0 && 1 >= p && (a[f++] = p), m >= 0 && 1 >= m && (a[f++] = m) } else if (g > 0) { var y = Qb(g),
                    x = h * s + 1.5 * o * (-c + y),
                    _ = h * s + 1.5 * o * (-c - y);
                x = 0 > x ? -$b(-x, nw) : $b(x, nw), _ = 0 > _ ? -$b(-_, nw) : $b(_, nw); var p = (-s - (x + _)) / (3 * o);
                p >= 0 && 1 >= p && (a[f++] = p) } else { var b = (2 * h * s - 3 * o * c) / (2 * Qb(h * h * h)),
                    w = Math.acos(b) / 3,
                    M = Qb(h),
                    S = Math.cos(w),
                    p = (-s - 2 * M * S) / (3 * o),
                    m = (-s + M * (S + ew * Math.sin(w))) / (3 * o),
                    I = (-s + M * (S - ew * Math.sin(w))) / (3 * o);
                p >= 0 && 1 >= p && (a[f++] = p), m >= 0 && 1 >= m && (a[f++] = m), I >= 0 && 1 >= I && (a[f++] = I) } } return f }

    function Dr(t, e, n, i, r) { var a = 6 * n - 12 * e + 6 * t,
            o = 9 * e + 3 * i - 3 * t - 9 * n,
            s = 3 * e - 3 * t,
            l = 0; if (Sr(o)) { if (Ir(a)) { var u = -s / a;
                u >= 0 && 1 >= u && (r[l++] = u) } } else { var h = a * a - 4 * o * s; if (Sr(h)) r[0] = -a / (2 * o);
            else if (h > 0) { var c = Qb(h),
                    u = (-a + c) / (2 * o),
                    d = (-a - c) / (2 * o);
                u >= 0 && 1 >= u && (r[l++] = u), d >= 0 && 1 >= d && (r[l++] = d) } } return l }

    function kr(t, e, n, i, r, a) { var o = (e - t) * r + t,
            s = (n - e) * r + e,
            l = (i - n) * r + n,
            u = (s - o) * r + o,
            h = (l - s) * r + s,
            c = (h - u) * r + u;
        a[0] = t, a[1] = o, a[2] = u, a[3] = c, a[4] = c, a[5] = h, a[6] = l, a[7] = i }

    function Pr(t, e, n, i, r, a, o, s, l, u, h) { var c, d, f, p, g, v = .005,
            m = 1 / 0;
        iw[0] = l, iw[1] = u; for (var y = 0; 1 > y; y += .05) rw[0] = Tr(t, n, r, o, y), rw[1] = Tr(e, i, a, s, y), p = Wx(iw, rw), m > p && (c = y, m = p);
        m = 1 / 0; for (var x = 0; 32 > x && !(tw > v); x++) d = c - v, f = c + v, rw[0] = Tr(t, n, r, o, d), rw[1] = Tr(e, i, a, s, d), p = Wx(rw, iw), d >= 0 && m > p ? (c = d, m = p) : (aw[0] = Tr(t, n, r, o, f), aw[1] = Tr(e, i, a, s, f), g = Wx(aw, iw), 1 >= f && m > g ? (c = f, m = g) : v *= .5); return h && (h[0] = Tr(t, n, r, o, c), h[1] = Tr(e, i, a, s, c)), Qb(m) }

    function Lr(t, e, n, i) { var r = 1 - i; return r * (r * t + 2 * i * e) + i * i * n }

    function Or(t, e, n, i) { return 2 * ((1 - i) * (e - t) + i * (n - e)) }

    function zr(t, e, n, i, r) { var a = t - 2 * e + n,
            o = 2 * (e - t),
            s = t - i,
            l = 0; if (Sr(a)) { if (Ir(o)) { var u = -s / o;
                u >= 0 && 1 >= u && (r[l++] = u) } } else { var h = o * o - 4 * a * s; if (Sr(h)) { var u = -o / (2 * a);
                u >= 0 && 1 >= u && (r[l++] = u) } else if (h > 0) { var c = Qb(h),
                    u = (-o + c) / (2 * a),
                    d = (-o - c) / (2 * a);
                u >= 0 && 1 >= u && (r[l++] = u), d >= 0 && 1 >= d && (r[l++] = d) } } return l }

    function Er(t, e, n) { var i = t + n - 2 * e; return 0 === i ? .5 : (t - e) / i }

    function Rr(t, e, n, i, r) { var a = (e - t) * i + t,
            o = (n - e) * i + e,
            s = (o - a) * i + a;
        r[0] = t, r[1] = a, r[2] = s, r[3] = s, r[4] = o, r[5] = n }

    function Br(t, e, n, i, r, a, o, s, l) { var u, h = .005,
            c = 1 / 0;
        iw[0] = o, iw[1] = s; for (var d = 0; 1 > d; d += .05) { rw[0] = Lr(t, n, r, d), rw[1] = Lr(e, i, a, d); var f = Wx(iw, rw);
            c > f && (u = d, c = f) }
        c = 1 / 0; for (var p = 0; 32 > p && !(tw > h); p++) { var g = u - h,
                v = u + h;
            rw[0] = Lr(t, n, r, g), rw[1] = Lr(e, i, a, g); var f = Wx(rw, iw); if (g >= 0 && c > f) u = g, c = f;
            else { aw[0] = Lr(t, n, r, v), aw[1] = Lr(e, i, a, v); var m = Wx(aw, iw);
                1 >= v && c > m ? (u = v, c = m) : h *= .5 } } return l && (l[0] = Lr(t, n, r, u), l[1] = Lr(e, i, a, u)), Qb(c) }

    function Nr(t, e, n) { if (0 !== t.length) { var i, r = t[0],
                a = r[0],
                o = r[0],
                s = r[1],
                l = r[1]; for (i = 1; i < t.length; i++) r = t[i], a = ow(a, r[0]), o = sw(o, r[0]), s = ow(s, r[1]), l = sw(l, r[1]);
            e[0] = a, e[1] = s, n[0] = o, n[1] = l } }

    function Vr(t, e, n, i, r, a) { r[0] = ow(t, n), r[1] = ow(e, i), a[0] = sw(t, n), a[1] = sw(e, i) }

    function Fr(t, e, n, i, r, a, o, s, l, u) { var h, c = Dr,
            d = Tr,
            f = c(t, n, r, o, pw); for (l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0, h = 0; f > h; h++) { var p = d(t, n, r, o, pw[h]);
            l[0] = ow(p, l[0]), u[0] = sw(p, u[0]) } for (f = c(e, i, a, s, gw), h = 0; f > h; h++) { var g = d(e, i, a, s, gw[h]);
            l[1] = ow(g, l[1]), u[1] = sw(g, u[1]) }
        l[0] = ow(t, l[0]), u[0] = sw(t, u[0]), l[0] = ow(o, l[0]), u[0] = sw(o, u[0]), l[1] = ow(e, l[1]), u[1] = sw(e, u[1]), l[1] = ow(s, l[1]), u[1] = sw(s, u[1]) }

    function Hr(t, e, n, i, r, a, o, s) { var l = Er,
            u = Lr,
            h = sw(ow(l(t, n, r), 1), 0),
            c = sw(ow(l(e, i, a), 1), 0),
            d = u(t, n, r, h),
            f = u(e, i, a, c);
        o[0] = ow(t, r, d), o[1] = ow(e, a, f), s[0] = sw(t, r, d), s[1] = sw(e, a, f) }

    function Gr(t, e, n, i, r, a, o, s, l) { var u = oe,
            h = se,
            c = Math.abs(r - a); if (1e-4 > c % hw && c > 1e-4) return s[0] = t - n, s[1] = e - i, l[0] = t + n, void(l[1] = e + i); if (cw[0] = uw(r) * n + t, cw[1] = lw(r) * i + e, dw[0] = uw(a) * n + t, dw[1] = lw(a) * i + e, u(s, cw, dw), h(l, cw, dw), r %= hw, 0 > r && (r += hw), a %= hw, 0 > a && (a += hw), r > a && !o ? a += hw : a > r && o && (r += hw), o) { var d = a;
            a = r, r = d } for (var f = 0; a > f; f += Math.PI / 2) f > r && (fw[0] = uw(f) * n + t, fw[1] = lw(f) * i + e, u(s, fw, s), h(l, fw, l)) }

    function Wr(t, e, n, i, r, a, o) { if (0 === r) return !1; var s = r,
            l = 0,
            u = t; if (o > e + s && o > i + s || e - s > o && i - s > o || a > t + s && a > n + s || t - s > a && n - s > a) return !1; if (t === n) return Math.abs(a - t) <= s / 2;
        l = (e - i) / (t - n), u = (t * i - n * e) / (t - n); var h = l * a - o + u,
            c = h * h / (l * l + 1); return s / 2 * s / 2 >= c }

    function Zr(t, e, n, i, r, a, o, s, l, u, h) { if (0 === l) return !1; var c = l; if (h > e + c && h > i + c && h > a + c && h > s + c || e - c > h && i - c > h && a - c > h && s - c > h || u > t + c && u > n + c && u > r + c && u > o + c || t - c > u && n - c > u && r - c > u && o - c > u) return !1; var d = Pr(t, e, n, i, r, a, o, s, u, h, null); return c / 2 >= d }

    function Ur(t, e, n, i, r, a, o, s, l) { if (0 === o) return !1; var u = o; if (l > e + u && l > i + u && l > a + u || e - u > l && i - u > l && a - u > l || s > t + u && s > n + u && s > r + u || t - u > s && n - u > s && r - u > s) return !1; var h = Br(t, e, n, i, r, a, s, l, null); return u / 2 >= h }

    function Xr(t) { return t %= Dw, 0 > t && (t += Dw), t }

    function Yr(t, e, n, i, r, a, o, s, l) { if (0 === o) return !1; var u = o;
        s -= t, l -= e; var h = Math.sqrt(s * s + l * l); if (h - u > n || n > h + u) return !1; if (Math.abs(i - r) % kw < 1e-4) return !0; if (a) { var c = i;
            i = Xr(r), r = Xr(c) } else i = Xr(i), r = Xr(r);
        i > r && (r += kw); var d = Math.atan2(l, s); return 0 > d && (d += kw), d >= i && r >= d || d + kw >= i && r >= d + kw }

    function jr(t, e, n, i, r, a) { if (a > e && a > i || e > a && i > a) return 0; if (i === e) return 0; var o = e > i ? 1 : -1,
            s = (a - e) / (i - e);
        (1 === s || 0 === s) && (o = e > i ? .5 : -.5); var l = s * (n - t) + t; return l === r ? 1 / 0 : l > r ? o : 0 }

    function qr(t, e) { return Math.abs(t - e) < Ow }

    function Kr() { var t = Ew[0];
        Ew[0] = Ew[1], Ew[1] = t }

    function $r(t, e, n, i, r, a, o, s, l, u) { if (u > e && u > i && u > a && u > s || e > u && i > u && a > u && s > u) return 0; var h = Ar(e, i, a, s, u, zw); if (0 === h) return 0; for (var c, d, f = 0, p = -1, g = 0; h > g; g++) { var v = zw[g],
                m = 0 === v || 1 === v ? .5 : 1,
                y = Tr(t, n, r, o, v);
            l > y || (0 > p && (p = Dr(e, i, a, s, Ew), Ew[1] < Ew[0] && p > 1 && Kr(), c = Tr(e, i, a, s, Ew[0]), p > 1 && (d = Tr(e, i, a, s, Ew[1]))), f += 2 === p ? v < Ew[0] ? e > c ? m : -m : v < Ew[1] ? c > d ? m : -m : d > s ? m : -m : v < Ew[0] ? e > c ? m : -m : c > s ? m : -m) } return f }

    function Qr(t, e, n, i, r, a, o, s) { if (s > e && s > i && s > a || e > s && i > s && a > s) return 0; var l = zr(e, i, a, s, zw); if (0 === l) return 0; var u = Er(e, i, a); if (u >= 0 && 1 >= u) { for (var h = 0, c = Lr(e, i, a, u), d = 0; l > d; d++) { var f = 0 === zw[d] || 1 === zw[d] ? .5 : 1,
                    p = Lr(t, n, r, zw[d]);
                o > p || (h += zw[d] < u ? e > c ? f : -f : c > a ? f : -f) } return h } var f = 0 === zw[0] || 1 === zw[0] ? .5 : 1,
            p = Lr(t, n, r, zw[0]); return o > p ? 0 : e > a ? f : -f }

    function Jr(t, e, n, i, r, a, o, s) { if (s -= e, s > n || -n > s) return 0; var l = Math.sqrt(n * n - s * s);
        zw[0] = -l, zw[1] = l; var u = Math.abs(i - r); if (1e-4 > u) return 0; if (1e-4 > u % Lw) { i = 0, r = Lw; var h = a ? 1 : -1; return o >= zw[0] + t && o <= zw[1] + t ? h : 0 } if (a) { var l = i;
            i = Xr(r), r = Xr(l) } else i = Xr(i), r = Xr(r);
        i > r && (r += Lw); for (var c = 0, d = 0; 2 > d; d++) { var f = zw[d]; if (f + t > o) { var p = Math.atan2(s, f),
                    h = a ? 1 : -1;
                0 > p && (p = Lw + p), (p >= i && r >= p || p + Lw >= i && r >= p + Lw) && (p > Math.PI / 2 && p < 1.5 * Math.PI && (h = -h), c += h) } } return c }

    function ta(t, e, n, i, r) { for (var a = 0, o = 0, s = 0, l = 0, u = 0, h = 0; h < t.length;) { var c = t[h++]; switch (c === Pw.M && h > 1 && (n || (a += jr(o, s, l, u, i, r))), 1 === h && (o = t[h], s = t[h + 1], l = o, u = s), c) {
                case Pw.M:
                    l = t[h++], u = t[h++], o = l, s = u; break;
                case Pw.L:
                    if (n) { if (Wr(o, s, t[h], t[h + 1], e, i, r)) return !0 } else a += jr(o, s, t[h], t[h + 1], i, r) || 0;
                    o = t[h++], s = t[h++]; break;
                case Pw.C:
                    if (n) { if (Zr(o, s, t[h++], t[h++], t[h++], t[h++], t[h], t[h + 1], e, i, r)) return !0 } else a += $r(o, s, t[h++], t[h++], t[h++], t[h++], t[h], t[h + 1], i, r) || 0;
                    o = t[h++], s = t[h++]; break;
                case Pw.Q:
                    if (n) { if (Ur(o, s, t[h++], t[h++], t[h], t[h + 1], e, i, r)) return !0 } else a += Qr(o, s, t[h++], t[h++], t[h], t[h + 1], i, r) || 0;
                    o = t[h++], s = t[h++]; break;
                case Pw.A:
                    var d = t[h++],
                        f = t[h++],
                        p = t[h++],
                        g = t[h++],
                        v = t[h++],
                        m = t[h++];
                    h += 1; var y = 1 - t[h++],
                        x = Math.cos(v) * p + d,
                        _ = Math.sin(v) * g + f;
                    h > 1 ? a += jr(o, s, x, _, i, r) : (l = x, u = _); var b = (i - d) * g / p + d; if (n) { if (Yr(d, f, g, v, v + m, y, e, b, r)) return !0 } else a += Jr(d, f, g, v, v + m, y, b, r);
                    o = Math.cos(v + m) * p + d, s = Math.sin(v + m) * g + f; break;
                case Pw.R:
                    l = o = t[h++], u = s = t[h++]; var w = t[h++],
                        M = t[h++],
                        x = l + w,
                        _ = u + M; if (n) { if (Wr(l, u, x, u, e, i, r) || Wr(x, u, x, _, e, i, r) || Wr(x, _, l, _, e, i, r) || Wr(l, _, l, u, e, i, r)) return !0 } else a += jr(x, u, x, _, i, r), a += jr(l, _, l, u, i, r); break;
                case Pw.Z:
                    if (n) { if (Wr(o, s, l, u, e, i, r)) return !0 } else a += jr(o, s, l, u, i, r);
                    o = l, s = u } } return n || qr(s, u) || (a += jr(o, s, l, u, i, r) || 0), 0 !== a }

    function ea(t, e, n) { return ta(t, 0, !1, e, n) }

    function na(t, e, n, i) { return ta(t, e, !0, n, i) }

    function ia(t) { Ai.call(this, t), this.path = null }

    function ra(t, e, n, i, r, a, o, s, l, u, h) { var c = l * (Yw / 180),
            d = Xw(c) * (t - n) / 2 + Uw(c) * (e - i) / 2,
            f = -1 * Uw(c) * (t - n) / 2 + Xw(c) * (e - i) / 2,
            p = d * d / (o * o) + f * f / (s * s);
        p > 1 && (o *= Zw(p), s *= Zw(p)); var g = (r === a ? -1 : 1) * Zw((o * o * s * s - o * o * f * f - s * s * d * d) / (o * o * f * f + s * s * d * d)) || 0,
            v = g * o * f / s,
            m = g * -s * d / o,
            y = (t + n) / 2 + Xw(c) * v - Uw(c) * m,
            x = (e + i) / 2 + Uw(c) * v + Xw(c) * m,
            _ = Kw([1, 0], [(d - v) / o, (f - m) / s]),
            b = [(d - v) / o, (f - m) / s],
            w = [(-1 * d - v) / o, (-1 * f - m) / s],
            M = Kw(b, w);
        qw(b, w) <= -1 && (M = Yw), qw(b, w) >= 1 && (M = 0), 0 === a && M > 0 && (M -= 2 * Yw), 1 === a && 0 > M && (M += 2 * Yw), h.addData(u, y, x, o, s, _, M, c, a) }

    function aa(t) { if (!t) return new Aw; for (var e, n = 0, i = 0, r = n, a = i, o = new Aw, s = Aw.CMD, l = t.match($w), u = 0; u < l.length; u++) { for (var h, c = l[u], d = c.charAt(0), f = c.match(Qw) || [], p = f.length, g = 0; p > g; g++) f[g] = parseFloat(f[g]); for (var v = 0; p > v;) { var m, y, x, _, b, w, M, S = n,
                    I = i; switch (d) {
                    case "l":
                        n += f[v++], i += f[v++], h = s.L, o.addData(h, n, i); break;
                    case "L":
                        n = f[v++], i = f[v++], h = s.L, o.addData(h, n, i); break;
                    case "m":
                        n += f[v++], i += f[v++], h = s.M, o.addData(h, n, i), r = n, a = i, d = "l"; break;
                    case "M":
                        n = f[v++], i = f[v++], h = s.M, o.addData(h, n, i), r = n, a = i, d = "L"; break;
                    case "h":
                        n += f[v++], h = s.L, o.addData(h, n, i); break;
                    case "H":
                        n = f[v++], h = s.L, o.addData(h, n, i); break;
                    case "v":
                        i += f[v++], h = s.L, o.addData(h, n, i); break;
                    case "V":
                        i = f[v++], h = s.L, o.addData(h, n, i); break;
                    case "C":
                        h = s.C, o.addData(h, f[v++], f[v++], f[v++], f[v++], f[v++], f[v++]), n = f[v - 2], i = f[v - 1]; break;
                    case "c":
                        h = s.C, o.addData(h, f[v++] + n, f[v++] + i, f[v++] + n, f[v++] + i, f[v++] + n, f[v++] + i), n += f[v - 2], i += f[v - 1]; break;
                    case "S":
                        m = n, y = i; var T = o.len(),
                            C = o.data;
                        e === s.C && (m += n - C[T - 4], y += i - C[T - 3]), h = s.C, S = f[v++], I = f[v++], n = f[v++], i = f[v++], o.addData(h, m, y, S, I, n, i); break;
                    case "s":
                        m = n, y = i; var T = o.len(),
                            C = o.data;
                        e === s.C && (m += n - C[T - 4], y += i - C[T - 3]), h = s.C, S = n + f[v++], I = i + f[v++], n += f[v++], i += f[v++], o.addData(h, m, y, S, I, n, i); break;
                    case "Q":
                        S = f[v++], I = f[v++], n = f[v++], i = f[v++], h = s.Q, o.addData(h, S, I, n, i); break;
                    case "q":
                        S = f[v++] + n, I = f[v++] + i, n += f[v++], i += f[v++], h = s.Q, o.addData(h, S, I, n, i); break;
                    case "T":
                        m = n, y = i; var T = o.len(),
                            C = o.data;
                        e === s.Q && (m += n - C[T - 4], y += i - C[T - 3]), n = f[v++], i = f[v++], h = s.Q, o.addData(h, m, y, n, i); break;
                    case "t":
                        m = n, y = i; var T = o.len(),
                            C = o.data;
                        e === s.Q && (m += n - C[T - 4], y += i - C[T - 3]), n += f[v++], i += f[v++], h = s.Q, o.addData(h, m, y, n, i); break;
                    case "A":
                        x = f[v++], _ = f[v++], b = f[v++], w = f[v++], M = f[v++], S = n, I = i, n = f[v++], i = f[v++], h = s.A, ra(S, I, n, i, w, M, x, _, b, h, o); break;
                    case "a":
                        x = f[v++], _ = f[v++], b = f[v++], w = f[v++], M = f[v++], S = n, I = i, n += f[v++], i += f[v++], h = s.A, ra(S, I, n, i, w, M, x, _, b, h, o) } }("z" === d || "Z" === d) && (h = s.Z, o.addData(h), n = r, i = a), e = h } return o.toStatic(), o }

    function oa(t, e) { var n = aa(t); return e = e || {}, e.buildPath = function(t) { if (t.setData) { t.setData(n.data); var e = t.getContext();
                e && t.rebuildPath(e) } else { var e = t;
                n.rebuildPath(e) } }, e.applyTransform = function(t) { Ww(n, t), this.dirty(!0) }, e }

    function sa(t, e) { return new ia(oa(t, e)) }

    function la(t, e) { return ia.extend(oa(t, e)) }

    function ua(t, e) { for (var n = [], i = t.length, r = 0; i > r; r++) { var a = t[r];
            a.path || a.createPathProxy(), a.__dirtyPath && a.buildPath(a.path, a.shape, !0), n.push(a.path) } var o = new ia(e); return o.createPathProxy(), o.buildPath = function(t) { t.appendPath(n); var e = t.getContext();
            e && t.rebuildPath(e) }, o }

    function ha(t, e, n, i, r, a, o) { var s = .5 * (n - t),
            l = .5 * (i - e); return (2 * (e - n) + s + l) * o + (-3 * (e - n) - 2 * s - l) * a + s * r + e }

    function ca(t, e, n) { var i = e.points,
            r = e.smooth; if (i && i.length >= 2) { if (r && "spline" !== r) { var a = oM(i, r, n, e.smoothConstraint);
                t.moveTo(i[0][0], i[0][1]); for (var o = i.length, s = 0;
                    (n ? o : o - 1) > s; s++) { var l = a[2 * s],
                        u = a[2 * s + 1],
                        h = i[(s + 1) % o];
                    t.bezierCurveTo(l[0], l[1], u[0], u[1], h[0], h[1]) } } else { "spline" === r && (i = aM(i, n)), t.moveTo(i[0][0], i[0][1]); for (var s = 1, c = i.length; c > s; s++) t.lineTo(i[s][0], i[s][1]) }
            n && t.closePath() } }

    function da(t, e, n) { if (e) { var i = e.x1,
                r = e.x2,
                a = e.y1,
                o = e.y2;
            t.x1 = i, t.x2 = r, t.y1 = a, t.y2 = o; var s = n && n.lineWidth;
            s && (uM(2 * i) === uM(2 * r) && (t.x1 = t.x2 = pa(i, s, !0)), uM(2 * a) === uM(2 * o) && (t.y1 = t.y2 = pa(a, s, !0))) } }

    function fa(t, e, n) { if (e) { var i = e.x,
                r = e.y,
                a = e.width,
                o = e.height;
            t.x = i, t.y = r, t.width = a, t.height = o; var s = n && n.lineWidth;
            s && (t.x = pa(i, s, !0), t.y = pa(r, s, !0), t.width = Math.max(pa(i + a, s, !1) - t.x, 0 === a ? 0 : 1), t.height = Math.max(pa(r + o, s, !1) - t.y, 0 === o ? 0 : 1)) } }

    function pa(t, e, n) { if (!e) return t; var i = uM(2 * t); return (i + uM(e)) % 2 === 0 ? i / 2 : (i + (n ? 1 : -1)) / 2 }

    function ga(t, e, n) { var i = t.cpx2,
            r = t.cpy2; return null === i || null === r ? [(n ? Cr : Tr)(t.x1, t.cpx1, t.cpx2, t.x2, e), (n ? Cr : Tr)(t.y1, t.cpy1, t.cpy2, t.y2, e)] : [(n ? Or : Lr)(t.x1, t.cpx1, t.x2, e), (n ? Or : Lr)(t.y1, t.cpy1, t.y2, e)] }

    function va(t) { Ai.call(this, t), this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.notClear = !0 }

    function ma(t) { return ia.extend(t) }

    function ya(t, e) { return la(t, e) }

    function xa(t, e) { PM[t] = e }

    function _a(t) { return PM.hasOwnProperty(t) ? PM[t] : void 0 }

    function ba(t, e, n, i) { var r = sa(t, e); return n && ("center" === i && (n = Ma(n, r.getBoundingRect())), Sa(r, n)), r }

    function wa(t, e, n) { var i = new Di({ style: { image: t, x: e.x, y: e.y, width: e.width, height: e.height }, onload: function(t) { if ("center" === n) { var r = { width: t.width, height: t.height };
                    i.setStyle(Ma(e, r)) } } }); return i }

    function Ma(t, e) { var n, i = e.width / e.height,
            r = t.height * i;
        r <= t.width ? n = t.height : (r = t.width, n = r / i); var a = t.x + t.width / 2,
            o = t.y + t.height / 2; return { x: a - r / 2, y: o - n / 2, width: r, height: n } }

    function Sa(t, e) { if (t.applyTransform) { var n = t.getBoundingRect(),
                i = n.calculateTransform(e);
            t.applyTransform(i) } }

    function Ia(t) { return da(t.shape, t.shape, t.style), t }

    function Ta(t) { return fa(t.shape, t.shape, t.style), t }

    function Ca(t) { return null != t && "none" !== t }

    function Aa(t) { if ("string" != typeof t) return t; var e = zM.get(t); return e || (e = rn(t, -.1), 1e4 > EM && (zM.set(t, e), EM++)), e }

    function Da(t) { if (t.__hoverStlDirty) { t.__hoverStlDirty = !1; var e = t.__hoverStl; if (!e) return void(t.__cachedNormalStl = t.__cachedNormalZ2 = null); var n = t.__cachedNormalStl = {};
            t.__cachedNormalZ2 = t.z2; var i = t.style; for (var r in e) null != e[r] && (n[r] = i[r]);
            n.fill = i.fill, n.stroke = i.stroke } }

    function ka(t) { var e = t.__hoverStl; if (e && !t.__highlighted) { var n = t.__zr,
                i = t.useHoverLayer && n && "canvas" === n.painter.type; if (t.__highlighted = i ? "layer" : "plain", !(t.isGroup || !n && t.useHoverLayer)) { var r = t,
                    a = t.style;
                i && (r = n.addHover(t), a = r.style), Ja(a), i || Da(r), a.extendFrom(e), Pa(a, e, "fill"), Pa(a, e, "stroke"), Qa(a), i || (t.dirty(!1), t.z2 += IM) } } }

    function Pa(t, e, n) {!Ca(e[n]) && Ca(t[n]) && (t[n] = Aa(t[n])) }

    function La(t) { var e = t.__highlighted; if (e && (t.__highlighted = !1, !t.isGroup))
            if ("layer" === e) t.__zr && t.__zr.removeHover(t);
            else { var n = t.style,
                    i = t.__cachedNormalStl;
                i && (Ja(n), t.setStyle(i), Qa(n)); var r = t.__cachedNormalZ2;
                null != r && t.z2 - r === IM && (t.z2 = r) } }

    function Oa(t, e, n) { var i, r = AM,
            a = AM;
        t.__highlighted && (r = CM, i = !0), e(t, n), t.__highlighted && (a = CM, i = !0), t.isGroup && t.traverse(function(t) {!t.isGroup && e(t, n) }), i && t.__highDownOnUpdate && t.__highDownOnUpdate(r, a) }

    function za(t, e) { e = t.__hoverStl = e !== !1 && (t.hoverStyle || e || {}), t.__hoverStlDirty = !0, t.__highlighted && (t.__cachedNormalStl = null, La(t), ka(t)) }

    function Ea(t) {!Va(this, t) && !this.__highByOuter && Oa(this, ka) }

    function Ra(t) {!Va(this, t) && !this.__highByOuter && Oa(this, La) }

    function Ba(t) { this.__highByOuter |= 1 << (t || 0), Oa(this, ka) }

    function Na(t) {!(this.__highByOuter &= ~(1 << (t || 0))) && Oa(this, La) }

    function Va(t, e) { return t.__highDownSilentOnTouch && e.zrByTouch }

    function Fa(t, e) { Ha(t, !0), Oa(t, za, e) }

    function Ha(t, e) { var n = e === !1; if (t.__highDownSilentOnTouch = t.highDownSilentOnTouch, t.__highDownOnUpdate = t.highDownOnUpdate, !n || t.__highDownDispatcher) { var i = n ? "off" : "on";
            t[i]("mouseover", Ea)[i]("mouseout", Ra), t[i]("emphasis", Ba)[i]("normal", Na), t.__highByOuter = t.__highByOuter || 0, t.__highDownDispatcher = !n } }

    function Ga(t) { return !(!t || !t.__highDownDispatcher) }

    function Wa(t) { var e = kM[t]; return null == e && 32 >= DM && (e = kM[t] = DM++), e }

    function Za(t, e, n, i, r, a, o) { r = r || SM; var s, l = r.labelFetcher,
            u = r.labelDataIndex,
            h = r.labelDimIndex,
            c = n.getShallow("show"),
            d = i.getShallow("show");
        (c || d) && (l && (s = l.getFormattedLabel(u, "normal", null, h)), null == s && (s = b(r.defaultText) ? r.defaultText(u, r) : r.defaultText)); var f = c ? s : null,
            p = d ? D(l ? l.getFormattedLabel(u, "emphasis", null, h) : null, s) : null;
        (null != f || null != p) && (Xa(t, n, a, r), Xa(e, i, o, r, !0)), t.text = f, e.text = p }

    function Ua(t, e, n) { var i = t.style;
        e && (Ja(i), t.setStyle(e), Qa(i)), i = t.__hoverStl, n && i && (Ja(i), o(i, n), Qa(i)) }

    function Xa(t, e, n, i, r) { return ja(t, e, i, r), n && o(t, n), t }

    function Ya(t, e, n) { var i, r = { isRectText: !0 };
        n === !1 ? i = !0 : r.autoColor = n, ja(t, e, r, i) }

    function ja(t, e, n, i) { if (n = n || SM, n.isRectText) { var r;
            n.getTextPosition ? r = n.getTextPosition(e, i) : (r = e.getShallow("position") || (i ? null : "inside"), "outside" === r && (r = "top")), t.textPosition = r, t.textOffset = e.getShallow("offset"); var a = e.getShallow("rotate");
            null != a && (a *= Math.PI / 180), t.textRotation = a, t.textDistance = D(e.getShallow("distance"), i ? null : 5) } var o, s = e.ecModel,
            l = s && s.option.textStyle,
            u = qa(e); if (u) { o = {}; for (var h in u)
                if (u.hasOwnProperty(h)) { var c = e.getModel(["rich", h]);
                    Ka(o[h] = {}, c, l, n, i) } } return t.rich = o, Ka(t, e, l, n, i, !0), n.forceRich && !n.textStyle && (n.textStyle = {}), t }

    function qa(t) { for (var e; t && t !== t.ecModel;) { var n = (t.option || SM).rich; if (n) { e = e || {}; for (var i in n) n.hasOwnProperty(i) && (e[i] = 1) }
            t = t.parentModel } return e }

    function Ka(t, e, n, i, r, a) { n = !r && n || SM, t.textFill = $a(e.getShallow("color"), i) || n.color, t.textStroke = $a(e.getShallow("textBorderColor"), i) || n.textBorderColor, t.textStrokeWidth = D(e.getShallow("textBorderWidth"), n.textBorderWidth), r || (a && (t.insideRollbackOpt = i, Qa(t)), null == t.textFill && (t.textFill = i.autoColor)), t.fontStyle = e.getShallow("fontStyle") || n.fontStyle, t.fontWeight = e.getShallow("fontWeight") || n.fontWeight, t.fontSize = e.getShallow("fontSize") || n.fontSize, t.fontFamily = e.getShallow("fontFamily") || n.fontFamily, t.textAlign = e.getShallow("align"), t.textVerticalAlign = e.getShallow("verticalAlign") || e.getShallow("baseline"), t.textLineHeight = e.getShallow("lineHeight"), t.textWidth = e.getShallow("width"), t.textHeight = e.getShallow("height"), t.textTag = e.getShallow("tag"), a && i.disableBox || (t.textBackgroundColor = $a(e.getShallow("backgroundColor"), i), t.textPadding = e.getShallow("padding"), t.textBorderColor = $a(e.getShallow("borderColor"), i), t.textBorderWidth = e.getShallow("borderWidth"), t.textBorderRadius = e.getShallow("borderRadius"), t.textBoxShadowColor = e.getShallow("shadowColor"), t.textBoxShadowBlur = e.getShallow("shadowBlur"), t.textBoxShadowOffsetX = e.getShallow("shadowOffsetX"), t.textBoxShadowOffsetY = e.getShallow("shadowOffsetY")), t.textShadowColor = e.getShallow("textShadowColor") || n.textShadowColor, t.textShadowBlur = e.getShallow("textShadowBlur") || n.textShadowBlur, t.textShadowOffsetX = e.getShallow("textShadowOffsetX") || n.textShadowOffsetX, t.textShadowOffsetY = e.getShallow("textShadowOffsetY") || n.textShadowOffsetY }

    function $a(t, e) { return "auto" !== t ? t : e && e.autoColor ? e.autoColor : null }

    function Qa(t) { var e, n = t.textPosition,
            i = t.insideRollbackOpt; if (i && null == t.textFill) { var r = i.autoColor,
                a = i.isRectText,
                o = i.useInsideStyle,
                s = o !== !1 && (o === !0 || a && n && "string" == typeof n && n.indexOf("inside") >= 0),
                l = !s && null != r;
            (s || l) && (e = { textFill: t.textFill, textStroke: t.textStroke, textStrokeWidth: t.textStrokeWidth }), s && (t.textFill = "#fff", null == t.textStroke && (t.textStroke = r, null == t.textStrokeWidth && (t.textStrokeWidth = 2))), l && (t.textFill = r) }
        t.insideRollback = e }

    function Ja(t) { var e = t.insideRollback;
        e && (t.textFill = e.textFill, t.textStroke = e.textStroke, t.textStrokeWidth = e.textStrokeWidth, t.insideRollback = null) }

    function to(t, e) { var n = e && e.getModel("textStyle"); return z([t.fontStyle || n && n.getShallow("fontStyle") || "", t.fontWeight || n && n.getShallow("fontWeight") || "", (t.fontSize || n && n.getShallow("fontSize") || 12) + "px", t.fontFamily || n && n.getShallow("fontFamily") || "sans-serif"].join(" ")) }

    function eo(t, e, n, i, r, a) { "function" == typeof r && (a = r, r = null); var o = i && i.isAnimationEnabled(); if (o) { var s = t ? "Update" : "",
                l = i.getShallow("animationDuration" + s),
                u = i.getShallow("animationEasing" + s),
                h = i.getShallow("animationDelay" + s); "function" == typeof h && (h = h(r, i.getAnimationDelayParams ? i.getAnimationDelayParams(e, r) : null)), "function" == typeof l && (l = l(r)), l > 0 ? e.animateTo(n, l, h || 0, u, a, !!a) : (e.stopAnimation(), e.attr(n), a && a()) } else e.stopAnimation(), e.attr(n), a && a() }

    function no(t, e, n, i, r) { eo(!0, t, e, n, i, r) }

    function io(t, e, n, i, r) { eo(!1, t, e, n, i, r) }

    function ro(t, e) { for (var n = ze([]); t && t !== e;) Re(n, t.getLocalTransform(), n), t = t.parent; return n }

    function ao(t, e, n) { return e && !d(e) && (e = u_.getLocalTransform(e)), n && (e = Fe([], e)), ae([], t, e) }

    function oo(t, e, n) { var i = 0 === e[4] || 0 === e[5] || 0 === e[0] ? 1 : Math.abs(2 * e[4] / e[0]),
            r = 0 === e[4] || 0 === e[5] || 0 === e[2] ? 1 : Math.abs(2 * e[4] / e[2]),
            a = ["left" === t ? -i : "right" === t ? i : 0, "top" === t ? -r : "bottom" === t ? r : 0]; return a = ao(a, e, n), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top" }

    function so(t, e, n) {
        function i(t) { var e = {}; return t.traverse(function(t) {!t.isGroup && t.anid && (e[t.anid] = t) }), e }

        function r(t) { var e = { position: W(t.position), rotation: t.rotation }; return t.shape && (e.shape = o({}, t.shape)), e } if (t && e) { var a = i(t);
            e.traverse(function(t) { if (!t.isGroup && t.anid) { var e = a[t.anid]; if (e) { var i = r(t);
                        t.attr(r(e)), no(t, i, n, t.dataIndex) } } }) } }

    function lo(t, e) { return p(t, function(t) { var n = t[0];
            n = wM(n, e.x), n = MM(n, e.x + e.width); var i = t[1]; return i = wM(i, e.y), i = MM(i, e.y + e.height), [n, i] }) }

    function uo(t, e) { var n = wM(t.x, e.x),
            i = MM(t.x + t.width, e.x + e.width),
            r = wM(t.y, e.y),
            a = MM(t.y + t.height, e.y + e.height); return i >= n && a >= r ? { x: n, y: r, width: i - n, height: a - r } : void 0 }

    function ho(t, e, n) { e = o({ rectHover: !0 }, e); var i = e.style = { strokeNoScale: !0 }; return n = n || { x: -1, y: -1, width: 2, height: 2 }, t ? 0 === t.indexOf("image://") ? (i.image = t.slice(8), s(i, n), new Di(e)) : ba(t.replace("path://", ""), e, n, "center") : void 0 }

    function co(t, e, n, i, r) { for (var a = 0, o = r[r.length - 1]; a < r.length; a++) { var s = r[a]; if (fo(t, e, n, i, s[0], s[1], o[0], o[1])) return !0;
            o = s } }

    function fo(t, e, n, i, r, a, o, s) { var l = n - t,
            u = i - e,
            h = o - r,
            c = s - a,
            d = po(h, c, l, u); if (go(d)) return !1; var f = t - r,
            p = e - a,
            g = po(f, p, l, u) / d; if (0 > g || g > 1) return !1; var v = po(f, p, h, c) / d; return 0 > v || v > 1 ? !1 : !0 }

    function po(t, e, n, i) { return t * i - n * e }

    function go(t) {
        return 1e-6 >= t && t >= -1e-6
    }

    function vo(t, e, n) { this.parentModel = e, this.ecModel = n, this.option = t }

    function mo(t, e, n) { for (var i = 0; i < e.length && (!e[i] || (t = t && "object" == typeof t ? t[e[i]] : null, null != t)); i++); return null == t && n && (t = n.get(e)), t }

    function yo(t, e) { var n = GM(t).getParent; return n ? n.call(t, e) : t.parentModel }

    function xo(t) { return [t || "", WM++, Math.random().toFixed(5)].join("_") }

    function _o(t) { var e = {}; return t.registerSubTypeDefaulter = function(t, n) { t = mr(t), e[t.main] = n }, t.determineSubType = function(n, i) { var r = i.type; if (!r) { var a = mr(n).main;
                t.hasSubTypes(n) && e[a] && (r = e[a](i)) } return r }, t }

    function bo(t, e) {
        function n(t) { var n = {},
                a = []; return f(t, function(o) { var s = i(n, o),
                    l = s.originalDeps = e(o),
                    h = r(l, t);
                s.entryCount = h.length, 0 === s.entryCount && a.push(o), f(h, function(t) { u(s.predecessor, t) < 0 && s.predecessor.push(t); var e = i(n, t);
                    u(e.successor, t) < 0 && e.successor.push(o) }) }), { graph: n, noEntryList: a } }

        function i(t, e) { return t[e] || (t[e] = { predecessor: [], successor: [] }), t[e] }

        function r(t, e) { var n = []; return f(t, function(t) { u(e, t) >= 0 && n.push(t) }), n }
        t.topologicalTravel = function(t, e, i, r) {
            function a(t) { l[t].entryCount--, 0 === l[t].entryCount && u.push(t) }

            function o(t) { h[t] = !0, a(t) } if (t.length) { var s = n(e),
                    l = s.graph,
                    u = s.noEntryList,
                    h = {}; for (f(t, function(t) { h[t] = !0 }); u.length;) { var c = u.pop(),
                        d = l[c],
                        p = !!h[c];
                    p && (i.call(r, c, d.originalDeps.slice()), delete h[c]), f(d.successor, p ? o : a) }
                f(h, function() { throw new Error("Circle dependency may exists") }) } } }

    function wo(t) { return t.replace(/^\s+|\s+$/g, "") }

    function Mo(t, e, n, i) { var r = e[1] - e[0],
            a = n[1] - n[0]; if (0 === r) return 0 === a ? n[0] : (n[0] + n[1]) / 2; if (i)
            if (r > 0) { if (t <= e[0]) return n[0]; if (t >= e[1]) return n[1] } else { if (t >= e[0]) return n[0]; if (t <= e[1]) return n[1] }
        else { if (t === e[0]) return n[0]; if (t === e[1]) return n[1] } return (t - e[0]) / r * a + n[0] }

    function So(t, e) { switch (t) {
            case "center":
            case "middle":
                t = "50%"; break;
            case "left":
            case "top":
                t = "0%"; break;
            case "right":
            case "bottom":
                t = "100%" } return "string" == typeof t ? wo(t).match(/%$/) ? parseFloat(t) / 100 * e : parseFloat(t) : null == t ? 0 / 0 : +t }

    function Io(t, e, n) { return null == e && (e = 10), e = Math.min(Math.max(0, e), 20), t = (+t).toFixed(e), n ? t : +t }

    function To(t) { return t.sort(function(t, e) { return t - e }), t }

    function Co(t) { if (t = +t, isNaN(t)) return 0; for (var e = 1, n = 0; Math.round(t * e) / e !== t;) e *= 10, n++; return n }

    function Ao(t) { var e = t.toString(),
            n = e.indexOf("e"); if (n > 0) { var i = +e.slice(n + 1); return 0 > i ? -i : 0 } var r = e.indexOf("."); return 0 > r ? 0 : e.length - 1 - r }

    function Do(t, e) { var n = Math.log,
            i = Math.LN10,
            r = Math.floor(n(t[1] - t[0]) / i),
            a = Math.round(n(Math.abs(e[1] - e[0])) / i),
            o = Math.min(Math.max(-r + a, 0), 20); return isFinite(o) ? o : 20 }

    function ko(t, e, n) { if (!t[e]) return 0; var i = g(t, function(t, e) { return t + (isNaN(e) ? 0 : e) }, 0); if (0 === i) return 0; for (var r = Math.pow(10, n), a = p(t, function(t) { return (isNaN(t) ? 0 : t) / i * r * 100 }), o = 100 * r, s = p(a, function(t) { return Math.floor(t) }), l = g(s, function(t, e) { return t + e }, 0), u = p(a, function(t, e) { return t - s[e] }); o > l;) { for (var h = Number.NEGATIVE_INFINITY, c = null, d = 0, f = u.length; f > d; ++d) u[d] > h && (h = u[d], c = d);++s[c], u[c] = 0, ++l } return s[e] / r }

    function Po(t) { var e = 2 * Math.PI; return (t % e + e) % e }

    function Lo(t) { return t > -ZM && ZM > t }

    function Oo(t) { if (t instanceof Date) return t; if ("string" == typeof t) { var e = XM.exec(t); if (!e) return new Date(0 / 0); if (e[8]) { var n = +e[4] || 0; return "Z" !== e[8].toUpperCase() && (n -= e[8].slice(0, 3)), new Date(Date.UTC(+e[1], +(e[2] || 1) - 1, +e[3] || 1, n, +(e[5] || 0), +e[6] || 0, +e[7] || 0)) } return new Date(+e[1], +(e[2] || 1) - 1, +e[3] || 1, +e[4] || 0, +(e[5] || 0), +e[6] || 0, +e[7] || 0) } return new Date(null == t ? 0 / 0 : Math.round(t)) }

    function zo(t) { return Math.pow(10, Eo(t)) }

    function Eo(t) { if (0 === t) return 0; var e = Math.floor(Math.log(t) / Math.LN10); return t / Math.pow(10, e) >= 10 && e++, e }

    function Ro(t, e) { var n, i = Eo(t),
            r = Math.pow(10, i),
            a = t / r; return n = e ? 1.5 > a ? 1 : 2.5 > a ? 2 : 4 > a ? 3 : 7 > a ? 5 : 10 : 1 > a ? 1 : 2 > a ? 2 : 3 > a ? 3 : 5 > a ? 5 : 10, t = n * r, i >= -20 ? +t.toFixed(0 > i ? -i : 0) : t }

    function Bo(t, e) { var n = (t.length - 1) * e + 1,
            i = Math.floor(n),
            r = +t[i - 1],
            a = n - i; return a ? r + a * (t[i] - r) : r }

    function No(t) {
        function e(t, n, i) { return t.interval[i] < n.interval[i] || t.interval[i] === n.interval[i] && (t.close[i] - n.close[i] === (i ? -1 : 1) || !i && e(t, n, 1)) }
        t.sort(function(t, n) { return e(t, n, 0) ? -1 : 1 }); for (var n = -1 / 0, i = 1, r = 0; r < t.length;) { for (var a = t[r].interval, o = t[r].close, s = 0; 2 > s; s++) a[s] <= n && (a[s] = n, o[s] = s ? 1 : 1 - i), n = a[s], i = o[s];
            a[0] === a[1] && o[0] * o[1] !== 1 ? t.splice(r, 1) : r++ } return t }

    function Vo(t) { return t - parseFloat(t) >= 0 }

    function Fo(t) { return isNaN(t) ? "-" : (t = (t + "").split("."), t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t.length > 1 ? "." + t[1] : "")) }

    function Ho(t, e) { return t = (t || "").toLowerCase().replace(/-(.)/g, function(t, e) { return e.toUpperCase() }), e && t && (t = t.charAt(0).toUpperCase() + t.slice(1)), t }

    function Go(t) { return null == t ? "" : (t + "").replace(qM, function(t, e) { return KM[e] }) }

    function Wo(t, e, n) { _(e) || (e = [e]); var i = e.length; if (!i) return ""; for (var r = e[0].$vars || [], a = 0; a < r.length; a++) { var o = $M[a];
            t = t.replace(QM(o), QM(o, 0)) } for (var s = 0; i > s; s++)
            for (var l = 0; l < r.length; l++) { var u = e[s][r[l]];
                t = t.replace(QM($M[l], s), n ? Go(u) : u) }
        return t }

    function Zo(t, e, n) { return f(e, function(e, i) { t = t.replace("{" + i + "}", n ? Go(e) : e) }), t }

    function Uo(t, e) { t = w(t) ? { color: t, extraCssText: e } : t || {}; var n = t.color,
            i = t.type,
            e = t.extraCssText,
            r = t.renderMode || "html",
            a = t.markerId || "X"; return n ? "html" === r ? "subItem" === i ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + Go(n) + ";" + (e || "") + '"></span>' : '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:' + Go(n) + ";" + (e || "") + '"></span>' : { renderMode: r, content: "{marker" + a + "|}  ", style: { color: n } } : "" }

    function Xo(t, e) { return t += "", "0000".substr(0, e - t.length) + t }

    function Yo(t, e, n) {
        ("week" === t || "month" === t || "quarter" === t || "half-year" === t || "year" === t) && (t = "MM-dd\nyyyy"); var i = Oo(e),
            r = n ? "UTC" : "",
            a = i["get" + r + "FullYear"](),
            o = i["get" + r + "Month"]() + 1,
            s = i["get" + r + "Date"](),
            l = i["get" + r + "Hours"](),
            u = i["get" + r + "Minutes"](),
            h = i["get" + r + "Seconds"](),
            c = i["get" + r + "Milliseconds"](); return t = t.replace("MM", Xo(o, 2)).replace("M", o).replace("yyyy", a).replace("yy", a % 100).replace("dd", Xo(s, 2)).replace("d", s).replace("hh", Xo(l, 2)).replace("h", l).replace("mm", Xo(u, 2)).replace("m", u).replace("ss", Xo(h, 2)).replace("s", h).replace("SSS", Xo(c, 3)) }

    function jo(t) { return t ? t.charAt(0).toUpperCase() + t.substr(1) : t }

    function qo(t) { return Yn(t.text, t.font, t.textAlign, t.textVerticalAlign, t.textPadding, t.textLineHeight, t.rich, t.truncate) }

    function Ko(t, e, n, i, r, a, o, s) { return Yn(t, e, n, i, r, s, a, o) }

    function $o(t, e, n, i, r) { var a = 0,
            o = 0;
        null == i && (i = 1 / 0), null == r && (r = 1 / 0); var s = 0;
        e.eachChild(function(l, u) { var h, c, d = l.position,
                f = l.getBoundingRect(),
                p = e.childAt(u + 1),
                g = p && p.getBoundingRect(); if ("horizontal" === t) { var v = f.width + (g ? -g.x + f.x : 0);
                h = a + v, h > i || l.newline ? (a = 0, h = v, o += s + n, s = f.height) : s = Math.max(s, f.height) } else { var m = f.height + (g ? -g.y + f.y : 0);
                c = o + m, c > r || l.newline ? (a += s + n, o = 0, c = m, s = f.width) : s = Math.max(s, f.width) }
            l.newline || (d[0] = a, d[1] = o, "horizontal" === t ? a = h + n : o = c + n) }) }

    function Qo(t, e, n) { n = jM(n || 0); var i = e.width,
            r = e.height,
            a = So(t.left, i),
            o = So(t.top, r),
            s = So(t.right, i),
            l = So(t.bottom, r),
            u = So(t.width, i),
            h = So(t.height, r),
            c = n[2] + n[0],
            d = n[1] + n[3],
            f = t.aspect; switch (isNaN(u) && (u = i - s - d - a), isNaN(h) && (h = r - l - c - o), null != f && (isNaN(u) && isNaN(h) && (f > i / r ? u = .8 * i : h = .8 * r), isNaN(u) && (u = f * h), isNaN(h) && (h = u / f)), isNaN(a) && (a = i - s - u - d), isNaN(o) && (o = r - l - h - c), t.left || t.right) {
            case "center":
                a = i / 2 - u / 2 - n[3]; break;
            case "right":
                a = i - u - d } switch (t.top || t.bottom) {
            case "middle":
            case "center":
                o = r / 2 - h / 2 - n[0]; break;
            case "bottom":
                o = r - h - c }
        a = a || 0, o = o || 0, isNaN(u) && (u = i - d - a - (s || 0)), isNaN(h) && (h = r - c - o - (l || 0)); var p = new Cn(a + n[3], o + n[0], u, h); return p.margin = n, p }

    function Jo(t, e, n, i, r) { var a = !r || !r.hv || r.hv[0],
            o = !r || !r.hv || r.hv[1],
            l = r && r.boundingMode || "all"; if (a || o) { var u; if ("raw" === l) u = "group" === t.type ? new Cn(0, 0, +e.width || 0, +e.height || 0) : t.getBoundingRect();
            else if (u = t.getBoundingRect(), t.needLocalTransform()) { var h = t.getLocalTransform();
                u = u.clone(), u.applyTransform(h) }
            e = Qo(s({ width: u.width, height: u.height }, e), n, i); var c = t.position,
                d = a ? e.x - u.x : 0,
                f = o ? e.y - u.y : 0;
            t.attr("position", "raw" === l ? [d, f] : [c[0] + d, c[1] + f]) } }

    function ts(t, e, n) {
        function i(n, i) { var o = {},
                l = 0,
                u = {},
                h = 0,
                c = 2; if (eS(n, function(e) { u[e] = t[e] }), eS(n, function(t) { r(e, t) && (o[t] = u[t] = e[t]), a(o, t) && l++, a(u, t) && h++ }), s[i]) return a(e, n[1]) ? u[n[2]] = null : a(e, n[2]) && (u[n[1]] = null), u; if (h !== c && l) { if (l >= c) return o; for (var d = 0; d < n.length; d++) { var f = n[d]; if (!r(o, f) && r(t, f)) { o[f] = t[f]; break } } return o } return u }

        function r(t, e) { return t.hasOwnProperty(e) }

        function a(t, e) { return null != t[e] && "auto" !== t[e] }

        function o(t, e, n) { eS(t, function(t) { e[t] = n[t] }) }!M(n) && (n = {}); var s = n.ignoreSize;!_(s) && (s = [s, s]); var l = i(iS[0], 0),
            u = i(iS[1], 1);
        o(iS[0], t, l), o(iS[1], t, u) }

    function es(t) { return ns({}, t) }

    function ns(t, e) { return e && t && eS(nS, function(n) { e.hasOwnProperty(n) && (t[n] = e[n]) }), t }

    function is(t) { var e = []; return f(sS.getClassesByMainType(t), function(t) { e = e.concat(t.prototype.dependencies || []) }), e = p(e, function(t) { return mr(t).main }), "dataset" !== t && u(e, "dataset") <= 0 && e.unshift("dataset"), e }

    function rs(t, e) { for (var n = t.length, i = 0; n > i; i++)
            if (t[i].length > e) return t[i];
        return t[n - 1] }

    function as(t) { this.fromDataset = t.fromDataset, this.data = t.data || (t.sourceFormat === gS ? {} : []), this.sourceFormat = t.sourceFormat || vS, this.seriesLayoutBy = t.seriesLayoutBy || yS, this.dimensionsDefine = t.dimensionsDefine, this.encodeDefine = t.encodeDefine && N(t.encodeDefine), this.startIndex = t.startIndex || 0, this.dimensionsDetectCount = t.dimensionsDetectCount }

    function os(t) { var e = t.option.source,
            n = vS; if (I(e)) n = mS;
        else if (_(e)) { 0 === e.length && (n = fS); for (var i = 0, r = e.length; r > i; i++) { var a = e[i]; if (null != a) { if (_(a)) { n = fS; break } if (M(a)) { n = pS; break } } } } else if (M(e)) { for (var o in e)
                if (e.hasOwnProperty(o) && d(e[o])) { n = gS; break } } else if (null != e) throw new Error("Invalid data");
        bS(t).sourceFormat = n }

    function ss(t) { return bS(t).source }

    function ls(t) { bS(t).datasetMap = N() }

    function us(t) { var e = t.option,
            n = e.data,
            i = I(n) ? mS : dS,
            r = !1,
            a = e.seriesLayoutBy,
            o = e.sourceHeader,
            s = e.dimensions,
            l = vs(t); if (l) { var u = l.option;
            n = u.source, i = bS(l).sourceFormat, r = !0, a = a || u.seriesLayoutBy, null == o && (o = u.sourceHeader), s = s || u.dimensions } var h = hs(n, i, a, o, s);
        bS(t).source = new as({ data: n, fromDataset: r, seriesLayoutBy: a, sourceFormat: i, dimensionsDefine: h.dimensionsDefine, startIndex: h.startIndex, dimensionsDetectCount: h.dimensionsDetectCount, encodeDefine: e.encode }) }

    function hs(t, e, n, i, r) { if (!t) return { dimensionsDefine: cs(r) }; var a, o; if (e === fS) "auto" === i || null == i ? ds(function(t) { null != t && "-" !== t && (w(t) ? null == o && (o = 1) : o = 0) }, n, t, 10) : o = i ? 1 : 0, r || 1 !== o || (r = [], ds(function(t, e) { r[e] = null != t ? t : "" }, n, t)), a = r ? r.length : n === xS ? t.length : t[0] ? t[0].length : null;
        else if (e === pS) r || (r = fs(t));
        else if (e === gS) r || (r = [], f(t, function(t, e) { r.push(e) }));
        else if (e === dS) { var s = ir(t[0]);
            a = _(s) && s.length || 1 } return { startIndex: o, dimensionsDefine: cs(r), dimensionsDetectCount: a } }

    function cs(t) { if (t) { var e = N(); return p(t, function(t) { if (t = o({}, M(t) ? t : { name: t }), null == t.name) return t;
                t.name += "", null == t.displayName && (t.displayName = t.name); var n = e.get(t.name); return n ? t.name += "-" + n.count++ : e.set(t.name, { count: 1 }), t }) } }

    function ds(t, e, n, i) { if (null == i && (i = 1 / 0), e === xS)
            for (var r = 0; r < n.length && i > r; r++) t(n[r] ? n[r][0] : null, r);
        else
            for (var a = n[0] || [], r = 0; r < a.length && i > r; r++) t(a[r], r) }

    function fs(t) { for (var e, n = 0; n < t.length && !(e = t[n++]);); if (e) { var i = []; return f(e, function(t, e) { i.push(e) }), i } }

    function ps(t, e, n) {
        function i(t, e, n) { for (var i = 0; n > i; i++) t.push(e + i) }

        function r(t) { var e = t.dimsDef; return e ? e.length : 1 } var a = {},
            o = vs(e); if (!o || !t) return a; var s, l, u = [],
            h = [],
            c = e.ecModel,
            d = bS(c).datasetMap,
            p = o.uid + "_" + n.seriesLayoutBy;
        t = t.slice(), f(t, function(e, n) {!M(e) && (t[n] = { name: e }), "ordinal" === e.type && null == s && (s = n, l = r(t[n])), a[e.name] = [] }); var g = d.get(p) || d.set(p, { categoryWayDim: l, valueWayDim: 0 }); return f(t, function(t, e) { var n = t.name,
                o = r(t); if (null == s) { var l = g.valueWayDim;
                i(a[n], l, o), i(h, l, o), g.valueWayDim += o } else if (s === e) i(a[n], 0, o), i(u, 0, o);
            else { var l = g.categoryWayDim;
                i(a[n], l, o), i(h, l, o), g.categoryWayDim += o } }), u.length && (a.itemName = u), h.length && (a.seriesName = h), a }

    function gs(t, e, n) { var i = {},
            r = vs(t); if (!r) return i; var a, o = e.sourceFormat,
            s = e.dimensionsDefine;
        (o === pS || o === gS) && f(s, function(t, e) { "name" === (M(t) ? t.name : t) && (a = e) }); var l = function() {
            function t(t) { return null != t.v && null != t.n } for (var i = {}, r = {}, l = [], u = 0, h = Math.min(5, n); h > u; u++) { var c = ys(e.data, o, e.seriesLayoutBy, s, e.startIndex, u);
                l.push(c); var d = c === _S.Not; if (d && null == i.v && u !== a && (i.v = u), (null == i.n || i.n === i.v || !d && l[i.n] === _S.Not) && (i.n = u), t(i) && l[i.n] !== _S.Not) return i;
                d || (c === _S.Might && null == r.v && u !== a && (r.v = u), (null == r.n || r.n === r.v) && (r.n = u)) } return t(i) ? i : t(r) ? r : null }(); if (l) { i.value = l.v; var u = null != a ? a : l.n;
            i.itemName = [u], i.seriesName = [u] } return i }

    function vs(t) { var e = t.option,
            n = e.data; return n ? void 0 : t.ecModel.getComponent("dataset", e.datasetIndex || 0) }

    function ms(t, e) { return ys(t.data, t.sourceFormat, t.seriesLayoutBy, t.dimensionsDefine, t.startIndex, e) }

    function ys(t, e, n, i, r, a) {
        function o(t) { var e = w(t); return null != t && isFinite(t) && "" !== t ? e ? _S.Might : _S.Not : e && "-" !== t ? _S.Must : void 0 } var s, l = 5; if (I(t)) return _S.Not; var u, h; if (i) { var c = i[a];
            M(c) ? (u = c.name, h = c.type) : w(c) && (u = c) } if (null != h) return "ordinal" === h ? _S.Must : _S.Not; if (e === fS)
            if (n === xS) { for (var d = t[a], f = 0; f < (d || []).length && l > f; f++)
                    if (null != (s = o(d[r + f]))) return s } else
                for (var f = 0; f < t.length && l > f; f++) { var p = t[r + f]; if (p && null != (s = o(p[a]))) return s } else if (e === pS) { if (!u) return _S.Not; for (var f = 0; f < t.length && l > f; f++) { var g = t[f]; if (g && null != (s = o(g[u]))) return s } } else if (e === gS) { if (!u) return _S.Not; var d = t[u]; if (!d || I(d)) return _S.Not; for (var f = 0; f < d.length && l > f; f++)
                if (null != (s = o(d[f]))) return s } else if (e === dS)
            for (var f = 0; f < t.length && l > f; f++) { var g = t[f],
                    v = ir(g); if (!_(v)) return _S.Not; if (null != (s = o(v[a]))) return s }
        return _S.Not }

    function xs(t, e) { if (e) { var n = e.seiresIndex,
                i = e.seriesId,
                r = e.seriesName; return null != n && t.componentIndex !== n || null != i && t.id !== i || null != r && t.name !== r } }

    function _s(t, e) { var n = t.color && !t.colorLayer;
        f(e, function(e, a) { "colorLayer" === a && n || sS.hasClass(a) || ("object" == typeof e ? t[a] = t[a] ? r(t[a], e, !1) : i(e) : null == t[a] && (t[a] = e)) }) }

    function bs(t) { t = t, this.option = {}, this.option[wS] = 1, this._componentsMap = N({ series: [] }), this._seriesIndices, this._seriesIndicesMap, _s(t, this._theme.option), r(t, uS, !1), this.mergeOption(t) }

    function ws(t, e) { _(e) || (e = e ? [e] : []); var n = {}; return f(e, function(e) { n[e] = (t.get(e) || []).slice() }), n }

    function Ms(t, e, n) { var i = e.type ? e.type : n ? n.subType : sS.determineSubType(t, e); return i }

    function Ss(t, e) { t._seriesIndicesMap = N(t._seriesIndices = p(e, function(t) { return t.componentIndex }) || []) }

    function Is(t, e) { return e.hasOwnProperty("subType") ? v(t, function(t) { return t.subType === e.subType }) : t }

    function Ts(t) { f(SS, function(e) { this[e] = y(t[e], t) }, this) }

    function Cs() { this._coordinateSystems = [] }

    function As(t) { this._api = t, this._timelineOptions = [], this._mediaList = [], this._mediaDefault, this._currentMediaIndices = [], this._optionBackup, this._newBaseOption }

    function Ds(t, e, n) { var i, r, a = [],
            o = [],
            s = t.timeline; if (t.baseOption && (r = t.baseOption), (s || t.options) && (r = r || {}, a = (t.options || []).slice()), t.media) { r = r || {}; var l = t.media;
            TS(l, function(t) { t && t.option && (t.query ? o.push(t) : i || (i = t)) }) } return r || (r = t), r.timeline || (r.timeline = s), TS([r].concat(a).concat(p(o, function(t) { return t.option })), function(t) { TS(e, function(e) { e(t, n) }) }), { baseOption: r, timelineOptions: a, mediaDefault: i, mediaList: o } }

    function ks(t, e, n) { var i = { width: e, height: n, aspectratio: e / n },
            r = !0; return f(t, function(t, e) { var n = e.match(kS); if (n && n[1] && n[2]) { var a = n[1],
                    o = n[2].toLowerCase();
                Ps(i[o], t, a) || (r = !1) } }), r }

    function Ps(t, e, n) { return "min" === n ? t >= e : "max" === n ? e >= t : t === e }

    function Ls(t, e) { return t.join(",") === e.join(",") }

    function Os(t, e) { e = e || {}, TS(e, function(e, n) { if (null != e) { var i = t[n]; if (sS.hasClass(n)) { e = er(e), i = er(i); var r = ar(i, e);
                    t[n] = AS(r, function(t) { return t.option && t.exist ? DS(t.exist, t.option, !0) : t.exist || t.option }) } else t[n] = DS(i, e, !0) } }) }

    function zs(t) { var e = t && t.itemStyle; if (e)
            for (var n = 0, i = OS.length; i > n; n++) { var a = OS[n],
                    o = e.normal,
                    s = e.emphasis;
                o && o[a] && (t[a] = t[a] || {}, t[a].normal ? r(t[a].normal, o[a]) : t[a].normal = o[a], o[a] = null), s && s[a] && (t[a] = t[a] || {}, t[a].emphasis ? r(t[a].emphasis, s[a]) : t[a].emphasis = s[a], s[a] = null) } }

    function Es(t, e, n) { if (t && t[e] && (t[e].normal || t[e].emphasis)) { var i = t[e].normal,
                r = t[e].emphasis;
            i && (n ? (t[e].normal = t[e].emphasis = null, s(t[e], i)) : t[e] = i), r && (t.emphasis = t.emphasis || {}, t.emphasis[e] = r) } }

    function Rs(t) { Es(t, "itemStyle"), Es(t, "lineStyle"), Es(t, "areaStyle"), Es(t, "label"), Es(t, "labelLine"), Es(t, "upperLabel"), Es(t, "edgeLabel") }

    function Bs(t, e) { var n = LS(t) && t[e],
            i = LS(n) && n.textStyle; if (i)
            for (var r = 0, a = Hb.length; a > r; r++) { var e = Hb[r];
                i.hasOwnProperty(e) && (n[e] = i[e]) } }

    function Ns(t) { t && (Rs(t), Bs(t, "label"), t.emphasis && Bs(t.emphasis, "label")) }

    function Vs(t) { if (LS(t)) { zs(t), Rs(t), Bs(t, "label"), Bs(t, "upperLabel"), Bs(t, "edgeLabel"), t.emphasis && (Bs(t.emphasis, "label"), Bs(t.emphasis, "upperLabel"), Bs(t.emphasis, "edgeLabel")); var e = t.markPoint;
            e && (zs(e), Ns(e)); var n = t.markLine;
            n && (zs(n), Ns(n)); var i = t.markArea;
            i && Ns(i); var r = t.data; if ("graph" === t.type) { r = r || t.nodes; var a = t.links || t.edges; if (a && !I(a))
                    for (var o = 0; o < a.length; o++) Ns(a[o]);
                f(t.categories, function(t) { Rs(t) }) } if (r && !I(r))
                for (var o = 0; o < r.length; o++) Ns(r[o]); var e = t.markPoint; if (e && e.data)
                for (var s = e.data, o = 0; o < s.length; o++) Ns(s[o]); var n = t.markLine; if (n && n.data)
                for (var l = n.data, o = 0; o < l.length; o++) _(l[o]) ? (Ns(l[o][0]), Ns(l[o][1])) : Ns(l[o]); "gauge" === t.type ? (Bs(t, "axisLabel"), Bs(t, "title"), Bs(t, "detail")) : "treemap" === t.type ? (Es(t.breadcrumb, "itemStyle"), f(t.levels, function(t) { Rs(t) })) : "tree" === t.type && Rs(t.leaves) } }

    function Fs(t) { return _(t) ? t : t ? [t] : [] }

    function Hs(t) { return (_(t) ? t[0] : t) || {} }

    function Gs(t, e) { e = e.split(","); for (var n = t, i = 0; i < e.length && (n = n && n[e[i]], null != n); i++); return n }

    function Ws(t, e, n, i) { e = e.split(","); for (var r, a = t, o = 0; o < e.length - 1; o++) r = e[o], null == a[r] && (a[r] = {}), a = a[r];
        (i || null == a[e[o]]) && (a[e[o]] = n) }

    function Zs(t) { f(ES, function(e) { e[0] in t && !(e[1] in t) && (t[e[1]] = t[e[0]]) }) }

    function Us(t) { f(t, function(e, n) { var i = [],
                r = [0 / 0, 0 / 0],
                a = [e.stackResultDimension, e.stackedOverDimension],
                o = e.data,
                s = e.isStackedByIndex,
                l = o.map(a, function(a, l, u) { var h = o.get(e.stackedDimension, u); if (isNaN(h)) return r; var c, d;
                    s ? d = o.getRawIndex(u) : c = o.get(e.stackedByDimension, u); for (var f = 0 / 0, p = n - 1; p >= 0; p--) { var g = t[p]; if (s || (d = g.data.rawIndexOf(g.stackedByDimension, c)), d >= 0) { var v = g.data.getByRawIndex(g.stackResultDimension, d); if (h >= 0 && v > 0 || 0 >= h && 0 > v) { h += v, f = v; break } } } return i[0] = h, i[1] = f, i });
            o.hostModel.setData(l), e.data = l }) }

    function Xs(t, e) { as.isInstance(t) || (t = as.seriesDataToSource(t)), this._source = t; var n = this._data = t.data,
            i = t.sourceFormat;
        i === mS && (this._offset = 0, this._dimSize = e, this._data = n); var r = FS[i === fS ? i + "_" + t.seriesLayoutBy : i];
        o(this, r) }

    function Ys() { return this._data.length }

    function js(t) { return this._data[t] }

    function qs(t) { for (var e = 0; e < t.length; e++) this._data.push(t[e]) }

    function Ks(t, e, n) { return null != n ? t[n] : t }

    function $s(t, e, n, i) { return Qs(t[i], this._dimensionInfos[e]) }

    function Qs(t, e) { var n = e && e.type; if ("ordinal" === n) { var i = e && e.ordinalMeta; return i ? i.parseAndCollect(t) : t } return "time" === n && "number" != typeof t && null != t && "-" !== t && (t = +Oo(t)), null == t || "" === t ? 0 / 0 : +t }

    function Js(t, e, n) { if (t) { var i = t.getRawDataItem(e); if (null != i) { var r, a, o = t.getProvider().getSource().sourceFormat,
                    s = t.getDimensionInfo(n); return s && (r = s.name, a = s.index), HS[o](i, e, a, r) } } }

    function tl(t, e, n) { if (t) { var i = t.getProvider().getSource().sourceFormat; if (i === dS || i === pS) { var r = t.getRawDataItem(e); return i !== dS || M(r) || (r = null), r ? r[n] : void 0 } } }

    function el(t) { return new nl(t) }

    function nl(t) { t = t || {}, this._reset = t.reset, this._plan = t.plan, this._count = t.count, this._onDirty = t.onDirty, this._dirty = !0, this.context }

    function il(t, e, n, i, r, a) { XS.reset(n, i, r, a), t._callingProgress = e, t._callingProgress({ start: n, end: i, count: i - n, next: XS.next }, t.context) }

    function rl(t, e) { t._dueIndex = t._outputDueEnd = t._dueEnd = 0, t._settedOutputEnd = null; var n, i;!e && t._reset && (n = t._reset(t.context), n && n.progress && (i = n.forceFirstProgress, n = n.progress), _(n) && !n.length && (n = null)), t._progress = n, t._modBy = t._modDataCount = null; var r = t._downstream; return r && r.dirty(), i }

    function al(t) { var e = t.name;
        sr(t) || (t.name = ol(t) || e) }

    function ol(t) { var e = t.getRawData(),
            n = e.mapDimension("seriesName", !0),
            i = []; return f(n, function(t) { var n = e.getDimensionInfo(t);
            n.displayName && i.push(n.displayName) }), i.join(" ") }

    function sl(t) { return t.model.getRawData().count() }

    function ll(t) { var e = t.model; return e.setData(e.getRawData().cloneShallow()), ul }

    function ul(t, e) { t.end > e.outputData.count() && e.model.getRawData().cloneShallow(e.outputData) }

    function hl(t, e) { f(t.CHANGABLE_METHODS, function(n) { t.wrapMethod(n, x(cl, e)) }) }

    function cl(t) { var e = dl(t);
        e && e.setOutputEnd(this.count()) }

    function dl(t) { var e = (t.ecModel || {}).scheduler,
            n = e && e.getPipeline(t.uid); if (n) { var i = n.currentTask; if (i) { var r = i.agentStubMap;
                r && (i = r.get(t.uid)) } return i } }

    function fl() { this.group = new N_, this.uid = xo("viewChart"), this.renderTask = el({ plan: vl, reset: ml }), this.renderTask.context = { view: this } }

    function pl(t, e, n) { if (t && (t.trigger(e, n), t.isGroup && !Ga(t)))
            for (var i = 0, r = t.childCount(); r > i; i++) pl(t.childAt(i), e, n) }

    function gl(t, e, n) { var i = hr(t, e),
            r = e && null != e.highlightKey ? Wa(e.highlightKey) : null;
        null != i ? f(er(i), function(e) { pl(t.getItemGraphicEl(e), n, r) }) : t.eachItemGraphicEl(function(t) { pl(t, n, r) }) }

    function vl(t) { return JS(t.model) }

    function ml(t) { var e = t.model,
            n = t.ecModel,
            i = t.api,
            r = t.payload,
            a = e.pipelineContext.progressiveRender,
            o = t.view,
            s = r && QS(r).updateMethod,
            l = a ? "incrementalPrepareRender" : s && o[s] ? s : "render"; return "render" !== l && o[l](e, n, i, r), eI[l] }

    function yl(t, e, n) {
        function i() { h = (new Date).getTime(), c = null, t.apply(o, s || []) } var r, a, o, s, l, u = 0,
            h = 0,
            c = null;
        e = e || 0; var d = function() { r = (new Date).getTime(), o = this, s = arguments; var t = l || e,
                d = l || n;
            l = null, a = r - (d ? u : h) - t, clearTimeout(c), d ? c = setTimeout(i, t) : a >= 0 ? i() : c = setTimeout(i, -a), u = r }; return d.clear = function() { c && (clearTimeout(c), c = null) }, d.debounceNextCall = function(t) { l = t }, d }

    function xl(t, e, n, i) { var r = t[e]; if (r) { var a = r[nI] || r,
                o = r[rI],
                s = r[iI]; if (s !== n || o !== i) { if (null == n || !i) return t[e] = a;
                r = t[e] = yl(a, n, "debounce" === i), r[nI] = a, r[rI] = i, r[iI] = n } return r } }

    function _l(t, e) { var n = t[e];
        n && n[nI] && (t[e] = n[nI]) }

    function bl(t, e, n, i) { this.ecInstance = t, this.api = e, this.unfinished; var n = this._dataProcessorHandlers = n.slice(),
            i = this._visualHandlers = i.slice();
        this._allHandlers = n.concat(i), this._stageTaskMap = N() }

    function wl(t, e, n, i, r) {
        function a(t, e) { return t.setDirty && (!t.dirtyMap || t.dirtyMap.get(e.__pipeline.id)) }
        r = r || {}; var o;
        f(e, function(e) { if (!r.visualType || r.visualType === e.visualType) { var s = t._stageTaskMap.get(e.uid),
                    l = s.seriesTaskMap,
                    u = s.overallTask; if (u) { var h, c = u.agentStubMap;
                    c.each(function(t) { a(r, t) && (t.dirty(), h = !0) }), h && u.dirty(), cI(u, i); var d = t.getPerformArgs(u, r.block);
                    c.each(function(t) { t.perform(d) }), o |= u.perform(d) } else l && l.each(function(s) { a(r, s) && s.dirty(); var l = t.getPerformArgs(s, r.block);
                    l.skip = !e.performRawSeries && n.isSeriesFiltered(s.context.model), cI(s, i), o |= s.perform(l) }) } }), t.unfinished |= o }

    function Ml(t, e, n, i, r) {
        function a(n) { var a = n.uid,
                s = o.get(a) || o.set(a, el({ plan: Dl, reset: kl, count: Ll }));
            s.context = { model: n, ecModel: i, api: r, useClearVisual: e.isVisual && !e.isLayout, plan: e.plan, reset: e.reset, scheduler: t }, Ol(t, n, s) } var o = n.seriesTaskMap || (n.seriesTaskMap = N()),
            s = e.seriesType,
            l = e.getTargetSeries;
        e.createOnAllSeries ? i.eachRawSeries(a) : s ? i.eachRawSeriesByType(s, a) : l && l(i, r).each(a); var u = t._pipelineMap;
        o.each(function(t, e) { u.get(e) || (t.dispose(), o.removeKey(e)) }) }

    function Sl(t, e, n, i, r) {
        function a(e) { var n = e.uid,
                i = s.get(n);
            i || (i = s.set(n, el({ reset: Tl, onDirty: Al })), o.dirty()), i.context = { model: e, overallProgress: h, modifyOutputEnd: c }, i.agent = o, i.__block = h, Ol(t, e, i) } var o = n.overallTask = n.overallTask || el({ reset: Il });
        o.context = { ecModel: i, api: r, overallReset: e.overallReset, scheduler: t }; var s = o.agentStubMap = o.agentStubMap || N(),
            l = e.seriesType,
            u = e.getTargetSeries,
            h = !0,
            c = e.modifyOutputEnd;
        l ? i.eachRawSeriesByType(l, a) : u ? u(i, r).each(a) : (h = !1, f(i.getSeries(), a)); var d = t._pipelineMap;
        s.each(function(t, e) { d.get(e) || (t.dispose(), o.dirty(), s.removeKey(e)) }) }

    function Il(t) { t.overallReset(t.ecModel, t.api, t.payload) }

    function Tl(t) { return t.overallProgress && Cl }

    function Cl() { this.agent.dirty(), this.getDownstream().dirty() }

    function Al() { this.agent && this.agent.dirty() }

    function Dl(t) { return t.plan && t.plan(t.model, t.ecModel, t.api, t.payload) }

    function kl(t) { t.useClearVisual && t.data.clearAllVisual(); var e = t.resetDefines = er(t.reset(t.model, t.ecModel, t.api, t.payload)); return e.length > 1 ? p(e, function(t, e) { return Pl(e) }) : dI }

    function Pl(t) { return function(e, n) { var i = n.data,
                r = n.resetDefines[t]; if (r && r.dataEach)
                for (var a = e.start; a < e.end; a++) r.dataEach(i, a);
            else r && r.progress && r.progress(e, i) } }

    function Ll(t) { return t.data.count() }

    function Ol(t, e, n) { var i = e.uid,
            r = t._pipelineMap.get(i);!r.head && (r.head = n), r.tail && r.tail.pipe(n), r.tail = n, n.__idxInPipeline = r.count++, n.__pipeline = r }

    function zl(t) { fI = null; try { t(pI, gI) } catch (e) {} return fI }

    function El(t, e) { for (var n in e.prototype) t[n] = F }

    function Rl(t) { if (w(t)) { var e = new DOMParser;
            t = e.parseFromString(t, "text/xml") } for (9 === t.nodeType && (t = t.firstChild);
            "svg" !== t.nodeName.toLowerCase() || 1 !== t.nodeType;) t = t.nextSibling; return t }

    function Bl() { this._defs = {}, this._root = null, this._isDefine = !1, this._isText = !1 }

    function Nl(t, e) { for (var n = t.firstChild; n;) { if (1 === n.nodeType) { var i = n.getAttribute("offset");
                i = i.indexOf("%") > 0 ? parseInt(i, 10) / 100 : i ? parseFloat(i) : 0; var r = n.getAttribute("stop-color") || "#000000";
                e.addColorStop(i, r) }
            n = n.nextSibling } }

    function Vl(t, e) { t && t.__inheritedStyle && (e.__inheritedStyle || (e.__inheritedStyle = {}), s(e.__inheritedStyle, t.__inheritedStyle)) }

    function Fl(t) { for (var e = z(t).split(MI), n = [], i = 0; i < e.length; i += 2) { var r = parseFloat(e[i]),
                a = parseFloat(e[i + 1]);
            n.push([r, a]) } return n }

    function Hl(t, e, n, i) { var r = e.__inheritedStyle || {},
            a = "text" === e.type; if (1 === t.nodeType && (Wl(t, e), o(r, Zl(t)), !i))
            for (var s in TI)
                if (TI.hasOwnProperty(s)) { var l = t.getAttribute(s);
                    null != l && (r[TI[s]] = l) }
        var u = a ? "textFill" : "fill",
            h = a ? "textStroke" : "stroke";
        e.style = e.style || new Y_; var c = e.style;
        null != r.fill && c.set(u, Gl(r.fill, n)), null != r.stroke && c.set(h, Gl(r.stroke, n)), f(["lineWidth", "opacity", "fillOpacity", "strokeOpacity", "miterLimit", "fontSize"], function(t) { var e = "lineWidth" === t && a ? "textStrokeWidth" : t;
            null != r[t] && c.set(e, parseFloat(r[t])) }), r.textBaseline && "auto" !== r.textBaseline || (r.textBaseline = "alphabetic"), "alphabetic" === r.textBaseline && (r.textBaseline = "bottom"), "start" === r.textAlign && (r.textAlign = "left"), "end" === r.textAlign && (r.textAlign = "right"), f(["lineDashOffset", "lineCap", "lineJoin", "fontWeight", "fontFamily", "fontStyle", "textAlign", "textBaseline"], function(t) { null != r[t] && c.set(t, r[t]) }), r.lineDash && (e.style.lineDash = z(r.lineDash).split(MI)), c[h] && "none" !== c[h] && (e[h] = !0), e.__inheritedStyle = r }

    function Gl(t, e) { var n = e && t && t.match(CI); if (n) { var i = z(n[1]),
                r = e[i]; return r } return t }

    function Wl(t, e) { var n = t.getAttribute("transform"); if (n) { n = n.replace(/,/g, " "); var i = null,
                r = [];
            n.replace(AI, function(t, e, n) { r.push(e, n) }); for (var a = r.length - 1; a > 0; a -= 2) { var o = r[a],
                    s = r[a - 1]; switch (i = i || Oe(), s) {
                    case "translate":
                        o = z(o).split(MI), Be(i, i, [parseFloat(o[0]), parseFloat(o[1] || 0)]); break;
                    case "scale":
                        o = z(o).split(MI), Ve(i, i, [parseFloat(o[0]), parseFloat(o[1] || o[0])]); break;
                    case "rotate":
                        o = z(o).split(MI), Ne(i, i, parseFloat(o[0])); break;
                    case "skew":
                        o = z(o).split(MI), console.warn("Skew transform is not supported yet"); break;
                    case "matrix":
                        var o = z(o).split(MI);
                        i[0] = parseFloat(o[0]), i[1] = parseFloat(o[1]), i[2] = parseFloat(o[2]), i[3] = parseFloat(o[3]), i[4] = parseFloat(o[4]), i[5] = parseFloat(o[5]) } }
            e.setLocalTransform(i) } }

    function Zl(t) { var e = t.getAttribute("style"),
            n = {}; if (!e) return n; var i = {};
        DI.lastIndex = 0; for (var r; null != (r = DI.exec(e));) i[r[1]] = r[2]; for (var a in TI) TI.hasOwnProperty(a) && null != i[a] && (n[TI[a]] = i[a]); return n }

    function Ul(t, e, n) { var i = e / t.width,
            r = n / t.height,
            a = Math.min(i, r),
            o = [a, a],
            s = [-(t.x + t.width / 2) * a + e / 2, -(t.y + t.height / 2) * a + n / 2]; return { scale: o, position: s } }

    function Xl(t, e) { return function(n, i, r) {
            (e || !this._disposed) && (n = n && n.toLowerCase(), Xx.prototype[t].call(this, n, i, r)) } }

    function Yl() { Xx.call(this) }

    function jl(t, e, n) {
        function r(t, e) { return t.__prio - e.__prio }
        n = n || {}, "string" == typeof e && (e = cT[e]), this.id, this.group, this._dom = t; var a = "canvas",
            o = this._zr = Ki(t, { renderer: n.renderer || a, devicePixelRatio: n.devicePixelRatio, width: n.width, height: n.height });
        this._throttledZrFlush = yl(y(o.flush, o), 17); var e = i(e);
        e && BS(e, !0), this._theme = e, this._chartsViews = [], this._chartsMap = {}, this._componentsViews = [], this._componentsMap = {}, this._coordSysMgr = new Cs; var s = this._api = du(this);
        En(hT, r), En(sT, r), this._scheduler = new bl(this, s, sT, hT), Xx.call(this, this._ecEventProcessor = new fu), this._messageCenter = new Yl, this._initEvents(), this.resize = y(this.resize, this), this._pendingActions = [], o.animation.on("frame", this._onframe, this), nu(o, this), E(this) }

    function ql(t, e, n) { if (!this._disposed) { var i, r = this._model,
                a = this._coordSysMgr.getCoordinateSystems();
            e = dr(r, e); for (var o = 0; o < a.length; o++) { var s = a[o]; if (s[t] && null != (i = s[t](r, e, n))) return i } } }

    function Kl(t) { var e = t._model,
            n = t._scheduler;
        n.restorePipelines(e), n.prepareStageTasks(), iu(t, "component", e, n), iu(t, "chart", e, n), n.plan() }

    function $l(t, e, n, i, r) {
        function a(i) { i && i.__alive && i[e] && i[e](i.__model, o, t._api, n) } var o = t._model; if (!i) return void zI(t._componentsViews.concat(t._chartsViews), a); var s = {};
        s[i + "Id"] = n[i + "Id"], s[i + "Index"] = n[i + "Index"], s[i + "Name"] = n[i + "Name"]; var l = { mainType: i, query: s };
        r && (l.subType = r); var u = n.excludeSeriesId;
        null != u && (u = N(er(u))), o && o.eachComponent(l, function(e) { u && null != u.get(e.id) || a(t["series" === i ? "_chartsMap" : "_componentsMap"][e.__viewId]) }, t) }

    function Ql(t, e) { var n = t._chartsMap,
            i = t._scheduler;
        e.eachSeries(function(t) { i.updateStreamModes(t, n[t.__viewId]) }) }

    function Jl(t, e) { var n = t.type,
            i = t.escapeConnect,
            r = aT[n],
            a = r.actionInfo,
            l = (a.update || "update").split(":"),
            u = l.pop();
        l = null != l[0] && BI(l[0]), this[JI] = !0; var h = [t],
            c = !1;
        t.batch && (c = !0, h = p(t.batch, function(e) { return e = s(o({}, e), t), e.batch = null, e })); var d, f = [],
            g = "highlight" === n || "downplay" === n;
        zI(h, function(t) { d = r.action(t, this._model, this._api), d = d || o({}, t), d.type = a.event || d.type, f.push(d), g ? $l(this, u, t, "series") : l && $l(this, u, t, l.main, l.sub) }, this), "none" === u || g || l || (this[tT] ? (Kl(this), iT.update.call(this, t), this[tT] = !1) : iT[u].call(this, t)), d = c ? { type: a.event || n, escapeConnect: i, batch: f } : f[0], this[JI] = !1, !e && this._messageCenter.trigger(d.type, d) }

    function tu(t) { for (var e = this._pendingActions; e.length;) { var n = e.shift();
            Jl.call(this, n, t) } }

    function eu(t) {!t && this.trigger("updated") }

    function nu(t, e) { t.on("rendered", function() { e.trigger("rendered"), !t.animation.isFinished() || e[tT] || e._scheduler.unfinished || e._pendingActions.length || e.trigger("finished") }) }

    function iu(t, e, n, i) {
        function r(t) { var e = "_ec_" + t.id + "_" + t.type,
                r = s[e]; if (!r) { var h = BI(t.type),
                    c = a ? qS.getClass(h.main, h.sub) : fl.getClass(h.sub);
                r = new c, r.init(n, u), s[e] = r, o.push(r), l.add(r.group) }
            t.__viewId = r.__id = e, r.__alive = !0, r.__model = t, r.group.__ecComponentInfo = { mainType: t.mainType, index: t.componentIndex }, !a && i.prepareView(r, t, n, u) } for (var a = "component" === e, o = a ? t._componentsViews : t._chartsViews, s = a ? t._componentsMap : t._chartsMap, l = t._zr, u = t._api, h = 0; h < o.length; h++) o[h].__alive = !1;
        a ? n.eachComponent(function(t, e) { "series" !== t && r(e) }) : n.eachSeries(r); for (var h = 0; h < o.length;) { var c = o[h];
            c.__alive ? h++ : (!a && c.renderTask.dispose(), l.remove(c.group), c.dispose(n, u), o.splice(h, 1), delete s[c.__id], c.__id = c.group.__ecComponentInfo = null) } }

    function ru(t) { t.clearColorPalette(), t.eachSeries(function(t) { t.clearColorPalette() }) }

    function au(t, e, n, i) { ou(t, e, n, i), zI(t._chartsViews, function(t) { t.__alive = !1 }), su(t, e, n, i), zI(t._chartsViews, function(t) { t.__alive || t.remove(e, n) }) }

    function ou(t, e, n, i, r) { zI(r || t._componentsViews, function(t) { var r = t.__model;
            t.render(r, e, n, i), cu(r, t) }) }

    function su(t, e, n, i, r) { var a, o = t._scheduler;
        e.eachSeries(function(e) { var n = t._chartsMap[e.__viewId];
            n.__alive = !0; var s = n.renderTask;
            o.updatePayload(s, i), r && r.get(e.uid) && s.dirty(), a |= s.perform(o.getPerformArgs(s)), n.group.silent = !!e.get("silent"), cu(e, n), hu(e, n) }), o.unfinished |= a, uu(t, e), sI(t._zr.dom, e) }

    function lu(t, e) { zI(uT, function(n) { n(t, e) }) }

    function uu(t, e) {
        var n = t._zr,
            i = n.storage,
            r = 0;
        i.traverse(function() { r++ }), r > e.get("hoverLayerThreshold") && !Sx.node && e.eachSeries(function(e) {
            if (!e.preventUsingHoverLayer) {
                var n = t._chartsMap[e.__viewId];
                n.__alive && n.group.traverse(function(t) {
                    t.useHoverLayer = !0
                })
            }
        })
    }

    function hu(t, e) { var n = t.get("blendMode") || null;
        e.group.traverse(function(t) { t.isGroup || t.style.blend !== n && t.setStyle("blend", n), t.eachPendingDisplayable && t.eachPendingDisplayable(function(t) { t.setStyle("blend", n) }) }) }

    function cu(t, e) { var n = t.get("z"),
            i = t.get("zlevel");
        e.group.traverse(function(t) { "group" !== t.type && (null != n && (t.z = n), null != i && (t.zlevel = i)) }) }

    function du(t) { var e = t._coordSysMgr; return o(new Ts(t), { getCoordinateSystems: y(e.getCoordinateSystems, e), getComponentByElement: function(e) { for (; e;) { var n = e.__ecComponentInfo; if (null != n) return t._model.getComponent(n.mainType, n.index);
                    e = e.parent } } }) }

    function fu() { this.eventInfo }

    function pu(t) {
        function e(t, e) { for (var n = 0; n < t.length; n++) { var i = t[n];
                i[a] = e } } var n = 0,
            i = 1,
            r = 2,
            a = "__connectUpdateStatus";
        zI(oT, function(o, s) { t._messageCenter.on(s, function(o) { if (pT[t.group] && t[a] !== n) { if (o && o.escapeConnect) return; var s = t.makeActionFromEvent(o),
                        l = [];
                    zI(fT, function(e) { e !== t && e.group === t.group && l.push(e) }), e(l, n), zI(l, function(t) { t[a] !== i && t.dispatchAction(s) }), e(l, r) } }) }) }

    function gu(t, e, n) { var i = xu(t); if (i) return i; var r = new jl(t, e, n); return r.id = "ec_" + gT++, fT[r.id] = r, pr(t, mT, r.id), pu(r), r }

    function vu(t) { if (_(t)) { var e = t;
            t = null, zI(e, function(e) { null != e.group && (t = e.group) }), t = t || "g_" + vT++, zI(e, function(e) { e.group = t }) } return pT[t] = !0, t }

    function mu(t) { pT[t] = !1 }

    function yu(t) { "string" == typeof t ? t = fT[t] : t instanceof jl || (t = xu(t)), t instanceof jl && !t.isDisposed() && t.dispose() }

    function xu(t) { return fT[gr(t, mT)] }

    function _u(t) { return fT[t] }

    function bu(t, e) { cT[t] = e }

    function wu(t) { lT.push(t) }

    function Mu(t, e) { ku(sT, t, e, HI) }

    function Su(t) { uT.push(t) }

    function Iu(t, e, n) { "function" == typeof e && (n = e, e = ""); var i = RI(t) ? t.type : [t, t = { event: e }][0];
        t.event = (t.event || i).toLowerCase(), e = t.event, OI(eT.test(i) && eT.test(e)), aT[i] || (aT[i] = { action: n, actionInfo: t }), oT[e] = i }

    function Tu(t, e) { Cs.register(t, e) }

    function Cu(t) { var e = Cs.get(t); return e ? e.getDimensionsInfo ? e.getDimensionsInfo() : e.dimensions.slice() : void 0 }

    function Au(t, e) { ku(hT, t, e, UI, "layout") }

    function Du(t, e) { ku(hT, t, e, jI, "visual") }

    function ku(t, e, n, i, r) {
        (EI(e) || RI(e)) && (n = e, e = i); var a = bl.wrapStageHandler(n, r); return a.__prio = e, a.__raw = n, t.push(a), a }

    function Pu(t, e) { dT[t] = e }

    function Lu(t) { return sS.extend(t) }

    function Ou(t) { return qS.extend(t) }

    function zu(t) { return jS.extend(t) }

    function Eu(t) { return fl.extend(t) }

    function Ru(t) { n("createCanvas", t) }

    function Bu(t, e, n) { PI.registerMap(t, e, n) }

    function Nu(t) { var e = PI.retrieveMap(t); return e && e[0] && { geoJson: e[0].geoJSON, specialAreas: e[0].specialAreas } }

    function Vu(t) { return t }

    function Fu(t, e, n, i, r) { this._old = t, this._new = e, this._oldKeyGetter = n || Vu, this._newKeyGetter = i || Vu, this.context = r }

    function Hu(t, e, n, i, r) { for (var a = 0; a < t.length; a++) { var o = "_ec_" + r[i](t[a], a),
                s = e[o];
            null == s ? (n.push(o), e[o] = a) : (s.length || (e[o] = s = [s]), s.push(a)) } }

    function Gu(t) { var e = {},
            n = e.encode = {},
            i = N(),
            r = [],
            a = [],
            o = e.userOutput = { dimensionNames: t.dimensions.slice(), encode: {} };
        f(t.dimensions, function(e) { var s = t.getDimensionInfo(e),
                l = s.coordDim; if (l) { var u = s.coordDimIndex;
                Wu(n, l)[u] = e, s.isExtraCoord || (i.set(l, 1), Uu(s.type) && (r[0] = e), Wu(o.encode, l)[u] = s.index), s.defaultTooltip && a.push(e) }
            _T.each(function(t, e) { var i = Wu(n, e),
                    r = s.otherDims[e];
                null != r && r !== !1 && (i[r] = s.name) }) }); var s = [],
            l = {};
        i.each(function(t, e) { var i = n[e];
            l[e] = i[0], s = s.concat(i) }), e.dataDimsOnCoord = s, e.encodeFirstDimNotExtra = l; var u = n.label;
        u && u.length && (r = u.slice()); var h = n.tooltip; return h && h.length ? a = h.slice() : a.length || (a = r.slice()), n.defaultedLabel = r, n.defaultedTooltip = a, e }

    function Wu(t, e) { return t.hasOwnProperty(e) || (t[e] = []), t[e] }

    function Zu(t) { return "category" === t ? "ordinal" : "time" === t ? "time" : "float" }

    function Uu(t) { return !("ordinal" === t || "time" === t) }

    function Xu(t) { null != t && o(this, t), this.otherDims = {} }

    function Yu(t) { return t._rawCount > 65535 ? TT : AT }

    function ju(t) { var e = t.constructor; return e === Array ? t.slice() : new e(t) }

    function qu(t, e) { f(DT.concat(e.__wrappedMethods || []), function(n) { e.hasOwnProperty(n) && (t[n] = e[n]) }), t.__wrappedMethods = e.__wrappedMethods, f(kT, function(n) { t[n] = i(e[n]) }), t._calculationInfo = o(e._calculationInfo) }

    function Ku(t, e, n, i, r) { var a = IT[e.type],
            o = i - 1,
            s = e.name,
            l = t[s][o]; if (l && l.length < n) { for (var u = new a(Math.min(r - o * n, n)), h = 0; h < l.length; h++) u[h] = l[h];
            t[s][o] = u } for (var c = i * n; r > c; c += n) t[s].push(new a(Math.min(r - c, n))) }

    function $u(t) { var e = t._invertedIndicesMap;
        f(e, function(n, i) { var r = t._dimensionInfos[i],
                a = r.ordinalMeta; if (a) { n = e[i] = new CT(a.categories.length); for (var o = 0; o < n.length; o++) n[o] = MT; for (var o = 0; o < t._count; o++) n[t.get(i, o)] = o } }) }

    function Qu(t, e, n) { var i; if (null != e) { var r = t._chunkSize,
                a = Math.floor(n / r),
                o = n % r,
                s = t.dimensions[e],
                l = t._storage[s][a]; if (l) { i = l[o]; var u = t._dimensionInfos[s].ordinalMeta;
                u && u.categories.length && (i = u.categories[i]) } } return i }

    function Ju(t) { return t }

    function th(t) { return t < this._count && t >= 0 ? this._indices[t] : -1 }

    function eh(t, e) { var n = t._idList[e]; return null == n && (n = Qu(t, t._idDimIdx, e)), null == n && (n = ST + e), n }

    function nh(t) { return _(t) || (t = [t]), t }

    function ih(t, e) { var n = t.dimensions,
            i = new PT(p(n, t.getDimensionInfo, t), t.hostModel);
        qu(i, t); for (var r = i._storage = {}, a = t._storage, o = 0; o < n.length; o++) { var s = n[o];
            a[s] && (u(e, s) >= 0 ? (r[s] = rh(a[s]), i._rawExtent[s] = ah(), i._extent[s] = null) : r[s] = a[s]) } return i }

    function rh(t) { for (var e = new Array(t.length), n = 0; n < t.length; n++) e[n] = ju(t[n]); return e }

    function ah() { return [1 / 0, -1 / 0] }

    function oh(t, e, n) {
        function r(t, e, n) { null != _T.get(e) ? t.otherDims[e] = n : (t.coordDim = e, t.coordDimIndex = n, u.set(e, !0)) }
        as.isInstance(e) || (e = as.seriesDataToSource(e)), n = n || {}, t = (t || []).slice(); for (var a = (n.dimsDef || []).slice(), l = N(), u = N(), h = [], c = sh(e, t, a, n.dimCount), d = 0; c > d; d++) { var p = a[d] = o({}, M(a[d]) ? a[d] : { name: a[d] }),
                g = p.name,
                v = h[d] = new Xu;
            null != g && null == l.get(g) && (v.name = v.displayName = g, l.set(g, d)), null != p.type && (v.type = p.type), null != p.displayName && (v.displayName = p.displayName) } var m = n.encodeDef;!m && n.encodeDefaulter && (m = n.encodeDefaulter(e, c)), m = N(m), m.each(function(t, e) { if (t = er(t).slice(), 1 === t.length && !w(t[0]) && t[0] < 0) return void m.set(e, !1); var n = m.set(e, []);
            f(t, function(t, i) { w(t) && (t = l.get(t)), null != t && c > t && (n[i] = t, r(h[t], e, i)) }) }); var y = 0;
        f(t, function(t) { var e, t, n, a; if (w(t)) e = t, t = {};
            else { e = t.name; var o = t.ordinalMeta;
                t.ordinalMeta = null, t = i(t), t.ordinalMeta = o, n = t.dimsDef, a = t.otherDims, t.name = t.coordDim = t.coordDimIndex = t.dimsDef = t.otherDims = null } var l = m.get(e); if (l !== !1) { var l = er(l); if (!l.length)
                    for (var u = 0; u < (n && n.length || 1); u++) { for (; y < h.length && null != h[y].coordDim;) y++;
                        y < h.length && l.push(y++) }
                f(l, function(i, o) { var l = h[i]; if (r(s(l, t), e, o), null == l.name && n) { var u = n[o];!M(u) && (u = { name: u }), l.name = l.displayName = u.name, l.defaultTooltip = u.defaultTooltip }
                    a && s(l.otherDims, a) }) } }); var x = n.generateCoord,
            _ = n.generateCoordCount,
            b = null != _;
        _ = x ? _ || 1 : 0; for (var S = x || "value", I = 0; c > I; I++) { var v = h[I] = h[I] || new Xu,
                T = v.coordDim;
            null == T && (v.coordDim = lh(S, u, b), v.coordDimIndex = 0, (!x || 0 >= _) && (v.isExtraCoord = !0), _--), null == v.name && (v.name = lh(v.coordDim, l)), null != v.type || ms(e, I, v.name) !== _S.Must && (!v.isExtraCoord || null == v.otherDims.itemName && null == v.otherDims.seriesName) || (v.type = "ordinal") } return h }

    function sh(t, e, n, i) { var r = Math.max(t.dimensionsDetectCount || 1, e.length, n.length, i || 0); return f(e, function(t) { var e = t.dimsDef;
            e && (r = Math.max(r, e.length)) }), r }

    function lh(t, e, n) { if (n || null != e.get(t)) { for (var i = 0; null != e.get(t + i);) i++;
            t += i } return e.set(t, !0), t }

    function uh(t) { this.coordSysName = t, this.coordSysDims = [], this.axisMap = N(), this.categoryAxisMap = N(), this.firstCategoryDimIndex = null }

    function hh(t) { var e = t.get("coordinateSystem"),
            n = new uh(e),
            i = ET[e]; return i ? (i(t, n, n.axisMap, n.categoryAxisMap), n) : void 0 }

    function ch(t) { return "category" === t.get("type") }

    function dh(t, e, n) { n = n || {}; var i, r, a, o, s = n.byIndex,
            l = n.stackedCoordDimension,
            u = !(!t || !t.get("stack")); if (f(e, function(t, n) { w(t) && (e[n] = t = { name: t }), u && !t.isExtraCoord && (s || i || !t.ordinalMeta || (i = t), r || "ordinal" === t.type || "time" === t.type || l && l !== t.coordDim || (r = t)) }), !r || s || i || (s = !0), r) { a = "__\x00ecstackresult", o = "__\x00ecstackedover", i && (i.createInvertedIndices = !0); var h = r.coordDim,
                c = r.type,
                d = 0;
            f(e, function(t) { t.coordDim === h && d++ }), e.push({ name: a, coordDim: h, coordDimIndex: d, type: c, isExtraCoord: !0, isCalculationCoord: !0 }), d++, e.push({ name: o, coordDim: o, coordDimIndex: d, type: c, isExtraCoord: !0, isCalculationCoord: !0 }) } return { stackedDimension: r && r.name, stackedByDimension: i && i.name, isStackedByIndex: s, stackedOverDimension: o, stackResultDimension: a } }

    function fh(t, e) { return !!e && e === t.getCalculationInfo("stackedDimension") }

    function ph(t, e) { return fh(t, e) ? t.getCalculationInfo("stackResultDimension") : e }

    function gh(t, e, n) { n = n || {}, as.isInstance(t) || (t = as.seriesDataToSource(t)); var i, r = e.get("coordinateSystem"),
            a = Cs.get(r),
            o = hh(e);
        o && (i = p(o.coordSysDims, function(t) { var e = { name: t },
                n = o.axisMap.get(t); if (n) { var i = n.get("type");
                e.type = Zu(i) } return e })), i || (i = a && (a.getDimensionsInfo ? a.getDimensionsInfo() : a.dimensions.slice()) || ["x", "y"]); var s, l, u = zT(t, { coordDimensions: i, generateCoord: n.generateCoord, encodeDefaulter: n.useEncodeDefaulter ? x(ps, i, e) : null });
        o && f(u, function(t, e) { var n = t.coordDim,
                i = o.categoryAxisMap.get(n);
            i && (null == s && (s = e), t.ordinalMeta = i.getOrdinalMeta()), null != t.otherDims.itemName && (l = !0) }), l || null == s || (u[s].otherDims.itemName = 0); var h = dh(e, u),
            c = new PT(u, e);
        c.setCalculationInfo(h); var d = null != s && vh(t) ? function(t, e, n, i) { return i === s ? n : this.defaultDimValueGetter(t, e, n, i) } : null; return c.hasItemOption = !1, c.initData(t, null, d), c }

    function vh(t) { if (t.sourceFormat === dS) { var e = mh(t.data || []); return null != e && !_(ir(e)) } }

    function mh(t) { for (var e = 0; e < t.length && null == t[e];) e++; return t[e] }

    function yh(t) { this._setting = t || {}, this._extent = [1 / 0, -1 / 0], this._interval = 0, this.init && this.init.apply(this, arguments) }

    function xh(t) { this.categories = t.categories || [], this._needCollect = t.needCollect, this._deduplication = t.deduplication, this._map }

    function _h(t) { return t._map || (t._map = N(t.categories)) }

    function bh(t) { return M(t) && null != t.value ? t.value : t + "" }

    function wh(t, e, n, i) { var r = {},
            a = t[1] - t[0],
            o = r.interval = Ro(a / e, !0);
        null != n && n > o && (o = r.interval = n), null != i && o > i && (o = r.interval = i); var s = r.intervalPrecision = Mh(o),
            l = r.niceTickExtent = [VT(Math.ceil(t[0] / o) * o, s), VT(Math.floor(t[1] / o) * o, s)]; return Ih(l, t), r }

    function Mh(t) { return Ao(t) + 2 }

    function Sh(t, e, n) { t[e] = Math.max(Math.min(t[e], n[1]), n[0]) }

    function Ih(t, e) {!isFinite(t[0]) && (t[0] = e[0]), !isFinite(t[1]) && (t[1] = e[1]), Sh(t, 0, e), Sh(t, 1, e), t[0] > t[1] && (t[0] = t[1]) }

    function Th(t) { return t.get("stack") || GT + t.seriesIndex }

    function Ch(t) { return t.dim + t.index }

    function Ah(t) { var e = [],
            n = t.axis,
            i = "axis0"; if ("category" === n.type) { for (var r = n.getBandWidth(), a = 0; a < t.count; a++) e.push(s({ bandWidth: r, axisKey: i, stackId: GT + a }, t)); for (var o = Lh(e), l = [], a = 0; a < t.count; a++) { var u = o[i][GT + a];
                u.offsetCenter = u.offset + u.width / 2, l.push(u) } return l } }

    function Dh(t, e) { var n = []; return e.eachSeriesByType(t, function(t) { Eh(t) && !Rh(t) && n.push(t) }), n }

    function kh(t) { var e = {};
        f(t, function(t) { var n = t.coordinateSystem,
                i = n.getBaseAxis(); if ("time" === i.type || "value" === i.type)
                for (var r = t.getData(), a = i.dim + "_" + i.index, o = r.mapDimension(i.dim), s = 0, l = r.count(); l > s; ++s) { var u = r.get(o, s);
                    e[a] ? e[a].push(u) : e[a] = [u] } }); var n = []; for (var i in e)
            if (e.hasOwnProperty(i)) { var r = e[i]; if (r) { r.sort(function(t, e) { return t - e }); for (var a = null, o = 1; o < r.length; ++o) { var s = r[o] - r[o - 1];
                        s > 0 && (a = null === a ? s : Math.min(a, s)) }
                    n[i] = a } }
        return n }

    function Ph(t) { var e = kh(t),
            n = []; return f(t, function(t) { var i, r = t.coordinateSystem,
                a = r.getBaseAxis(),
                o = a.getExtent(); if ("category" === a.type) i = a.getBandWidth();
            else if ("value" === a.type || "time" === a.type) { var s = a.dim + "_" + a.index,
                    l = e[s],
                    u = Math.abs(o[1] - o[0]),
                    h = a.scale.getExtent(),
                    c = Math.abs(h[1] - h[0]);
                i = l ? u / c * l : u } else { var d = t.getData();
                i = Math.abs(o[1] - o[0]) / d.count() } var f = So(t.get("barWidth"), i),
                p = So(t.get("barMaxWidth"), i),
                g = So(t.get("barMinWidth") || 1, i),
                v = t.get("barGap"),
                m = t.get("barCategoryGap");
            n.push({ bandWidth: i, barWidth: f, barMaxWidth: p, barMinWidth: g, barGap: v, barCategoryGap: m, axisKey: Ch(a), stackId: Th(t) }) }), Lh(n) }

    function Lh(t) { var e = {};
        f(t, function(t) { var n = t.axisKey,
                i = t.bandWidth,
                r = e[n] || { bandWidth: i, remainedWidth: i, autoWidthCount: 0, categoryGap: "20%", gap: "30%", stacks: {} },
                a = r.stacks;
            e[n] = r; var o = t.stackId;
            a[o] || r.autoWidthCount++, a[o] = a[o] || { width: 0, maxWidth: 0 }; var s = t.barWidth;
            s && !a[o].width && (a[o].width = s, s = Math.min(r.remainedWidth, s), r.remainedWidth -= s); var l = t.barMaxWidth;
            l && (a[o].maxWidth = l); var u = t.barMinWidth;
            u && (a[o].minWidth = u); var h = t.barGap;
            null != h && (r.gap = h); var c = t.barCategoryGap;
            null != c && (r.categoryGap = c) }); var n = {}; return f(e, function(t, e) { n[e] = {}; var i = t.stacks,
                r = t.bandWidth,
                a = So(t.categoryGap, r),
                o = So(t.gap, 1),
                s = t.remainedWidth,
                l = t.autoWidthCount,
                u = (s - a) / (l + (l - 1) * o);
            u = Math.max(u, 0), f(i, function(t) { var e = t.maxWidth,
                    n = t.minWidth; if (t.width) { var i = t.width;
                    e && (i = Math.min(i, e)), n && (i = Math.max(i, n)), t.width = i, s -= i + o * i, l-- } else { var i = u;
                    e && i > e && (i = Math.min(e, s)), n && n > i && (i = n), i !== u && (t.width = i, s -= i + o * i, l--) } }), u = (s - a) / (l + (l - 1) * o), u = Math.max(u, 0); var h, c = 0;
            f(i, function(t) { t.width || (t.width = u), h = t, c += t.width * (1 + o) }), h && (c -= h.width * o); var d = -c / 2;
            f(i, function(t, i) { n[e][i] = n[e][i] || { bandWidth: r, offset: d, width: t.width }, d += t.width * (1 + o) }) }), n }

    function Oh(t, e, n) { if (t && e) { var i = t[Ch(e)]; return null != i && null != n && (i = i[Th(n)]), i } }

    function zh(t, e) { var n = Dh(t, e),
            i = Ph(n),
            r = {};
        f(n, function(t) { var e = t.getData(),
                n = t.coordinateSystem,
                a = n.getBaseAxis(),
                o = Th(t),
                s = i[Ch(a)][o],
                l = s.offset,
                u = s.width,
                h = n.getOtherAxis(a),
                c = t.get("barMinHeight") || 0;
            r[o] = r[o] || [], e.setLayout({ bandWidth: s.bandWidth, offset: l, size: u }); for (var d = e.mapDimension(h.dim), f = e.mapDimension(a.dim), p = fh(e, d), g = h.isHorizontal(), v = Bh(a, h, p), m = 0, y = e.count(); y > m; m++) { var x = e.get(d, m),
                    _ = e.get(f, m),
                    b = x >= 0 ? "p" : "n",
                    w = v;
                p && (r[o][_] || (r[o][_] = { p: v, n: v }), w = r[o][_][b]); var M, S, I, T; if (g) { var C = n.dataToPoint([x, _]);
                    M = w, S = C[1] + l, I = C[0] - v, T = u, Math.abs(I) < c && (I = (0 > I ? -1 : 1) * c), isNaN(I) || p && (r[o][_][b] += I) } else { var C = n.dataToPoint([_, x]);
                    M = C[0] + l, S = w, I = u, T = C[1] - v, Math.abs(T) < c && (T = (0 >= T ? -1 : 1) * c), isNaN(T) || p && (r[o][_][b] += T) }
                e.setItemLayout(m, { x: M, y: S, width: I, height: T }) } }, this) }

    function Eh(t) { return t.coordinateSystem && "cartesian2d" === t.coordinateSystem.type }

    function Rh(t) { return t.pipelineContext && t.pipelineContext.large }

    function Bh(t, e) { return e.toGlobalCoord(e.dataToCoord("log" === e.type ? 1 : 0)) }

    function Nh(t, e) { return aC(t, rC(e)) }

    function Vh(t, e) { var n, i, r, a = t.type,
            o = e.getMin(),
            s = e.getMax(),
            l = null != o,
            u = null != s,
            h = t.getExtent(); "ordinal" === a ? n = e.getCategories().length : (i = e.get("boundaryGap"), _(i) || (i = [i || 0, i || 0]), "boolean" == typeof i[0] && (i = [0, 0]), i[0] = So(i[0], 1), i[1] = So(i[1], 1), r = h[1] - h[0] || Math.abs(h[0])), null == o && (o = "ordinal" === a ? n ? 0 : 0 / 0 : h[0] - i[0] * r), null == s && (s = "ordinal" === a ? n ? n - 1 : 0 / 0 : h[1] + i[1] * r), "dataMin" === o ? o = h[0] : "function" == typeof o && (o = o({ min: h[0], max: h[1] })), "dataMax" === s ? s = h[1] : "function" == typeof s && (s = s({ min: h[0], max: h[1] })), (null == o || !isFinite(o)) && (o = 0 / 0), (null == s || !isFinite(s)) && (s = 0 / 0), t.setBlank(C(o) || C(s) || "ordinal" === a && !t.getOrdinalMeta().categories.length), e.getNeedCrossZero() && (o > 0 && s > 0 && !l && (o = 0), 0 > o && 0 > s && !u && (s = 0)); var c = e.ecModel; if (c && "time" === a) { var d, p = Dh("bar", c); if (f(p, function(t) { d |= t.getBaseAxis() === e.axis }), d) { var g = Ph(p),
                    v = Fh(o, s, e, g);
                o = v.min, s = v.max } } return [o, s] }

    function Fh(t, e, n, i) { var r = n.axis.getExtent(),
            a = r[1] - r[0],
            o = Oh(i, n.axis); if (void 0 === o) return { min: t, max: e }; var s = 1 / 0;
        f(o, function(t) { s = Math.min(t.offset, s) }); var l = -1 / 0;
        f(o, function(t) { l = Math.max(t.offset + t.width, l) }), s = Math.abs(s), l = Math.abs(l); var u = s + l,
            h = e - t,
            c = 1 - (s + l) / a,
            d = h / c - h; return e += d * (l / u), t -= d * (s / u), { min: t, max: e } }

    function Hh(t, e) { var n = Vh(t, e),
            i = null != e.getMin(),
            r = null != e.getMax(),
            a = e.get("splitNumber"); "log" === t.type && (t.base = e.get("logBase")); var o = t.type;
        t.setExtent(n[0], n[1]), t.niceExtent({ splitNumber: a, fixMin: i, fixMax: r, minInterval: "interval" === o || "time" === o ? e.get("minInterval") : null, maxInterval: "interval" === o || "time" === o ? e.get("maxInterval") : null }); var s = e.get("interval");
        null != s && t.setInterval && t.setInterval(s) }

    function Gh(t, e) { if (e = e || t.get("type")) switch (e) {
            case "category":
                return new NT(t.getOrdinalMeta ? t.getOrdinalMeta() : t.getCategories(), [1 / 0, -1 / 0]);
            case "value":
                return new HT;
            default:
                return (yh.getClass(e) || HT).create(t) } }

    function Wh(t) { var e = t.scale.getExtent(),
            n = e[0],
            i = e[1]; return !(n > 0 && i > 0 || 0 > n && 0 > i) }

    function Zh(t) { var e = t.getLabelModel().get("formatter"),
            n = "category" === t.type ? t.scale.getExtent()[0] : null; return "string" == typeof e ? e = function(e) { return function(n) { return n = t.scale.getLabel(n), e.replace("{value}", null != n ? n : "") } }(e) : "function" == typeof e ? function(i, r) { return null != n && (r = i - n), e(Uh(t, i), r) } : function(e) { return t.scale.getLabel(e) } }

    function Uh(t, e) { return "category" === t.type ? t.scale.getLabel(e) : e }

    function Xh(t) { var e = t.model,
            n = t.scale; if (e.get("axisLabel.show") && !n.isBlank()) { var i, r, a = "category" === t.type,
                o = n.getExtent();
            a ? r = n.count() : (i = n.getTicks(), r = i.length); var s, l = t.getLabelModel(),
                u = Zh(t),
                h = 1;
            r > 40 && (h = Math.ceil(r / 40)); for (var c = 0; r > c; c += h) { var d = i ? i[c] : o[0] + c,
                    f = u(d),
                    p = l.getTextRect(f),
                    g = Yh(p, l.get("rotate") || 0);
                s ? s.union(g) : s = g } return s } }

    function Yh(t, e) { var n = e * Math.PI / 180,
            i = t.plain(),
            r = i.width,
            a = i.height,
            o = r * Math.cos(n) + a * Math.sin(n),
            s = r * Math.sin(n) + a * Math.cos(n),
            l = new Cn(i.x, i.y, o, s); return l }

    function jh(t) { var e = t.get("interval"); return null == e ? "auto" : e }

    function qh(t) { return "category" === t.type && 0 === jh(t.getLabelModel()) }

    function Kh(t, e) { if ("image" !== this.type) { var n = this.style,
                i = this.shape;
            i && "line" === i.symbolType ? n.stroke = t : this.__isEmptyBrush ? (n.stroke = t, n.fill = e || "#fff") : (n.fill && (n.fill = t), n.stroke && (n.stroke = t)), this.dirty(!1) } }

    function $h(t, e, n, i, r, a, o) { var s = 0 === t.indexOf("empty");
        s && (t = t.substr(5, 1).toLowerCase() + t.substr(6)); var l; return l = 0 === t.indexOf("image://") ? wa(t.slice(8), new Cn(e, n, i, r), o ? "center" : "cover") : 0 === t.indexOf("path://") ? ba(t.slice(7), {}, new Cn(e, n, i, r), o ? "center" : "cover") : new xC({ shape: { symbolType: t, x: e, y: n, width: i, height: r } }), l.__isEmptyBrush = s, l.setColor = Kh, l.setColor(a), l }

    function Qh(t) { return gh(t.getSource(), t) }

    function Jh(t, e) { var n = e;
        vo.isInstance(e) || (n = new vo(e), c(n, cC)); var i = Gh(n); return i.setExtent(t[0], t[1]), Hh(i, n), i }

    function tc(t) { c(t, cC) }

    function ec(t, e) { return Math.abs(t - e) < wC }

    function nc(t, e, n) { var i = 0,
            r = t[0]; if (!r) return !1; for (var a = 1; a < t.length; a++) { var o = t[a];
            i += jr(r[0], r[1], o[0], o[1], e, n), r = o } var s = t[0]; return ec(r[0], s[0]) && ec(r[1], s[1]) || (i += jr(r[0], r[1], s[0], s[1], e, n)), 0 !== i }

    function ic(t, e, n) { if (this.name = t, this.geometries = e, n) n = [n[0], n[1]];
        else { var i = this.getBoundingRect();
            n = [i.x + i.width / 2, i.y + i.height / 2] }
        this.center = n }

    function rc(t) { if (!t.UTF8Encoding) return t; var e = t.UTF8Scale;
        null == e && (e = 1024); for (var n = t.features, i = 0; i < n.length; i++)
            for (var r = n[i], a = r.geometry, o = a.coordinates, s = a.encodeOffsets, l = 0; l < o.length; l++) { var u = o[l]; if ("Polygon" === a.type) o[l] = ac(u, s[l], e);
                else if ("MultiPolygon" === a.type)
                    for (var h = 0; h < u.length; h++) { var c = u[h];
                        u[h] = ac(c, s[l][h], e) } }
        return t.UTF8Encoding = !1, t }

    function ac(t, e, n) { for (var i = [], r = e[0], a = e[1], o = 0; o < t.length; o += 2) { var s = t.charCodeAt(o) - 64,
                l = t.charCodeAt(o + 1) - 64;
            s = s >> 1 ^ -(1 & s), l = l >> 1 ^ -(1 & l), s += r, l += a, r = s, a = l, i.push([s / n, l / n]) } return i }

    function oc(t) { return "category" === t.type ? lc(t) : cc(t) }

    function sc(t, e) { return "category" === t.type ? hc(t, e) : { ticks: t.scale.getTicks() } }

    function lc(t) { var e = t.getLabelModel(),
            n = uc(t, e); return !e.get("show") || t.scale.isBlank() ? { labels: [], labelCategoryInterval: n.labelCategoryInterval } : n }

    function uc(t, e) { var n = dc(t, "labels"),
            i = jh(e),
            r = fc(n, i); if (r) return r; var a, o; return b(i) ? a = xc(t, i) : (o = "auto" === i ? gc(t) : i, a = yc(t, o)), pc(n, i, { labels: a, labelCategoryInterval: o }) }

    function hc(t, e) { var n = dc(t, "ticks"),
            i = jh(e),
            r = fc(n, i); if (r) return r; var a, o; if ((!e.get("show") || t.scale.isBlank()) && (a = []), b(i)) a = xc(t, i, !0);
        else if ("auto" === i) { var s = uc(t, t.getLabelModel());
            o = s.labelCategoryInterval, a = p(s.labels, function(t) { return t.tickValue }) } else o = i, a = yc(t, o, !0); return pc(n, i, { ticks: a, tickCategoryInterval: o }) }

    function cc(t) { var e = t.scale.getTicks(),
            n = Zh(t); return { labels: p(e, function(e, i) { return { formattedLabel: n(e, i), rawLabel: t.scale.getLabel(e), tickValue: e } }) } }

    function dc(t, e) { return SC(t)[e] || (SC(t)[e] = []) }

    function fc(t, e) { for (var n = 0; n < t.length; n++)
            if (t[n].key === e) return t[n].value }

    function pc(t, e, n) { return t.push({ key: e, value: n }), n }

    function gc(t) { var e = SC(t).autoInterval; return null != e ? e : SC(t).autoInterval = t.calculateCategoryInterval() }

    function vc(t) { var e = mc(t),
            n = Zh(t),
            i = (e.axisRotate - e.labelRotate) / 180 * Math.PI,
            r = t.scale,
            a = r.getExtent(),
            o = r.count(); if (a[1] - a[0] < 1) return 0; var s = 1;
        o > 40 && (s = Math.max(1, Math.floor(o / 40))); for (var l = a[0], u = t.dataToCoord(l + 1) - t.dataToCoord(l), h = Math.abs(u * Math.cos(i)), c = Math.abs(u * Math.sin(i)), d = 0, f = 0; l <= a[1]; l += s) { var p = 0,
                g = 0,
                v = Yn(n(l), e.font, "center", "top");
            p = 1.3 * v.width, g = 1.3 * v.height, d = Math.max(d, p, 7), f = Math.max(f, g, 7) } var m = d / h,
            y = f / c;
        isNaN(m) && (m = 1 / 0), isNaN(y) && (y = 1 / 0); var x = Math.max(0, Math.floor(Math.min(m, y))),
            _ = SC(t.model),
            b = t.getExtent(),
            w = _.lastAutoInterval,
            M = _.lastTickCount; return null != w && null != M && Math.abs(w - x) <= 1 && Math.abs(M - o) <= 1 && w > x && _.axisExtend0 === b[0] && _.axisExtend1 === b[1] ? x = w : (_.lastTickCount = o, _.lastAutoInterval = x, _.axisExtend0 = b[0], _.axisExtend1 = b[1]), x }

    function mc(t) { var e = t.getLabelModel(); return { axisRotate: t.getRotate ? t.getRotate() : t.isHorizontal && !t.isHorizontal() ? 90 : 0, labelRotate: e.get("rotate") || 0, font: e.getFont() } }

    function yc(t, e, n) {
        function i(t) { l.push(n ? t : { formattedLabel: r(t), rawLabel: a.getLabel(t), tickValue: t }) } var r = Zh(t),
            a = t.scale,
            o = a.getExtent(),
            s = t.getLabelModel(),
            l = [],
            u = Math.max((e || 0) + 1, 1),
            h = o[0],
            c = a.count();
        0 !== h && u > 1 && c / u > 2 && (h = Math.round(Math.ceil(h / u) * u)); var d = qh(t),
            f = s.get("showMinLabel") || d,
            p = s.get("showMaxLabel") || d;
        f && h !== o[0] && i(o[0]); for (var g = h; g <= o[1]; g += u) i(g); return p && g - u !== o[1] && i(o[1]), l }

    function xc(t, e, n) { var i = t.scale,
            r = Zh(t),
            a = []; return f(i.getTicks(), function(t) { var o = i.getLabel(t);
            e(t, o) && a.push(n ? t : { formattedLabel: r(t), rawLabel: o, tickValue: t }) }), a }

    function _c(t, e) { var n = t[1] - t[0],
            i = e,
            r = n / i / 2;
        t[0] += r, t[1] -= r }

    function bc(t, e, n, i) {
        function r(t, e) { return t = Io(t), e = Io(e), d ? t > e : e > t } var a = e.length; if (t.onBand && !n && a) { var o, s, l = t.getExtent(); if (1 === a) e[0].coord = l[0], o = e[1] = { coord: l[0] };
            else { var u = e[a - 1].tickValue - e[0].tickValue,
                    h = (e[a - 1].coord - e[0].coord) / u;
                f(e, function(t) { t.coord -= h / 2 }); var c = t.scale.getExtent();
                s = 1 + c[1] - e[a - 1].tickValue, o = { coord: e[a - 1].coord + h * s }, e.push(o) } var d = l[0] > l[1];
            r(e[0].coord, l[0]) && (i ? e[0].coord = l[0] : e.shift()), i && r(l[0], e[0].coord) && e.unshift({ coord: l[0] }), r(l[1], o.coord) && (i ? o.coord = l[1] : e.pop()), i && r(o.coord, l[1]) && e.push({ coord: l[1] }) } }

    function wc(t) { return this._axes[t] }

    function Mc(t) { kC.call(this, t) }

    function Sc(t, e) { return e.type || (e.data ? "category" : "value") }

    function Ic(t, e) { return t.getCoordSysModel() === e }

    function Tc(t, e, n) { this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this._initCartesian(t, e, n), this.model = t }

    function Cc(t, e, n, i) {
        function r(t) { return t.dim + "_" + t.index }
        n.getAxesOnZeroOf = function() { return a ? [a] : [] }; var a, o = t[e],
            s = n.model,
            l = s.get("axisLine.onZero"),
            u = s.get("axisLine.onZeroAxisIndex"); if (l) { if (null != u) Ac(o[u]) && (a = o[u]);
            else
                for (var h in o)
                    if (o.hasOwnProperty(h) && Ac(o[h]) && !i[r(o[h])]) { a = o[h]; break }
            a && (i[r(a)] = !0) } }

    function Ac(t) { return t && "category" !== t.type && "time" !== t.type && Wh(t) }

    function Dc(t, e) { var n = t.getExtent(),
            i = n[0] + n[1];
        t.toGlobalCoord = "x" === t.dim ? function(t) { return t + e } : function(t) { return i - t + e }, t.toLocalCoord = "x" === t.dim ? function(t) { return t - e } : function(t) { return i - t + e } }

    function kc(t) { return p(VC, function(e) { var n = t.getReferringComponents(e)[0]; return n }) }

    function Pc(t) { return "cartesian2d" === t.get("coordinateSystem") }

    function Lc(t, e) { var n = t.mapDimension("defaultedLabel", !0),
            i = n.length; if (1 === i) return Js(t, e, n[0]); if (i) { for (var r = [], a = 0; a < n.length; a++) { var o = Js(t, e, n[a]);
                r.push(o) } return r.join(" ") } }

    function Oc(t, e, n, i, r, a) { var o = n.getModel("label"),
            s = n.getModel("emphasis.label");
        Za(t, e, o, s, { labelFetcher: r, labelDataIndex: a, defaultText: Lc(r.getData(), a), isRectText: !0, autoColor: i }), zc(t), zc(e) }

    function zc(t, e) { "outside" === t.textPosition && (t.textPosition = e) }

    function Ec(t, e, n) { var i = t.getArea(),
            r = t.getBaseAxis().isHorizontal(),
            a = i.x,
            o = i.y,
            s = i.width,
            l = i.height,
            u = n.get("lineStyle.width") || 2;
        a -= u / 2, o -= u / 2, s += u, l += u; var h = new cM({ shape: { x: a, y: o, width: s, height: l } }); return e && (h.shape[r ? "width" : "height"] = 0, io(h, { shape: { width: s, height: l } }, n)), h }

    function Rc(t, e, n) { var i = t.getArea(),
            r = new iM({ shape: { cx: Io(t.cx, 1), cy: Io(t.cy, 1), r0: Io(i.r0, 1), r: Io(i.r, 1), startAngle: i.startAngle, endAngle: i.endAngle, clockwise: i.clockwise } }); return e && (r.shape.endAngle = i.startAngle, io(r, { shape: { endAngle: i.endAngle } }, n)), r }

    function Bc(t, e, n) { return t ? "polar" === t.type ? Rc(t, e, n) : "cartesian2d" === t.type ? Ec(t, e, n) : null : null }

    function Nc(t, e) { var n = t.getArea && t.getArea(); if ("cartesian2d" === t.type) { var i = t.getBaseAxis(); if ("category" !== i.type || !i.onBand) { var r = e.getLayout("bandWidth");
                i.isHorizontal() ? (n.x -= r, n.width += 2 * r) : (n.y -= r, n.height += 2 * r) } } return n }

    function Vc(t, e, n) { n.style.text = null, no(n, { shape: { width: 0 } }, e, t, function() { n.parent && n.parent.remove(n) }) }

    function Fc(t, e, n) { n.style.text = null, no(n, { shape: { r: n.shape.r0 } }, e, t, function() { n.parent && n.parent.remove(n) }) }

    function Hc(t) { return null != t.startAngle && null != t.endAngle && t.startAngle === t.endAngle }

    function Gc(t, e, n, i, r, a, o, l) { var u = e.getItemVisual(n, "color"),
            h = e.getItemVisual(n, "opacity"),
            c = e.getVisual("borderColor"),
            d = i.getModel("itemStyle"),
            f = i.getModel("emphasis.itemStyle").getBarItemStyle();
        l || t.setShape("r", d.get("barBorderRadius") || 0), t.useStyle(s({ stroke: Hc(r) ? "none" : c, fill: Hc(r) ? "none" : u, opacity: h }, d.getBarItemStyle())); var p = i.getShallow("cursor");
        p && t.attr("cursor", p); var g = o ? r.height > 0 ? "bottom" : "top" : r.width > 0 ? "left" : "right";
        l || Oc(t.style, f, i, u, a, n, g), Hc(r) && (f.fill = f.stroke = "none"), Fa(t, f) }

    function Wc(t, e) { var n = t.get(ZC) || 0,
            i = isNaN(e.width) ? Number.MAX_VALUE : Math.abs(e.width),
            r = isNaN(e.height) ? Number.MAX_VALUE : Math.abs(e.height); return Math.min(n, i, r) }

    function Zc(t, e, n) { var i = t.getData(),
            r = [],
            a = i.getLayout("valueAxisHorizontal") ? 1 : 0;
        r[1 - a] = i.getLayout("valueAxisStart"); var o = i.getLayout("largeDataIndices"),
            s = i.getLayout("barWidth"),
            l = t.getModel("backgroundStyle"),
            u = t.get("showBackground", !0); if (u) { var h = i.getLayout("largeBackgroundPoints"),
                c = [];
            c[1 - a] = i.getLayout("backgroundStart"); var d = new $C({ shape: { points: h }, incremental: !!n, __startPoint: c, __baseDimIdx: a, __largeDataIndices: o, __barWidth: s, silent: !0, z2: 0 });
            Yc(d, l, i), e.add(d) } var f = new $C({ shape: { points: i.getLayout("largePoints") }, incremental: !!n, __startPoint: r, __baseDimIdx: a, __largeDataIndices: o, __barWidth: s });
        e.add(f), Xc(f, t, i), f.seriesIndex = t.seriesIndex, t.get("silent") || (f.on("mousedown", QC), f.on("mousemove", QC)) }

    function Uc(t, e, n) { var i = t.__baseDimIdx,
            r = 1 - i,
            a = t.shape.points,
            o = t.__largeDataIndices,
            s = Math.abs(t.__barWidth / 2),
            l = t.__startPoint[r];
        UC[0] = e, UC[1] = n; for (var u = UC[i], h = UC[1 - i], c = u - s, d = u + s, f = 0, p = a.length / 2; p > f; f++) { var g = 2 * f,
                v = a[g + i],
                m = a[g + r]; if (v >= c && d >= v && (m >= l ? h >= l && m >= h : h >= m && l >= h)) return o[f] } return -1 }

    function Xc(t, e, n) { var i = n.getVisual("borderColor") || n.getVisual("color"),
            r = e.getModel("itemStyle").getItemStyle(["color", "borderColor"]);
        t.useStyle(r), t.style.fill = null, t.style.stroke = i, t.style.lineWidth = n.getLayout("barWidth") }

    function Yc(t, e, n) { var i = e.get("borderColor") || e.get("color"),
            r = e.getItemStyle(["color", "borderColor"]);
        t.useStyle(r), t.style.fill = null, t.style.stroke = i, t.style.lineWidth = n.getLayout("barWidth") }

    function jc(t, e, n) { var i, r = "polar" === n.type; return i = r ? n.getArea() : n.grid.getRect(), r ? { cx: i.cx, cy: i.cy, r0: t ? i.r0 : e.r0, r: t ? i.r : e.r, startAngle: t ? e.startAngle : 0, endAngle: t ? e.endAngle : 2 * Math.PI } : { x: t ? e.x : i.x, y: t ? i.y : e.y, width: t ? e.width : i.width, height: t ? i.height : e.height } }

    function qc(t, e, n) { var i = "polar" === t.type ? iM : cM; return new i({ shape: jc(e, n, t), silent: !0, z2: 0 }) }

    function Kc(t, e, n, i) { var r, a, o = Po(n - t.rotation),
            s = i[0] > i[1],
            l = "start" === e && !s || "start" !== e && s; return Lo(o - JC / 2) ? (a = l ? "bottom" : "top", r = "center") : Lo(o - 1.5 * JC) ? (a = l ? "top" : "bottom", r = "center") : (a = "middle", r = 1.5 * JC > o && o > JC / 2 ? l ? "left" : "right" : l ? "right" : "left"), { rotation: o, textAlign: r, textVerticalAlign: a } }

    function $c(t, e, n) { if (!qh(t.axis)) { var i = t.get("axisLabel.showMinLabel"),
                r = t.get("axisLabel.showMaxLabel");
            e = e || [], n = n || []; var a = e[0],
                o = e[1],
                s = e[e.length - 1],
                l = e[e.length - 2],
                u = n[0],
                h = n[1],
                c = n[n.length - 1],
                d = n[n.length - 2];
            i === !1 ? (Qc(a), Qc(u)) : Jc(a, o) && (i ? (Qc(o), Qc(h)) : (Qc(a), Qc(u))), r === !1 ? (Qc(s), Qc(c)) : Jc(l, s) && (r ? (Qc(l), Qc(d)) : (Qc(s), Qc(c))) } }

    function Qc(t) { t && (t.ignore = !0) }

    function Jc(t, e) { var n = t && t.getBoundingRect().clone(),
            i = e && e.getBoundingRect().clone(); if (n && i) { var r = ze([]); return Ne(r, r, -t.rotation), n.applyTransform(Re([], r, t.getLocalTransform())), i.applyTransform(Re([], r, e.getLocalTransform())), n.intersect(i) } }

    function td(t) { return "middle" === t || "center" === t }

    function ed(t, e, n, i, r) { for (var a = [], o = [], s = [], l = 0; l < t.length; l++) { var u = t[l].coord;
            o[0] = u, o[1] = 0, s[0] = u, s[1] = n, e && (ae(o, o, e), ae(s, s, e)); var h = new fM({ anid: r + "_" + t[l].tickValue, subPixelOptimize: !0, shape: { x1: o[0], y1: o[1], x2: s[0], y2: s[1] }, style: i, z2: 2, silent: !0 });
            a.push(h) } return a }

    function nd(t, e, n) { var i = e.axis,
            r = e.getModel("axisTick"); if (r.get("show") && !i.scale.isBlank()) { for (var a = r.getModel("lineStyle"), o = n.tickDirection * r.get("length"), l = i.getTicksCoords(), u = ed(l, t._transform, o, s(a.getLineStyle(), { stroke: e.get("axisLine.lineStyle.color") }), "ticks"), h = 0; h < u.length; h++) t.group.add(u[h]); return u } }

    function id(t, e, n) { var i = e.axis,
            r = e.getModel("minorTick"); if (r.get("show") && !i.scale.isBlank()) { var a = i.getMinorTicksCoords(); if (a.length)
                for (var o = r.getModel("lineStyle"), l = n.tickDirection * r.get("length"), u = s(o.getLineStyle(), s(e.getModel("axisTick").getLineStyle(), { stroke: e.get("axisLine.lineStyle.color") })), h = 0; h < a.length; h++)
                    for (var c = ed(a[h], t._transform, l, u, "minorticks_" + h), d = 0; d < c.length; d++) t.group.add(c[d]) } }

    function rd(t, e, n) { var i = e.axis,
            r = A(n.axisLabelShow, e.get("axisLabel.show")); if (r && !i.scale.isBlank()) { var a = e.getModel("axisLabel"),
                o = a.get("margin"),
                s = i.getViewLabels(),
                l = (A(n.labelRotate, a.get("rotate")) || 0) * JC / 180,
                u = iA(n.rotation, l, n.labelDirection),
                h = e.getCategories && e.getCategories(!0),
                c = [],
                d = rA(e),
                p = e.get("triggerEvent"); return f(s, function(r, s) { var l = r.tickValue,
                    f = r.formattedLabel,
                    g = r.rawLabel,
                    v = a;
                h && h[l] && h[l].textStyle && (v = new vo(h[l].textStyle, a, e.ecModel)); var m = v.getTextColor() || e.get("axisLine.lineStyle.color"),
                    y = i.dataToCoord(l),
                    x = [y, n.labelOffset + n.labelDirection * o],
                    _ = new Jw({ anid: "label_" + l, position: x, rotation: u.rotation, silent: d, z2: 10 });
                Xa(_.style, v, { text: f, textAlign: v.getShallow("align", !0) || u.textAlign, textVerticalAlign: v.getShallow("verticalAlign", !0) || v.getShallow("baseline", !0) || u.textVerticalAlign, textFill: "function" == typeof m ? m("category" === i.type ? g : "value" === i.type ? l + "" : l, s) : m }), p && (_.eventData = nA(e), _.eventData.targetType = "axisLabel", _.eventData.value = g), t._dumbGroup.add(_), _.updateTransform(), c.push(_), t.group.add(_), _.decomposeTransform() }), c } }

    function ad(t, e) { var n = { axesInfo: {}, seriesInvolved: !1, coordSysAxesInfo: {}, coordSysMap: {} }; return od(n, t, e), n.seriesInvolved && ld(n, t), n }

    function od(t, e, n) { var i = e.getComponent("tooltip"),
            r = e.getComponent("axisPointer"),
            a = r.get("link", !0) || [],
            o = [];
        aA(n.getCoordinateSystems(), function(n) {
            function s(i, s, l) { var h = l.model.getModel("axisPointer", r),
                    d = h.get("show"); if (d && ("auto" !== d || i || pd(h))) { null == s && (s = h.get("triggerTooltip")), h = i ? sd(l, c, r, e, i, s) : h; var f = h.get("snap"),
                        p = gd(l.model),
                        g = s || f || "category" === l.type,
                        v = t.axesInfo[p] = { key: p, axis: l, coordSys: n, axisPointerModel: h, triggerTooltip: s, involveSeries: g, snap: f, useHandle: pd(h), seriesModels: [] };
                    u[p] = v, t.seriesInvolved |= g; var m = ud(a, l); if (null != m) { var y = o[m] || (o[m] = { axesInfo: {} });
                        y.axesInfo[p] = v, y.mapper = a[m].mapper, v.linkGroup = y } } } if (n.axisPointerEnabled) { var l = gd(n.model),
                    u = t.coordSysAxesInfo[l] = {};
                t.coordSysMap[l] = n; var h = n.model,
                    c = h.getModel("tooltip", i); if (aA(n.getAxes(), oA(s, !1, null)), n.getTooltipAxes && i && c.get("show")) { var d = "axis" === c.get("trigger"),
                        f = "cross" === c.get("axisPointer.type"),
                        p = n.getTooltipAxes(c.get("axisPointer.axis"));
                    (d || f) && aA(p.baseAxes, oA(s, f ? "cross" : !0, d)), f && aA(p.otherAxes, oA(s, "cross", !1)) } } }) }

    function sd(t, e, n, r, a, o) {
        var l = e.getModel("axisPointer"),
            u = {};
        aA(["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], function(t) { u[t] = i(l.get(t)) }), u.snap = "category" !== t.type && !!o, "cross" === l.get("type") && (u.type = "line");
        var h = u.label || (u.label = {});
        if (null == h.show && (h.show = !1), "cross" === a) {
            var c = l.get("label.show");
            if (h.show = null != c ? c : !0, !o) { var d = u.lineStyle = l.get("crossStyle");
                d && s(h, d.textStyle) }
        }
        return t.model.getModel("axisPointer", new vo(u, n, r))
    }

    function ld(t, e) { e.eachSeries(function(e) { var n = e.coordinateSystem,
                i = e.get("tooltip.trigger", !0),
                r = e.get("tooltip.show", !0);
            n && "none" !== i && i !== !1 && "item" !== i && r !== !1 && e.get("axisPointer.show", !0) !== !1 && aA(t.coordSysAxesInfo[gd(n.model)], function(t) { var i = t.axis;
                n.getAxis(i.dim) === i && (t.seriesModels.push(e), null == t.seriesDataCount && (t.seriesDataCount = 0), t.seriesDataCount += e.getData().count()) }) }, this) }

    function ud(t, e) { for (var n = e.model, i = e.dim, r = 0; r < t.length; r++) { var a = t[r] || {}; if (hd(a[i + "AxisId"], n.id) || hd(a[i + "AxisIndex"], n.componentIndex) || hd(a[i + "AxisName"], n.name)) return r } }

    function hd(t, e) { return "all" === t || _(t) && u(t, e) >= 0 || t === e }

    function cd(t) { var e = dd(t); if (e) { var n = e.axisPointerModel,
                i = e.axis.scale,
                r = n.option,
                a = n.get("status"),
                o = n.get("value");
            null != o && (o = i.parse(o)); var s = pd(n);
            null == a && (r.status = s ? "show" : "hide"); var l = i.getExtent().slice();
            l[0] > l[1] && l.reverse(), (null == o || o > l[1]) && (o = l[1]), o < l[0] && (o = l[0]), r.value = o, s && (r.status = e.axis.scale.isBlank() ? "hide" : "show") } }

    function dd(t) { var e = (t.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo; return e && e.axesInfo[gd(t)] }

    function fd(t) { var e = dd(t); return e && e.axisPointerModel }

    function pd(t) { return !!t.get("handle.show") }

    function gd(t) { return t.type + "||" + t.id }

    function vd(t, e, n, i, r, a) { var o = sA.getAxisPointerClass(t.axisPointerClass); if (o) { var s = fd(e);
            s ? (t._axisPointer || (t._axisPointer = new o)).render(e, s, i, a) : md(t, i) } }

    function md(t, e, n) { var i = t._axisPointer;
        i && i.dispose(e, n), t._axisPointer = null }

    function yd(t, e, n) { n = n || {}; var i = t.coordinateSystem,
            r = e.axis,
            a = {},
            o = r.getAxesOnZeroOf()[0],
            s = r.position,
            l = o ? "onZero" : s,
            u = r.dim,
            h = i.getRect(),
            c = [h.x, h.x + h.width, h.y, h.y + h.height],
            d = { left: 0, right: 1, top: 0, bottom: 1, onZero: 2 },
            f = e.get("offset") || 0,
            p = "x" === u ? [c[2] - f, c[3] + f] : [c[0] - f, c[1] + f]; if (o) { var g = o.toGlobalCoord(o.dataToCoord(0));
            p[d.onZero] = Math.max(Math.min(g, p[1]), p[0]) }
        a.position = ["y" === u ? p[d[l]] : c[0], "x" === u ? p[d[l]] : c[3]], a.rotation = Math.PI / 2 * ("x" === u ? 0 : 1); var v = { top: -1, bottom: 1, left: -1, right: 1 };
        a.labelDirection = a.tickDirection = a.nameDirection = v[s], a.labelOffset = o ? p[d[s]] - p[d.onZero] : 0, e.get("axisTick.inside") && (a.tickDirection = -a.tickDirection), A(n.labelInside, e.get("axisLabel.inside")) && (a.labelDirection = -a.labelDirection); var m = e.get("axisLabel.rotate"); return a.labelRotate = "top" === l ? -m : m, a.z2 = 1, a }

    function xd(t, e, n, i) { var r = n.axis; if (!r.scale.isBlank()) { var a = n.getModel("splitArea"),
                o = a.getModel("areaStyle"),
                l = o.get("color"),
                u = i.coordinateSystem.getRect(),
                h = r.getTicksCoords({ tickModel: a, clamp: !0 }); if (h.length) { var c = l.length,
                    d = t.__splitAreaColors,
                    f = N(),
                    p = 0; if (d)
                    for (var g = 0; g < h.length; g++) { var v = d.get(h[g].tickValue); if (null != v) { p = (v + (c - 1) * g) % c; break } }
                var m = r.toGlobalCoord(h[0].coord),
                    y = o.getAreaStyle();
                l = _(l) ? l : [l]; for (var g = 1; g < h.length; g++) { var x, b, w, M, S = r.toGlobalCoord(h[g].coord);
                    r.isHorizontal() ? (x = m, b = u.y, w = S - x, M = u.height, m = x + w) : (x = u.x, b = m, w = u.width, M = S - b, m = b + M); var I = h[g - 1].tickValue;
                    null != I && f.set(I, p), e.add(new cM({ anid: null != I ? "area_" + I : null, shape: { x: x, y: b, width: w, height: M }, style: s({ fill: l[p] }, y), silent: !0 })), p = (p + 1) % c }
                t.__splitAreaColors = f } } }

    function _d(t) { t.__splitAreaColors = null }

    function bd(t, e, n) { N_.call(this), this.updateData(t, e, n) }

    function wd(t) { return [t[0] / 2, t[1] / 2] }

    function Md(t, e) { this.parent.drift(t, e) }

    function Sd(t, e) { if (!this.incremental && !this.useHoverLayer)
            if ("emphasis" === e) { var n = this.__symbolOriginalScale,
                    i = n[1] / n[0],
                    r = { scale: [Math.max(1.1 * n[0], n[0] + 3), Math.max(1.1 * n[1], n[1] + 3 * i)] };
                this.animateTo(r, 400, "elasticOut") } else "normal" === e && this.animateTo({ scale: this.__symbolOriginalScale }, 400, "elasticOut") }

    function Id(t) { this.group = new N_, this._symbolCtor = t || bd }

    function Td(t, e, n, i) { return !(!e || isNaN(e[0]) || isNaN(e[1]) || i.isIgnore && i.isIgnore(n) || i.clipShape && !i.clipShape.contain(e[0], e[1]) || "none" === t.getItemVisual(n, "symbol")) }

    function Cd(t) { return null == t || M(t) || (t = { isIgnore: t }), t || {} }

    function Ad(t) { var e = t.hostModel; return { itemStyle: e.getModel("itemStyle").getItemStyle(["color"]), hoverItemStyle: e.getModel("emphasis.itemStyle").getItemStyle(), symbolRotate: e.get("symbolRotate"), symbolOffset: e.get("symbolOffset"), hoverAnimation: e.get("hoverAnimation"), labelModel: e.getModel("label"), hoverLabelModel: e.getModel("emphasis.label"), cursorStyle: e.get("cursor") } }

    function Dd(t, e, n) { var i, r = t.getBaseAxis(),
            a = t.getOtherAxis(r),
            o = kd(a, n),
            s = r.dim,
            l = a.dim,
            u = e.mapDimension(l),
            h = e.mapDimension(s),
            c = "x" === l || "radius" === l ? 1 : 0,
            d = p(t.dimensions, function(t) { return e.mapDimension(t) }),
            f = e.getCalculationInfo("stackResultDimension"); return (i |= fh(e, d[0])) && (d[0] = f), (i |= fh(e, d[1])) && (d[1] = f), { dataDimsForPoint: d, valueStart: o, valueAxisDim: l, baseAxisDim: s, stacked: !!i, valueDim: u, baseDim: h, baseDataOffset: c, stackedOverDimension: e.getCalculationInfo("stackedOverDimension") } }

    function kd(t, e) { var n = 0,
            i = t.scale.getExtent(); return "start" === e ? n = i[0] : "end" === e ? n = i[1] : i[0] > 0 ? n = i[0] : i[1] < 0 && (n = i[1]), n }

    function Pd(t, e, n, i) { var r = 0 / 0;
        t.stacked && (r = n.get(n.getCalculationInfo("stackedOverDimension"), i)), isNaN(r) && (r = t.valueStart); var a = t.baseDataOffset,
            o = []; return o[a] = n.get(t.baseDim, i), o[1 - a] = r, e.dataToPoint(o) }

    function Ld(t, e) { var n = []; return e.diff(t).add(function(t) { n.push({ cmd: "+", idx: t }) }).update(function(t, e) { n.push({ cmd: "=", idx: e, idx1: t }) }).remove(function(t) { n.push({ cmd: "-", idx: t }) }).execute(), n }

    function Od(t) { return isNaN(t[0]) || isNaN(t[1]) }

    function zd(t, e, n, i, r, a, o, s, l, u) { return "none" !== u && u ? Ed.apply(this, arguments) : Rd.apply(this, arguments) }

    function Ed(t, e, n, i, r, a, o, s, l, u, h) { for (var c = 0, d = n, f = 0; i > f; f++) { var p = e[d]; if (d >= r || 0 > d) break; if (Od(p)) { if (h) { d += a; continue } break } if (d === n) t[a > 0 ? "moveTo" : "lineTo"](p[0], p[1]);
            else if (l > 0) { var g = e[c],
                    v = "y" === u ? 1 : 0,
                    m = (p[v] - g[v]) * l;
                MA(IA, g), IA[v] = g[v] + m, MA(TA, p), TA[v] = p[v] - m, t.bezierCurveTo(IA[0], IA[1], TA[0], TA[1], p[0], p[1]) } else t.lineTo(p[0], p[1]);
            c = d, d += a } return f }

    function Rd(t, e, n, i, r, a, o, s, l, u, h) { for (var c = 0, d = n, f = 0; i > f; f++) { var p = e[d]; if (d >= r || 0 > d) break; if (Od(p)) { if (h) { d += a; continue } break } if (d === n) t[a > 0 ? "moveTo" : "lineTo"](p[0], p[1]), MA(IA, p);
            else if (l > 0) { var g = d + a,
                    v = e[g]; if (h)
                    for (; v && Od(e[g]);) g += a, v = e[g]; var m = .5,
                    y = e[c],
                    v = e[g]; if (!v || Od(v)) MA(TA, p);
                else { Od(v) && !h && (v = p), Y(SA, v, y); var x, _; if ("x" === u || "y" === u) { var b = "x" === u ? 0 : 1;
                        x = Math.abs(p[b] - y[b]), _ = Math.abs(p[b] - v[b]) } else x = Gx(p, y), _ = Gx(p, v);
                    m = _ / (_ + x), wA(TA, p, SA, -l * (1 - m)) }
                _A(IA, IA, s), bA(IA, IA, o), _A(TA, TA, s), bA(TA, TA, o), t.bezierCurveTo(IA[0], IA[1], TA[0], TA[1], p[0], p[1]), wA(IA, p, SA, l * m) } else t.lineTo(p[0], p[1]);
            c = d, d += a } return f }

    function Bd(t, e) { var n = [1 / 0, 1 / 0],
            i = [-1 / 0, -1 / 0]; if (e)
            for (var r = 0; r < t.length; r++) { var a = t[r];
                a[0] < n[0] && (n[0] = a[0]), a[1] < n[1] && (n[1] = a[1]), a[0] > i[0] && (i[0] = a[0]), a[1] > i[1] && (i[1] = a[1]) }
        return { min: e ? n : i, max: e ? i : n } }

    function Nd(t, e) { if (t.length === e.length) { for (var n = 0; n < t.length; n++) { var i = t[n],
                    r = e[n]; if (i[0] !== r[0] || i[1] !== r[1]) return } return !0 } }

    function Vd(t) { return "number" == typeof t ? t : t ? .5 : 0 }

    function Fd(t, e, n) { if (!n.valueDim) return []; for (var i = [], r = 0, a = e.count(); a > r; r++) i.push(Pd(n, t, e, r)); return i }

    function Hd(t, e, n) { for (var i = e.getBaseAxis(), r = "x" === i.dim || "radius" === i.dim ? 0 : 1, a = [], o = 0; o < t.length - 1; o++) { var s = t[o + 1],
                l = t[o];
            a.push(l); var u = []; switch (n) {
                case "end":
                    u[r] = s[r], u[1 - r] = l[1 - r], a.push(u); break;
                case "middle":
                    var h = (l[r] + s[r]) / 2,
                        c = [];
                    u[r] = c[r] = h, u[1 - r] = l[1 - r], c[1 - r] = s[1 - r], a.push(u), a.push(c); break;
                default:
                    u[r] = l[r], u[1 - r] = s[1 - r], a.push(u) } } return t[o] && a.push(t[o]), a }

    function Gd(t, e) { var n = t.getVisual("visualMeta"); if (n && n.length && t.count() && "cartesian2d" === e.type) { for (var i, r, a = n.length - 1; a >= 0; a--) { var o = n[a].dimension,
                    s = t.dimensions[o],
                    l = t.getDimensionInfo(s); if (i = l && l.coordDim, "x" === i || "y" === i) { r = n[a]; break } } if (r) { var u = e.getAxis(i),
                    h = p(r.stops, function(t) { return { coord: u.toGlobalCoord(u.dataToCoord(t.value)), color: t.color } }),
                    c = h.length,
                    d = r.outerColors.slice();
                c && h[0].coord > h[c - 1].coord && (h.reverse(), d.reverse()); var g = 10,
                    v = h[0].coord - g,
                    m = h[c - 1].coord + g,
                    y = m - v; if (.001 > y) return "transparent";
                f(h, function(t) { t.offset = (t.coord - v) / y }), h.push({ offset: c ? h[c - 1].offset : .5, color: d[1] || "transparent" }), h.unshift({ offset: c ? h[0].offset : .5, color: d[0] || "transparent" }); var x = new xM(0, 0, 0, 0, h, !0); return x[i] = v, x[i + "2"] = m, x } } }

    function Wd(t, e, n) { var i = t.get("showAllSymbol"),
            r = "auto" === i; if (!i || r) { var a = n.getAxesByScale("ordinal")[0]; if (a && (!r || !Zd(a, e))) { var o = e.mapDimension(a.dim),
                    s = {}; return f(a.getViewLabels(), function(t) { s[t.tickValue] = 1 }),
                    function(t) { return !s.hasOwnProperty(e.get(o, t)) } } } }

    function Zd(t, e) { var n = t.getExtent(),
            i = Math.abs(n[1] - n[0]) / t.scale.count();
        isNaN(i) && (i = 0); for (var r = e.count(), a = Math.max(1, Math.round(r / 5)), o = 0; r > o; o += a)
            if (1.5 * bd.getSymbolSize(e, o)[t.isHorizontal() ? 1 : 0] > i) return !1;
        return !0 }

    function Ud(t, e, n) { if ("cartesian2d" === t.type) { var i = t.getBaseAxis().isHorizontal(),
                r = Ec(t, e, n); if (!n.get("clip", !0)) { var a = r.shape,
                    o = Math.max(a.width, a.height);
                i ? (a.y -= o, a.height += 2 * o) : (a.x -= o, a.width += 2 * o) } return r } return Rc(t, e, n) }

    function Xd(t, e) { this.getAllNames = function() { var t = e(); return t.mapArray(t.getName) }, this.containName = function(t) { var n = e(); return n.indexOfName(t) >= 0 }, this.indexOfName = function(e) { var n = t(); return n.indexOfName(e) }, this.getItemVisual = function(e, n) { var i = t(); return i.getItemVisual(e, n) } }

    function Yd(t, e, n, i) { var r = e.getData(),
            a = this.dataIndex,
            o = r.getName(a),
            s = e.get("selectedOffset");
        i.dispatchAction({ type: "pieToggleSelect", from: t, name: o, seriesId: e.id }), r.each(function(t) { jd(r.getItemGraphicEl(t), r.getItemLayout(t), e.isSelected(r.getName(t)), s, n) }) }

    function jd(t, e, n, i, r) { var a = (e.startAngle + e.endAngle) / 2,
            o = Math.cos(a),
            s = Math.sin(a),
            l = n ? i : 0,
            u = [o * l, s * l];
        r ? t.animate().when(200, { position: u }).start("bounceOut") : t.attr("position", u) }

    function qd(t, e) { N_.call(this); var n = new iM({ z2: 2 }),
            i = new lM,
            r = new Jw;
        this.add(n), this.add(i), this.add(r), this.updateData(t, e, !0) }

    function Kd(t, e, n, i, r, a, o, s, l, u) {
        function h(e, n, i) { for (var r = e; n > r && !(t[r].y + i > l + o); r++)
                if (t[r].y += i, r > e && n > r + 1 && t[r + 1].y > t[r].y + t[r].height) return void c(r, i / 2);
            c(n - 1, i / 2) }

        function c(e, n) { for (var i = e; i >= 0 && !(t[i].y - n < l) && (t[i].y -= n, !(i > 0 && t[i].y > t[i - 1].y + t[i - 1].height)); i--); }

        function d(t, e, n, i, r, a) { for (var o = a > 0 ? e ? Number.MAX_VALUE : 0 : e ? Number.MAX_VALUE : 0, s = 0, l = t.length; l > s; s++)
                if ("none" === t[s].labelAlignTo) { var u = Math.abs(t[s].y - i),
                        h = t[s].len,
                        c = t[s].len2,
                        d = r + h > u ? Math.sqrt((r + h + c) * (r + h + c) - u * u) : Math.abs(t[s].x - n);
                    e && d >= o && (d = o - 10), !e && o >= d && (d = o + 10), t[s].x = n + d * a, o = d } }
        t.sort(function(t, e) { return t.y - e.y }); for (var f, p = 0, g = t.length, v = [], m = [], y = 0; g > y; y++) { if ("outer" === t[y].position && "labelLine" === t[y].labelAlignTo) { var x = t[y].x - u;
                t[y].linePoints[1][0] += x, t[y].x = u }
            f = t[y].y - p, 0 > f && h(y, g, -f, r), p = t[y].y + t[y].height }
        0 > o - p && c(g - 1, p - o); for (var y = 0; g > y; y++) t[y].y >= n ? m.push(t[y]) : v.push(t[y]);
        d(v, !1, e, n, i, r), d(m, !0, e, n, i, r) }

    function $d(t, e, n, i, r, a, o, s) { for (var l = [], u = [], h = Number.MAX_VALUE, c = -Number.MAX_VALUE, d = 0; d < t.length; d++) Qd(t[d]) || (t[d].x < e ? (h = Math.min(h, t[d].x), l.push(t[d])) : (c = Math.max(c, t[d].x), u.push(t[d])));
        Kd(u, e, n, i, 1, r, a, o, s, c), Kd(l, e, n, i, -1, r, a, o, s, h); for (var d = 0; d < t.length; d++) { var f = t[d]; if (!Qd(f)) { var p = f.linePoints; if (p) { var g, v = "edge" === f.labelAlignTo,
                        m = f.textRect.width;
                    g = v ? f.x < e ? p[2][0] - f.labelDistance - o - f.labelMargin : o + r - f.labelMargin - p[2][0] - f.labelDistance : f.x < e ? f.x - o - f.bleedMargin : o + r - f.x - f.bleedMargin, g < f.textRect.width && (f.text = Jn(f.text, g, f.font), "edge" === f.labelAlignTo && (m = Xn(f.text, f.font))); var y = p[1][0] - p[2][0];
                    v ? p[2][0] = f.x < e ? o + f.labelMargin + m + f.labelDistance : o + r - f.labelMargin - m - f.labelDistance : (p[2][0] = f.x < e ? f.x + f.labelDistance : f.x - f.labelDistance, p[1][0] = p[2][0] + y), p[1][1] = p[2][1] = f.y } } } }

    function Qd(t) { return "center" === t.position }

    function Jd(t, e) { return Qo(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }) }

    function tf(t) { return "_EC_" + t }

    function ef(t, e) { this.id = null == t ? "" : t, this.inEdges = [], this.outEdges = [], this.edges = [], this.hostGraph, this.dataIndex = null == e ? -1 : e }

    function nf(t, e, n) { this.node1 = t, this.node2 = e, this.dataIndex = null == n ? -1 : n }

    function rf(t) { var e = t.mainData,
            n = t.datas;
        n || (n = { main: e }, t.datasAttr = { main: "data" }), t.datas = t.mainData = null, hf(e, n, t), qA(n, function(n) { qA(e.TRANSFERABLE_METHODS, function(e) { n.wrapMethod(e, x(af, t)) }) }), e.wrapMethod("cloneShallow", x(sf, t)), qA(e.CHANGABLE_METHODS, function(n) { e.wrapMethod(n, x(of, t)) }), O(n[e.dataType] === e) }

    function af(t, e) { if (uf(this)) { var n = o({}, this[KA]);
            n[this.dataType] = e, hf(e, n, t) } else cf(e, this.dataType, this[$A], t); return e }

    function of(t, e) { return t.struct && t.struct.update(this), e }

    function sf(t, e) { return qA(e[KA], function(n, i) { n !== e && cf(n.cloneShallow(), i, e, t) }), e }

    function lf(t) { var e = this[$A]; return null == t || null == e ? e : e[KA][t] }

    function uf(t) { return t[$A] === t }

    function hf(t, e, n) { t[KA] = {}, qA(e, function(e, i) { cf(e, i, t, n) }) }

    function cf(t, e, n, i) { n[KA][e] = t, t[$A] = n, t.dataType = e, i.struct && (t[i.structAttr] = i.struct, i.struct[i.datasAttr[e]] = t), t.getLinkedData = lf }

    function df(t) { return isNaN(+t.cpx1) || isNaN(+t.cpy1) }

    function ff(t) { return "_" + t + "Type" }

    function pf(t, e, n) { var i = e.getItemVisual(n, "color"),
            r = e.getItemVisual(n, t),
            a = e.getItemVisual(n, t + "Size"); if (r && "none" !== r) { _(a) || (a = [a, a]); var o = $h(r, -a[0] / 2, -a[1] / 2, a[0], a[1], i); return o.name = t, o } }

    function gf(t) { var e = new nD({ name: "line", subPixelOptimize: !0 }); return vf(e.shape, t), e }

    function vf(t, e) { t.x1 = e[0][0], t.y1 = e[0][1], t.x2 = e[1][0], t.y2 = e[1][1], t.percent = 1; var n = e[2];
        n ? (t.cpx1 = n[0], t.cpy1 = n[1]) : (t.cpx1 = 0 / 0, t.cpy1 = 0 / 0) }

    function mf() { var t = this,
            e = t.childOfName("fromSymbol"),
            n = t.childOfName("toSymbol"),
            i = t.childOfName("label"); if (e || n || !i.ignore) { for (var r = 1, a = this.parent; a;) a.scale && (r /= a.scale[0]), a = a.parent; var o = t.childOfName("line"); if (this.__dirty || o.__dirty) { var s = o.shape.percent,
                    l = o.pointAt(0),
                    u = o.pointAt(s),
                    h = Y([], u, l); if (te(h, h), e) { e.attr("position", l); var c = o.tangentAt(0);
                    e.attr("rotation", Math.PI / 2 - Math.atan2(c[1], c[0])), e.attr("scale", [r * s, r * s]) } if (n) { n.attr("position", u); var c = o.tangentAt(1);
                    n.attr("rotation", -Math.PI / 2 - Math.atan2(c[1], c[0])), n.attr("scale", [r * s, r * s]) } if (!i.ignore) { i.attr("position", u); var d, f, p, g, v = i.__labelDistance,
                        m = v[0] * r,
                        y = v[1] * r,
                        x = s / 2,
                        c = o.tangentAt(x),
                        _ = [c[1], -c[0]],
                        b = o.pointAt(x);
                    _[1] > 0 && (_[0] = -_[0], _[1] = -_[1]); var w = c[0] < 0 ? -1 : 1; if ("start" !== i.__position && "end" !== i.__position) { var M = -Math.atan2(c[1], c[0]);
                        u[0] < l[0] && (M = Math.PI + M), i.attr("rotation", M) } var S; switch (i.__position) {
                        case "insideStartTop":
                        case "insideMiddleTop":
                        case "insideEndTop":
                        case "middle":
                            S = -y, p = "bottom"; break;
                        case "insideStartBottom":
                        case "insideMiddleBottom":
                        case "insideEndBottom":
                            S = y, p = "top"; break;
                        default:
                            S = 0, p = "middle" } switch (i.__position) {
                        case "end":
                            d = [h[0] * m + u[0], h[1] * y + u[1]], f = h[0] > .8 ? "left" : h[0] < -.8 ? "right" : "center", p = h[1] > .8 ? "top" : h[1] < -.8 ? "bottom" : "middle"; break;
                        case "start":
                            d = [-h[0] * m + l[0], -h[1] * y + l[1]], f = h[0] > .8 ? "right" : h[0] < -.8 ? "left" : "center", p = h[1] > .8 ? "bottom" : h[1] < -.8 ? "top" : "middle"; break;
                        case "insideStartTop":
                        case "insideStart":
                        case "insideStartBottom":
                            d = [m * w + l[0], l[1] + S], f = c[0] < 0 ? "right" : "left", g = [-m * w, -S]; break;
                        case "insideMiddleTop":
                        case "insideMiddle":
                        case "insideMiddleBottom":
                        case "middle":
                            d = [b[0], b[1] + S], f = "center", g = [0, -S]; break;
                        case "insideEndTop":
                        case "insideEnd":
                        case "insideEndBottom":
                            d = [-m * w + u[0], u[1] + S], f = c[0] >= 0 ? "right" : "left", g = [m * w, -S] }
                    i.attr({ style: { textVerticalAlign: i.__verticalAlign || p, textAlign: i.__textAlign || f }, position: d, scale: [r, r], origin: g }) } } } }

    function yf(t, e, n) { N_.call(this), this._createLine(t, e, n) }

    function xf(t) { this._ctor = t || yf, this.group = new N_ }

    function _f(t, e, n, i) { var r = e.getItemLayout(n); if (Sf(r)) { var a = new t._ctor(e, n, i);
            e.setItemGraphicEl(n, a), t.group.add(a) } }

    function bf(t, e, n, i, r, a) { var o = e.getItemGraphicEl(i); return Sf(n.getItemLayout(r)) ? (o ? o.updateData(n, r, a) : o = new t._ctor(n, r, a), n.setItemGraphicEl(r, o), void t.group.add(o)) : void t.group.remove(o) }

    function wf(t) { var e = t.hostModel; return { lineStyle: e.getModel("lineStyle").getLineStyle(), hoverLineStyle: e.getModel("emphasis.lineStyle").getLineStyle(), labelModel: e.getModel("label"), hoverLabelModel: e.getModel("emphasis.label") } }

    function Mf(t) { return isNaN(t[0]) || isNaN(t[1]) }

    function Sf(t) { return !Mf(t[0]) && !Mf(t[1]) }

    function If(t, e, n) { var i = Af(t);
        i[e] = n }

    function Tf(t, e, n) { var i = Af(t),
            r = i[e];
        r === n && (i[e] = null) }

    function Cf(t, e) { return !!Af(t)[e] }

    function Af(t) { return t[oD] || (t[oD] = {}) }

    function Df(t) { this.pointerChecker, this._zr = t, this._opt = {}; var e = y,
            n = e(kf, this),
            r = e(Pf, this),
            a = e(Lf, this),
            o = e(Of, this),
            l = e(zf, this);
        Xx.call(this), this.setPointerChecker = function(t) { this.pointerChecker = t }, this.enable = function(e, u) { this.disable(), this._opt = s(i(u) || {}, { zoomOnMouseWheel: !0, moveOnMouseMove: !0, moveOnMouseWheel: !1, preventDefaultMouseMove: !0 }), null == e && (e = !0), (e === !0 || "move" === e || "pan" === e) && (t.on("mousedown", n), t.on("mousemove", r), t.on("mouseup", a)), (e === !0 || "scale" === e || "zoom" === e) && (t.on("mousewheel", o), t.on("pinch", l)) }, this.disable = function() { t.off("mousedown", n), t.off("mousemove", r), t.off("mouseup", a), t.off("mousewheel", o), t.off("pinch", l) }, this.dispose = this.disable, this.isDragging = function() { return this._dragging }, this.isPinching = function() { return this._pinching } }

    function kf(t) { if (!(Ie(t) || t.target && t.target.draggable)) { var e = t.offsetX,
                n = t.offsetY;
            this.pointerChecker && this.pointerChecker(t, e, n) && (this._x = e, this._y = n, this._dragging = !0) } }

    function Pf(t) { if (this._dragging && Bf("moveOnMouseMove", t, this._opt) && "pinch" !== t.gestureEvent && !Cf(this._zr, "globalPan")) { var e = t.offsetX,
                n = t.offsetY,
                i = this._x,
                r = this._y,
                a = e - i,
                o = n - r;
            this._x = e, this._y = n, this._opt.preventDefaultMouseMove && Jx(t.event), Rf(this, "pan", "moveOnMouseMove", t, { dx: a, dy: o, oldX: i, oldY: r, newX: e, newY: n }) } }

    function Lf(t) { Ie(t) || (this._dragging = !1) }

    function Of(t) { var e = Bf("zoomOnMouseWheel", t, this._opt),
            n = Bf("moveOnMouseWheel", t, this._opt),
            i = t.wheelDelta,
            r = Math.abs(i),
            a = t.offsetX,
            o = t.offsetY; if (0 !== i && (e || n)) { if (e) { var s = r > 3 ? 1.4 : r > 1 ? 1.2 : 1.1,
                    l = i > 0 ? s : 1 / s;
                Ef(this, "zoom", "zoomOnMouseWheel", t, { scale: l, originX: a, originY: o }) } if (n) { var u = Math.abs(i),
                    h = (i > 0 ? 1 : -1) * (u > 3 ? .4 : u > 1 ? .15 : .05);
                Ef(this, "scrollMove", "moveOnMouseWheel", t, { scrollDelta: h, originX: a, originY: o }) } } }

    function zf(t) { if (!Cf(this._zr, "globalPan")) { var e = t.pinchScale > 1 ? 1.1 : 1 / 1.1;
            Ef(this, "zoom", null, t, { scale: e, originX: t.pinchX, originY: t.pinchY }) } }

    function Ef(t, e, n, i, r) { t.pointerChecker && t.pointerChecker(i, r.originX, r.originY) && (Jx(i.event), Rf(t, e, n, i, r)) }

    function Rf(t, e, n, i, r) { r.isAvailableBehavior = y(Bf, null, n, i), t.trigger(e, r) }

    function Bf(t, e, n) { var i = n[t]; return !t || i && (!w(i) || e.event[i + "Key"]) }

    function Nf(t, e, n) { var i = t.target,
            r = i.position;
        r[0] += e, r[1] += n, i.dirty() }

    function Vf(t, e, n, i) { var r = t.target,
            a = t.zoomLimit,
            o = r.position,
            s = r.scale,
            l = t.zoom = t.zoom || 1; if (l *= e, a) { var u = a.min || 0,
                h = a.max || 1 / 0;
            l = Math.max(Math.min(h, l), u) } var c = l / t.zoom;
        t.zoom = l, o[0] -= (n - o[0]) * (c - 1), o[1] -= (i - o[1]) * (c - 1), s[0] *= c, s[1] *= c, r.dirty() }

    function Ff(t, e, n) { var i = e.getComponentByElement(t.topTarget),
            r = i && i.coordinateSystem; return i && i !== n && !sD[i.mainType] && r && r.model !== n }

    function Hf(t) { var e = t.coordinateSystem; if ("view" !== e.type) return 1; var n = t.option.nodeScaleRatio,
            i = e.scale,
            r = i && i[0] || 1,
            a = e.getZoom(),
            o = (a - 1) * n + 1; return o / r }

    function Gf(t) { var e = t.getVisual("symbolSize"); return e instanceof Array && (e = (e[0] + e[1]) / 2), +e }

    function Wf(t, e, n) { for (var i, r = t[0], a = t[1], o = t[2], s = 1 / 0, l = n * n, u = .1, h = .1; .9 >= h; h += .1) { lD[0] = cD(r[0], a[0], o[0], h), lD[1] = cD(r[1], a[1], o[1], h); var c = fD(dD(lD, e) - l);
            s > c && (s = c, i = h) } for (var d = 0; 32 > d; d++) { var f = i + u;
            uD[0] = cD(r[0], a[0], o[0], i), uD[1] = cD(r[1], a[1], o[1], i), hD[0] = cD(r[0], a[0], o[0], f), hD[1] = cD(r[1], a[1], o[1], f); var c = dD(uD, e) - l; if (fD(c) < .01) break; var p = dD(hD, e) - l;
            u /= 2, 0 > c ? p >= 0 ? i += u : i -= u : p >= 0 ? i -= u : i += u } return i }

    function Zf(t, e) { var n = t.getVisual("opacity"); return null != n ? n : t.getModel().get(e) }

    function Uf(t, e, n) { var i = t.getGraphicEl(),
            r = Zf(t, e);
        null != n && (null == r && (r = 1), r *= n), i.downplay && i.downplay(), i.traverse(function(t) { if (!t.isGroup) { var e = t.lineLabelOriginalOpacity;
                (null == e || null != n) && (e = r), t.setStyle("opacity", e) } }) }

    function Xf(t, e) { var n = Zf(t, e),
            i = t.getGraphicEl();
        i.traverse(function(t) {!t.isGroup && t.setStyle("opacity", n) }), i.highlight && i.highlight() }

    function Yf(t, e, n) { var i = t.getZoom(),
            r = t.getCenter(),
            a = e.zoom,
            o = t.dataToPoint(r); if (null != e.dx && null != e.dy) { o[0] -= e.dx, o[1] -= e.dy; var r = t.pointToData(o);
            t.setCenter(r) } if (null != a) { if (n) { var s = n.min || 0,
                    l = n.max || 1 / 0;
                a = Math.max(Math.min(i * a, l), s) / i }
            t.scale[0] *= a, t.scale[1] *= a; var u = t.position,
                h = (e.originX - u[0]) * (a - 1),
                c = (e.originY - u[1]) * (a - 1);
            u[0] -= h, u[1] -= c, t.updateTransform(); var r = t.pointToData(o);
            t.setCenter(r), t.setZoom(a * i) } return { center: t.getCenter(), zoom: t.getZoom() } }

    function jf(t) { return t instanceof Array || (t = [t, t]), t }

    function qf(t) { var e = t.coordinateSystem; if (!e || "view" === e.type) { var n = t.getGraph();
            n.eachNode(function(t) { var e = t.getModel();
                t.setLayout([+e.get("x"), +e.get("y")]) }), Kf(n) } }

    function Kf(t) { t.eachEdge(function(t) { var e = t.getModel().get("lineStyle.curveness") || 0,
                n = W(t.node1.getLayout()),
                i = W(t.node2.getLayout()),
                r = [n, i]; + e && r.push([(n[0] + i[0]) / 2 - (n[1] - i[1]) * e, (n[1] + i[1]) / 2 - (i[0] - n[0]) * e]), t.setLayout(r) }) }

    function $f(t, e) { var n = t.coordinateSystem; if (!n || "view" === n.type) { var i = n.getBoundingRect(),
                r = t.getData(),
                a = r.graph,
                o = i.width / 2 + i.x,
                s = i.height / 2 + i.y,
                l = Math.min(i.width, i.height) / 2,
                u = r.count();
            r.setLayout({ cx: o, cy: s }), u && (TD[e](t, n, a, r, l, o, s, u), a.eachEdge(function(t) { var e, n = t.getModel().get("lineStyle.curveness") || 0,
                    i = W(t.node1.getLayout()),
                    r = W(t.node2.getLayout()),
                    a = (i[0] + r[0]) / 2,
                    l = (i[1] + r[1]) / 2; + n && (n *= 3, e = [o * n + a * (1 - n), s * n + l * (1 - n)]), t.setLayout([i, r, e]) })) } }

    function Qf(t, e, n) { for (var i = n.rect, r = i.width, a = i.height, o = [i.x + r / 2, i.y + a / 2], s = null == n.gravity ? .1 : n.gravity, l = 0; l < t.length; l++) { var u = t[l];
            u.p || (u.p = H(r * (Math.random() - .5) + o[0], a * (Math.random() - .5) + o[1])), u.pp = W(u.p), u.edges = null } var h = null == n.friction ? .6 : n.friction,
            c = h; return { warmUp: function() { c = .8 * h }, setFixed: function(e) { t[e].fixed = !0 }, setUnfixed: function(e) { t[e].fixed = !1 }, step: function(n) { for (var i = [], r = t.length, a = 0; a < e.length; a++) { var l = e[a]; if (!l.ignoreForceLayout) { var u = l.n1,
                            h = l.n2;
                        Y(i, h.p, u.p); var d = j(i) - l.d,
                            f = h.w / (u.w + h.w);
                        isNaN(f) && (f = 0), te(i, i), !u.fixed && AD(u.p, u.p, i, f * d * c), !h.fixed && AD(h.p, h.p, i, -(1 - f) * d * c) } } for (var a = 0; r > a; a++) { var p = t[a];
                    p.fixed || (Y(i, o, p.p), AD(p.p, p.p, i, s * c)) } for (var a = 0; r > a; a++)
                    for (var u = t[a], g = a + 1; r > g; g++) { var h = t[g];
                        Y(i, h.p, u.p); var d = j(i);
                        0 === d && (Z(i, Math.random() - .5, Math.random() - .5), d = 1); var v = (u.rep + h.rep) / d / d;!u.fixed && AD(u.pp, u.pp, i, v), !h.fixed && AD(h.pp, h.pp, i, -v) }
                for (var m = [], a = 0; r > a; a++) { var p = t[a];
                    p.fixed || (Y(m, p.p, p.pp), AD(p.p, p.p, m, c), G(p.pp, p.p)) }
                c = .992 * c, n && n(t, e, .01 > c) } } }

    function Jf() { u_.call(this) }

    function tp(t) { this.name = t, this.zoomLimit, u_.call(this), this._roamTransformable = new Jf, this._rawTransformable = new Jf, this._center, this._zoom }

    function ep(t, e, n, i) { var r = n.seriesModel,
            a = r ? r.coordinateSystem : null; return a === this ? a[t](i) : null }

    function np(t, e, n) { var i = t.getBoxLayoutParams(); return i.aspect = n, Qo(i, { width: e.getWidth(), height: e.getHeight() }) }

    function ip(t, e) { return e = e || [0, 0], p(["x", "y"], function(n, i) { var r = this.getAxis(n),
                a = e[i],
                o = t[i] / 2; return "category" === r.type ? r.getBandWidth() : Math.abs(r.dataToCoord(a - o) - r.dataToCoord(a + o)) }, this) }

    function rp(t, e) { return e = e || [0, 0], p([0, 1], function(n) { var i = e[n],
                r = t[n] / 2,
                a = [],
                o = []; return a[n] = i - r, o[n] = i + r, a[1 - n] = o[1 - n] = e[1 - n], Math.abs(this.dataToPoint(a)[n] - this.dataToPoint(o)[n]) }, this) }

    function ap(t, e) { var n = this.getAxis(),
            i = e instanceof Array ? e[0] : e,
            r = (t instanceof Array ? t[0] : t) / 2; return "category" === n.type ? n.getBandWidth() : Math.abs(n.dataToCoord(i - r) - n.dataToCoord(i + r)) }

    function op(t, e) { return p(["Radius", "Angle"], function(n, i) { var r = this["get" + n + "Axis"](),
                a = e[i],
                o = t[i] / 2,
                s = "dataTo" + n,
                l = "category" === r.type ? r.getBandWidth() : Math.abs(r[s](a - o) - r[s](a + o)); return "Angle" === n && (l = l * Math.PI / 180), l }, this) }

    function sp(t) { var e, n = t.type; if ("path" === n) { var i = t.shape,
                r = null != i.width && null != i.height ? { x: i.x || 0, y: i.y || 0, width: i.width, height: i.height } : null,
                a = bp(i);
            e = ba(a, null, r, i.layout || "center"), e.__customPathData = a } else if ("image" === n) e = new Di({}), e.__customImagePath = t.style.image;
        else if ("text" === n) e = new Jw({}), e.__customText = t.style.text;
        else if ("group" === n) e = new N_;
        else { if ("compoundPath" === n) throw new Error('"compoundPath" is not supported yet.'); var o = _a(n);
            e = new o } return e.__customGraphicType = n, e.name = t.name, e }

    function lp(t, e, n, r, a, o, s) { var l = {},
            u = n.style || {}; if (n.shape && (l.shape = i(n.shape)), n.position && (l.position = n.position.slice()), n.scale && (l.scale = n.scale.slice()), n.origin && (l.origin = n.origin.slice()), n.rotation && (l.rotation = n.rotation), "image" === t.type && n.style) { var h = l.style = {};
            f(["x", "y", "width", "height"], function(e) { up(e, h, u, t.style, o) }) } if ("text" === t.type && n.style) { var h = l.style = {};
            f(["x", "y"], function(e) { up(e, h, u, t.style, o) }), !u.hasOwnProperty("textFill") && u.fill && (u.textFill = u.fill), !u.hasOwnProperty("textStroke") && u.stroke && (u.textStroke = u.stroke) } if ("group" !== t.type && (t.useStyle(u), o)) { t.style.opacity = 0; var c = u.opacity;
            null == c && (c = 1), io(t, { style: { opacity: c } }, r, e) }
        o ? t.attr(l) : no(t, l, r, e), n.hasOwnProperty("z2") && t.attr("z2", n.z2 || 0), n.hasOwnProperty("silent") && t.attr("silent", n.silent), n.hasOwnProperty("invisible") && t.attr("invisible", n.invisible), n.hasOwnProperty("ignore") && t.attr("ignore", n.ignore), n.hasOwnProperty("info") && t.attr("info", n.info); var d = n.styleEmphasis;
        za(t, d), s && Ha(t, d !== !1) }

    function up(t, e, n, i, r) { null == n[t] || r || (e[t] = n[t], n[t] = i[t]) }

    function hp(t, e, n, i) {
        function r(t) { null == t && (t = v), M && (m = e.getItemModel(t), y = m.getModel(FD), x = m.getModel(HD), _ = e.getItemVisual(t, "color"), M = !1) }

        function a(t, n) { return null == n && (n = v), e.get(e.getDimension(t || 0), n) }

        function o(n, i) { null == i && (i = v), r(i); var a = m.getModel(ND).getItemStyle();
            null != _ && (a.fill = _); var o = e.getItemVisual(i, "opacity");
            null != o && (a.opacity = o); var s = n ? yp(n, y) : y; return Xa(a, s, null, { autoColor: _, isRectText: !0 }), a.text = s.getShallow("show") ? D(t.getFormattedLabel(i, "normal"), Lc(e, i)) : null, n && xp(a, n), a }

        function l(n, i) { null == i && (i = v), r(i); var a = m.getModel(VD).getItemStyle(),
                o = n ? yp(n, x) : x; return Xa(a, o, null, { isRectText: !0 }, !0), a.text = o.getShallow("show") ? k(t.getFormattedLabel(i, "emphasis"), t.getFormattedLabel(i, "normal"), Lc(e, i)) : null, n && xp(a, n), a }

        function u(t, n) { return null == n && (n = v), e.getItemVisual(n, t) }

        function h(t) { if (p.getBaseAxis) { var e = p.getBaseAxis(); return Ah(s({ axis: e }, t), i) } }

        function c() { return n.getCurrentSeriesIndices() }

        function d(t) { return to(t, n) } var f = t.get("renderItem"),
            p = t.coordinateSystem,
            g = {};
        p && (g = p.prepareCustoms ? p.prepareCustoms() : WD[p.type](p)); var v, m, y, x, _, b = s({ getWidth: i.getWidth, getHeight: i.getHeight, getZr: i.getZr, getDevicePixelRatio: i.getDevicePixelRatio, value: a, style: o, styleEmphasis: l, visual: u, barLayout: h, currentSeriesIndices: c, font: d }, g.api || {}),
            w = { context: {}, seriesId: t.id, seriesName: t.name, seriesIndex: t.seriesIndex, coordSys: g.coordSys, dataInsideLength: e.count(), encode: cp(t.getData()) },
            M = !0; return function(t, n) { return v = t, M = !0, f && f(s({ dataIndexInside: t, dataIndex: e.getRawIndex(t), actionType: n ? n.type : null }, w), b) } }

    function cp(t) { var e = {}; return f(t.dimensions, function(n, i) { var r = t.getDimensionInfo(n); if (!r.isExtraCoord) { var a = r.coordDim,
                    o = e[a] = e[a] || [];
                o[r.coordDimIndex] = i } }), e }

    function dp(t, e, n, i, r, a) { return t = fp(t, e, n, i, r, a, !0), t && a.setItemGraphicEl(e, t), t }

    function fp(t, e, n, i, r, a, o) { var s = !n;
        n = n || {}; var l = n.type,
            u = n.shape,
            h = n.style; if (t && (s || null != l && l !== t.__customGraphicType || "path" === l && wp(u) && bp(u) !== t.__customPathData || "image" === l && Mp(h, "image") && h.image !== t.__customImagePath || "text" === l && Mp(u, "text") && h.text !== t.__customText) && (r.remove(t), t = null), !s) { var c = !t; return !t && (t = sp(n)), lp(t, e, n, i, a, c, o), "group" === l && pp(t, e, n, i, a), r.add(t), t } }

    function pp(t, e, n, i, r) { var a = n.children,
            o = a ? a.length : 0,
            s = n.$mergeChildren,
            l = "byName" === s || n.diffChildrenByName,
            u = s === !1; if (o || l || u) { if (l) return void gp({ oldChildren: t.children() || [], newChildren: a || [], dataIndex: e, animatableModel: i, group: t, data: r });
            u && t.removeAll(); for (var h = 0; o > h; h++) a[h] && fp(t.childAt(h), e, a[h], i, t, r) } }

    function gp(t) { new Fu(t.oldChildren, t.newChildren, vp, vp, t).add(mp).update(mp).remove(_p).execute() }

    function vp(t, e) { var n = t && t.name; return null != n ? n : GD + e }

    function mp(t, e) { var n = this.context,
            i = null != t ? n.newChildren[t] : null,
            r = null != e ? n.oldChildren[e] : null;
        fp(r, n.dataIndex, i, n.animatableModel, n.group, n.data) }

    function yp(t, e) { var n = new vo({}, e); return f(BD, function(e, i) { t.hasOwnProperty(e) && (n.option[i] = t[e]) }), n }

    function xp(t, e) { for (var n in e)(e.hasOwnProperty(n) || !BD.hasOwnProperty(n)) && (t[n] = e[n]) }

    function _p(t) { var e = this.context,
            n = e.oldChildren[t];
        n && e.group.remove(n) }

    function bp(t) { return t && (t.pathData || t.d) }

    function wp(t) { return t && (t.hasOwnProperty("pathData") || t.hasOwnProperty("d")) }

    function Mp(t, e) { return t && t.hasOwnProperty(e) }

    function Sp(t, e, n) { var i, r = {},
            a = "toggleSelected" === t; return n.eachComponent("legend", function(n) { a && null != i ? n[i ? "select" : "unSelect"](e.name) : "allSelect" === t || "inverseSelect" === t ? n[t]() : (n[t](e.name), i = n.isSelected(e.name)); var o = n.getData();
            f(o, function(t) { var e = t.get("name"); if ("\n" !== e && "" !== e) { var i = n.isSelected(e);
                    r[e] = r.hasOwnProperty(e) ? r[e] && i : i } }) }), "allSelect" === t || "inverseSelect" === t ? { selected: r } : { name: e.name, selected: r } }

    function Ip(t, e, n) { var i = e.getBoxLayoutParams(),
            r = e.get("padding"),
            a = { width: n.getWidth(), height: n.getHeight() },
            o = Qo(i, a, r);
        rS(e.get("orient"), t, e.get("itemGap"), o.width, o.height), Jo(t, i, a, r) }

    function Tp(t, e) { var n = jM(e.get("padding")),
            i = e.getItemStyle(["color", "opacity"]);
        i.fill = e.get("backgroundColor"); var t = new cM({ shape: { x: t.x - n[3], y: t.y - n[0], width: t.width + n[1] + n[3], height: t.height + n[0] + n[2], r: e.get("borderRadius") }, style: i, silent: !0, z2: -1 }); return t }

    function Cp(t, e, n, i, r, a) { var o; return "line" !== e && e.indexOf("empty") < 0 ? (o = n.getItemStyle(), t.style.stroke = i, a || (o.stroke = r)) : o = n.getItemStyle(["borderWidth", "borderColor"]), t.setStyle(o) }

    function Ap(t, e, n, i) { kp(t, e, n, i), n.dispatchAction({ type: "legendToggleSelect", name: null != t ? t : e }), Dp(t, e, n, i) }

    function Dp(t, e, n, i) { var r = n.getZr().storage.getDisplayList()[0];
        r && r.useHoverLayer || n.dispatchAction({ type: "highlight", seriesName: t, name: e, excludeSeriesId: i }) }

    function kp(t, e, n, i) { var r = n.getZr().storage.getDisplayList()[0];
        r && r.useHoverLayer || n.dispatchAction({ type: "downplay", seriesName: t, name: e, excludeSeriesId: i }) }

    function Pp(t, e, n) { var i = t.getOrient(),
            r = [1, 1];
        r[i.index] = 0, ts(e, n, { type: "box", ignoreSize: r }) }

    function Lp(t, e, n, i, r) { var a = t.axis; if (!a.scale.isBlank() && a.containData(e)) { if (!t.involveSeries) return void n.showPointer(t, e); var s = Op(e, t),
                l = s.payloadBatch,
                u = s.snapToValue;
            l[0] && null == r.seriesIndex && o(r, l[0]), !i && t.snap && a.containData(u) && null != u && (e = u), n.showPointer(t, e, l, r), n.showTooltip(t, s, u) } }

    function Op(t, e) { var n = e.axis,
            i = n.dim,
            r = t,
            a = [],
            o = Number.MAX_VALUE,
            s = -1; return rk(e.seriesModels, function(e) { var l, u, h = e.getData().mapDimension(i, !0); if (e.getAxisTooltipData) { var c = e.getAxisTooltipData(h, t, n);
                u = c.dataIndices, l = c.nestestValue } else { if (u = e.getData().indicesOfNearest(h[0], t, "category" === n.type ? .5 : null), !u.length) return;
                l = e.getData().get(h[0], u[0]) } if (null != l && isFinite(l)) { var d = t - l,
                    f = Math.abs(d);
                o >= f && ((o > f || d >= 0 && 0 > s) && (o = f, s = d, r = l, a.length = 0), rk(u, function(t) { a.push({ seriesIndex: e.seriesIndex, dataIndexInside: t, dataIndex: e.getData().getRawIndex(t) }) })) } }), { payloadBatch: a, snapToValue: r } }

    function zp(t, e, n, i) { t[e.key] = { value: n, payloadBatch: i } }

    function Ep(t, e, n, i) { var r = n.payloadBatch,
            a = e.axis,
            o = a.model,
            s = e.axisPointerModel; if (e.triggerTooltip && r.length) { var l = e.coordSys.model,
                u = gd(l),
                h = t.map[u];
            h || (h = t.map[u] = { coordSysId: l.id, coordSysIndex: l.componentIndex, coordSysType: l.type, coordSysMainType: l.mainType, dataByAxis: [] }, t.list.push(h)), h.dataByAxis.push({ axisDim: a.dim, axisIndex: o.componentIndex, axisType: o.type, axisId: o.id, value: i, valueLabelOpt: { precision: s.get("label.precision"), formatter: s.get("label.formatter") }, seriesDataIndices: r.slice() }) } }

    function Rp(t, e, n) { var i = n.axesInfo = [];
        rk(e, function(e, n) { var r = e.axisPointerModel.option,
                a = t[n];
            a ? (!e.useHandle && (r.status = "show"), r.value = a.value, r.seriesDataIndices = (a.payloadBatch || []).slice()) : !e.useHandle && (r.status = "hide"), "show" === r.status && i.push({ axisDim: e.axis.dim, axisIndex: e.axis.model.componentIndex, value: r.value }) }) }

    function Bp(t, e, n, i) {
        if (Hp(e) || !t.list.length) return void i({ type: "hideTip" });
        var r = ((t.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
        i({ type: "showTip", escapeConnect: !0, x: e[0], y: e[1], tooltipOption: n.tooltipOption, position: n.position, dataIndexInside: r.dataIndexInside, dataIndex: r.dataIndex, seriesIndex: r.seriesIndex, dataByCoordSys: t.list })
    }

    function Np(t, e, n) { var i = n.getZr(),
            r = "axisPointerLastHighlights",
            a = ok(i)[r] || {},
            o = ok(i)[r] = {};
        rk(t, function(t) { var e = t.axisPointerModel.option; "show" === e.status && rk(e.seriesDataIndices, function(t) { var e = t.seriesIndex + " | " + t.dataIndex;
                o[e] = t }) }); var s = [],
            l = [];
        f(a, function(t, e) {!o[e] && l.push(t) }), f(o, function(t, e) {!a[e] && s.push(t) }), l.length && n.dispatchAction({ type: "downplay", escapeConnect: !0, batch: l }), s.length && n.dispatchAction({ type: "highlight", escapeConnect: !0, batch: s }) }

    function Vp(t, e) { for (var n = 0; n < (t || []).length; n++) { var i = t[n]; if (e.axis.dim === i.axisDim && e.axis.model.componentIndex === i.axisIndex) return i } }

    function Fp(t) { var e = t.axis.model,
            n = {},
            i = n.axisDim = t.axis.dim; return n.axisIndex = n[i + "AxisIndex"] = e.componentIndex, n.axisName = n[i + "AxisName"] = e.name, n.axisId = n[i + "AxisId"] = e.id, n }

    function Hp(t) { return !t || null == t[0] || isNaN(t[0]) || null == t[1] || isNaN(t[1]) }

    function Gp(t, e, n) { if (!Sx.node) { var i = e.getZr();
            lk(i).records || (lk(i).records = {}), Wp(i, e); var r = lk(i).records[t] || (lk(i).records[t] = {});
            r.handler = n } }

    function Wp(t, e) {
        function n(n, i) { t.on(n, function(n) { var r = Yp(e);
                uk(lk(t).records, function(t) { t && i(t, n, r.dispatchAction) }), Zp(r.pendings, e) }) }
        lk(t).initialized || (lk(t).initialized = !0, n("click", x(Xp, "click")), n("mousemove", x(Xp, "mousemove")), n("globalout", Up)) }

    function Zp(t, e) { var n, i = t.showTip.length,
            r = t.hideTip.length;
        i ? n = t.showTip[i - 1] : r && (n = t.hideTip[r - 1]), n && (n.dispatchAction = null, e.dispatchAction(n)) }

    function Up(t, e, n) { t.handler("leave", null, n) }

    function Xp(t, e, n, i) { e.handler(t, n, i) }

    function Yp(t) { var e = { showTip: [], hideTip: [] },
            n = function(i) { var r = e[i.type];
                r ? r.push(i) : (i.dispatchAction = n, t.dispatchAction(i)) }; return { dispatchAction: n, pendings: e } }

    function jp(t, e) { if (!Sx.node) { var n = e.getZr(),
                i = (lk(n).records || {})[t];
            i && (lk(n).records[t] = null) } }

    function qp() {}

    function Kp(t, e, n, i) { $p(ck(n).lastProp, i) || (ck(n).lastProp = i, e ? no(n, i, t) : (n.stopAnimation(), n.attr(i))) }

    function $p(t, e) { if (M(t) && M(e)) { var n = !0; return f(e, function(e, i) { n = n && $p(t[i], e) }), !!n } return t === e }

    function Qp(t, e) { t[e.get("label.show") ? "show" : "hide"]() }

    function Jp(t) { return { position: t.position.slice(), rotation: t.rotation || 0 } }

    function tg(t, e, n) { var i = e.get("z"),
            r = e.get("zlevel");
        t && t.traverse(function(t) { "group" !== t.type && (null != i && (t.z = i), null != r && (t.zlevel = r), t.silent = n) }) }

    function eg(t) { var e, n = t.get("type"),
            i = t.getModel(n + "Style"); return "line" === n ? (e = i.getLineStyle(), e.fill = null) : "shadow" === n && (e = i.getAreaStyle(), e.stroke = null), e }

    function ng(t, e, n, i, r) { var a = n.get("value"),
            o = rg(a, e.axis, e.ecModel, n.get("seriesDataIndices"), { precision: n.get("label.precision"), formatter: n.get("label.formatter") }),
            s = n.getModel("label"),
            l = jM(s.get("padding") || 0),
            u = s.getFont(),
            h = Yn(o, u),
            c = r.position,
            d = h.width + l[1] + l[3],
            f = h.height + l[0] + l[2],
            p = r.align; "right" === p && (c[0] -= d), "center" === p && (c[0] -= d / 2); var g = r.verticalAlign; "bottom" === g && (c[1] -= f), "middle" === g && (c[1] -= f / 2), ig(c, d, f, i); var v = s.get("backgroundColor");
        v && "auto" !== v || (v = e.get("axisLine.lineStyle.color")), t.label = { shape: { x: 0, y: 0, width: d, height: f, r: s.get("borderRadius") }, position: c.slice(), style: { text: o, textFont: u, textFill: s.getTextColor(), textPosition: "inside", textPadding: l, fill: v, stroke: s.get("borderColor") || "transparent", lineWidth: s.get("borderWidth") || 0, shadowBlur: s.get("shadowBlur"), shadowColor: s.get("shadowColor"), shadowOffsetX: s.get("shadowOffsetX"), shadowOffsetY: s.get("shadowOffsetY") }, z2: 10 } }

    function ig(t, e, n, i) { var r = i.getWidth(),
            a = i.getHeight();
        t[0] = Math.min(t[0] + e, r) - e, t[1] = Math.min(t[1] + n, a) - n, t[0] = Math.max(t[0], 0), t[1] = Math.max(t[1], 0) }

    function rg(t, e, n, i, r) { t = e.scale.parse(t); var a = e.scale.getLabel(t, { precision: r.precision }),
            o = r.formatter; if (o) { var s = { value: Uh(e, t), axisDimension: e.dim, axisIndex: e.index, seriesData: [] };
            f(i, function(t) { var e = n.getSeriesByIndex(t.seriesIndex),
                    i = t.dataIndexInside,
                    r = e && e.getDataParams(i);
                r && s.seriesData.push(r) }), w(o) ? a = o.replace("{value}", a) : b(o) && (a = o(s)) } return a }

    function ag(t, e, n) { var i = Oe(); return Ne(i, i, n.rotation), Be(i, i, n.position), ao([t.dataToCoord(e), (n.labelOffset || 0) + (n.labelDirection || 1) * (n.labelMargin || 0)], i) }

    function og(t, e, n, i, r, a) { var o = tA.innerTextLayout(n.rotation, 0, n.labelDirection);
        n.labelMargin = r.get("label.margin"), ng(e, i, r, a, { position: ag(i.axis, t, n), align: o.textAlign, verticalAlign: o.textVerticalAlign }) }

    function sg(t, e, n) { return n = n || 0, { x1: t[n], y1: t[1 - n], x2: e[n], y2: e[1 - n] } }

    function lg(t, e, n) { return n = n || 0, { x: t[n], y: t[1 - n], width: e[n], height: e[1 - n] } }

    function ug(t, e) { var n = {}; return n[e.dim + "AxisIndex"] = e.index, t.getCartesian(n) }

    function hg(t) { return "x" === t.dim ? 0 : 1 }

    function cg(t) { var e = "cubic-bezier(0.23, 1, 0.32, 1)",
            n = "left " + t + "s " + e + ",top " + t + "s " + e; return p(yk, function(t) { return t + "transition:" + n }).join(";") }

    function dg(t) { var e = [],
            n = t.get("fontSize"),
            i = t.getTextColor(); return i && e.push("color:" + i), e.push("font:" + t.getFont()), n && e.push("line-height:" + Math.round(3 * n / 2) + "px"), vk(["decoration", "align"], function(n) { var i = t.get(n);
            i && e.push("text-" + n + ":" + i) }), e.join(";") }

    function fg(t) { var e = [],
            n = t.get("transitionDuration"),
            i = t.get("backgroundColor"),
            r = t.getModel("textStyle"),
            a = t.get("padding"); return n && e.push(cg(n)), i && (Sx.canvasSupported ? e.push("background-Color:" + i) : (e.push("background-Color:#" + an(i)), e.push("filter:alpha(opacity=70)"))), vk(["width", "color", "radius"], function(n) { var i = "border-" + n,
                r = mk(i),
                a = t.get(r);
            null != a && e.push(i + ":" + a + ("color" === n ? "" : "px")) }), e.push(dg(r)), null != a && e.push("padding:" + jM(a).join("px ") + "px"), e.join(";") + ";" }

    function pg(t, e, n, i, r) { var a = e && e.painter; if (n) { var o = a && a.getViewportRoot();
            o && pe(t, o, document.body, i, r) } else { t[0] = i, t[1] = r; var s = a && a.getViewportRootOffset();
            s && (t[0] += s.offsetLeft, t[1] += s.offsetTop) } }

    function gg(t, e, n) { if (Sx.wxa) return null; var i = document.createElement("div");
        i.domBelongToZr = !0, this.el = i; var r = this._zr = e.getZr(),
            a = this._appendToBody = n && n.appendToBody;
        this._styleCoord = [0, 0], pg(this._styleCoord, r, a, e.getWidth() / 2, e.getHeight() / 2), a ? document.body.appendChild(i) : t.appendChild(i), this._container = t, this._show = !1, this._hideTimeout; var o = this;
        i.onmouseenter = function() { o._enterable && (clearTimeout(o._hideTimeout), o._show = !0), o._inContent = !0 }, i.onmousemove = function(t) { if (t = t || window.event, !o._enterable) { var e = r.handler,
                    n = r.painter.getViewportRoot();
                we(n, t, !0), e.dispatch("mousemove", t) } }, i.onmouseleave = function() { o._enterable && o._show && o.hideLater(o._hideDelay), o._inContent = !1 } }

    function vg(t) { this._zr = t.getZr(), this._show = !1, this._hideTimeout }

    function mg(t) { for (var e = t.pop(); t.length;) { var n = t.pop();
            n && (vo.isInstance(n) && (n = n.get("tooltip", !0)), "string" == typeof n && (n = { formatter: n }), e = new vo(n, e, e.ecModel)) } return e }

    function yg(t, e) { return t.dispatchAction || y(e.dispatchAction, e) }

    function xg(t, e, n, i, r, a, o) { var s = n.getOuterSize(),
            l = s.width,
            u = s.height; return null != a && (t + l + a > i ? t -= l + a : t += a), null != o && (e + u + o > r ? e -= u + o : e += o), [t, e] }

    function _g(t, e, n, i, r) { var a = n.getOuterSize(),
            o = a.width,
            s = a.height; return t = Math.min(t + o, i) - o, e = Math.min(e + s, r) - s, t = Math.max(t, 0), e = Math.max(e, 0), [t, e] }

    function bg(t, e, n) { var i = n[0],
            r = n[1],
            a = 5,
            o = 0,
            s = 0,
            l = e.width,
            u = e.height; switch (t) {
            case "inside":
                o = e.x + l / 2 - i / 2, s = e.y + u / 2 - r / 2; break;
            case "top":
                o = e.x + l / 2 - i / 2, s = e.y - r - a; break;
            case "bottom":
                o = e.x + l / 2 - i / 2, s = e.y + u + a; break;
            case "left":
                o = e.x - i - a, s = e.y + u / 2 - r / 2; break;
            case "right":
                o = e.x + l + a, s = e.y + u / 2 - r / 2 } return [o, s] }

    function wg(t) { return "center" === t || "middle" === t }

    function Mg(t) { nr(t, "label", ["show"]) }

    function Sg(t) { return !(isNaN(parseFloat(t.x)) && isNaN(parseFloat(t.y))) }

    function Ig(t) { return !isNaN(parseFloat(t.x)) && !isNaN(parseFloat(t.y)) }

    function Tg(t, e, n, i, r, a) { var o = [],
            s = fh(e, i),
            l = s ? e.getCalculationInfo("stackResultDimension") : i,
            u = Lg(e, l, t),
            h = e.indicesOfNearest(l, u)[0];
        o[r] = e.get(n, h), o[a] = e.get(l, h); var c = e.get(i, h),
            d = Co(e.get(i, h)); return d = Math.min(d, 20), d >= 0 && (o[a] = +o[a].toFixed(d)), [o, c] }

    function Cg(t, e) { var n = t.getData(),
            r = t.coordinateSystem; if (e && !Ig(e) && !_(e.coord) && r) { var a = r.dimensions,
                o = Ag(e, n, r, t); if (e = i(e), e.type && Dk[e.type] && o.baseAxis && o.valueAxis) { var s = Ck(a, o.baseAxis.dim),
                    l = Ck(a, o.valueAxis.dim),
                    u = Dk[e.type](n, o.baseDataDim, o.valueDataDim, s, l);
                e.coord = u[0], e.value = u[1] } else { for (var h = [null != e.xAxis ? e.xAxis : e.radiusAxis, null != e.yAxis ? e.yAxis : e.angleAxis], c = 0; 2 > c; c++) Dk[h[c]] && (h[c] = Lg(n, n.mapDimension(a[c]), h[c]));
                e.coord = h } } return e }

    function Ag(t, e, n, i) { var r = {}; return null != t.valueIndex || null != t.valueDim ? (r.valueDataDim = null != t.valueIndex ? e.getDimension(t.valueIndex) : t.valueDim, r.valueAxis = n.getAxis(Dg(i, r.valueDataDim)), r.baseAxis = n.getOtherAxis(r.valueAxis), r.baseDataDim = e.mapDimension(r.baseAxis.dim)) : (r.baseAxis = i.getBaseAxis(), r.valueAxis = n.getOtherAxis(r.baseAxis), r.baseDataDim = e.mapDimension(r.baseAxis.dim), r.valueDataDim = e.mapDimension(r.valueAxis.dim)), r }

    function Dg(t, e) { var n = t.getData(),
            i = n.dimensions;
        e = n.getDimension(e); for (var r = 0; r < i.length; r++) { var a = n.getDimensionInfo(i[r]); if (a.name === e) return a.coordDim } }

    function kg(t, e) { return t && t.containData && e.coord && !Sg(e) ? t.containData(e.coord) : !0 }

    function Pg(t, e, n, i) { return 2 > i ? t.coord && t.coord[i] : t.value }

    function Lg(t, e, n) { if ("average" === n) { var i = 0,
                r = 0; return t.each(e, function(t) { isNaN(t) || (i += t, r++) }), i / r } return "median" === n ? t.getMedian(e) : t.getDataExtent(e, !0)["max" === n ? 1 : 0] }

    function Og(t, e, n) { var i = e.coordinateSystem;
        t.each(function(r) { var a, o = t.getItemModel(r),
                s = So(o.get("x"), n.getWidth()),
                l = So(o.get("y"), n.getHeight()); if (isNaN(s) || isNaN(l)) { if (e.getMarkerPosition) a = e.getMarkerPosition(t.getValues(t.dimensions, r));
                else if (i) { var u = t.get(i.dimensions[0], r),
                        h = t.get(i.dimensions[1], r);
                    a = i.dataToPoint([u, h]) } } else a = [s, l];
            isNaN(s) || (a[0] = s), isNaN(l) || (a[1] = l), t.setItemLayout(r, a) }) }

    function zg(t, e, n) { var i;
        i = t ? p(t && t.dimensions, function(t) { var n = e.getData().getDimensionInfo(e.getData().mapDimension(t)) || {}; return s({ name: t }, n) }) : [{ name: "value", type: "float" }]; var r = new PT(i, n),
            a = p(n.get("data"), x(Cg, e)); return t && (a = v(a, x(kg, t))), r.initData(a, null, t ? Pg : function(t) { return t.value }), r }

    function Eg(t) { return !isNaN(t) && !isFinite(t) }

    function Rg(t, e, n, i) { var r = 1 - t,
            a = i.dimensions[t]; return Eg(e[r]) && Eg(n[r]) && e[t] === n[t] && i.getAxis(a).containData(e[t]) }

    function Bg(t, e) { if ("cartesian2d" === t.type) { var n = e[0].coord,
                i = e[1].coord; if (n && i && (Rg(1, n, i, t) || Rg(0, n, i, t))) return !0 } return kg(t, e[0]) && kg(t, e[1]) }

    function Ng(t, e, n, i, r) { var a, o = i.coordinateSystem,
            s = t.getItemModel(e),
            l = So(s.get("x"), r.getWidth()),
            u = So(s.get("y"), r.getHeight()); if (isNaN(l) || isNaN(u)) { if (i.getMarkerPosition) a = i.getMarkerPosition(t.getValues(t.dimensions, e));
            else { var h = o.dimensions,
                    c = t.get(h[0], e),
                    d = t.get(h[1], e);
                a = o.dataToPoint([c, d]) } if ("cartesian2d" === o.type) { var f = o.getAxis("x"),
                    p = o.getAxis("y"),
                    h = o.dimensions;
                Eg(t.get(h[0], e)) ? a[0] = f.toGlobalCoord(f.getExtent()[n ? 0 : 1]) : Eg(t.get(h[1], e)) && (a[1] = p.toGlobalCoord(p.getExtent()[n ? 0 : 1])) }
            isNaN(l) || (a[0] = l), isNaN(u) || (a[1] = u) } else a = [l, u];
        t.setItemLayout(e, a) }

    function Vg(t, e, n) { var i;
        i = t ? p(t && t.dimensions, function(t) { var n = e.getData().getDimensionInfo(e.getData().mapDimension(t)) || {}; return s({ name: t }, n) }) : [{ name: "value", type: "float" }]; var r = new PT(i, n),
            a = new PT(i, n),
            o = new PT([], n),
            l = p(n.get("data"), x(Pk, e, t, n));
        t && (l = v(l, x(Bg, t))); var u = t ? Pg : function(t) { return t.value }; return r.initData(p(l, function(t) { return t[0] }), null, u), a.initData(p(l, function(t) { return t[1] }), null, u), o.initData(p(l, function(t) { return t[2] })), o.hasItemOption = !0, { from: r, to: a, line: o } }

    function Fg(t) { return !isNaN(t) && !isFinite(t) }

    function Hg(t, e, n) { var i = 1 - t; return Fg(e[i]) && Fg(n[i]) }

    function Gg(t, e) { var n = e.coord[0],
            i = e.coord[1]; return "cartesian2d" === t.type && n && i && (Hg(1, n, i, t) || Hg(0, n, i, t)) ? !0 : kg(t, { coord: n, x: e.x0, y: e.y0 }) || kg(t, { coord: i, x: e.x1, y: e.y1 }) }

    function Wg(t, e, n, i, r) { var a, o = i.coordinateSystem,
            s = t.getItemModel(e),
            l = So(s.get(n[0]), r.getWidth()),
            u = So(s.get(n[1]), r.getHeight()); if (isNaN(l) || isNaN(u)) { if (i.getMarkerPosition) a = i.getMarkerPosition(t.getValues(n, e));
            else { var h = t.get(n[0], e),
                    c = t.get(n[1], e),
                    d = [h, c];
                o.clampData && o.clampData(d, d), a = o.dataToPoint(d, !0) } if ("cartesian2d" === o.type) { var f = o.getAxis("x"),
                    p = o.getAxis("y"),
                    h = t.get(n[0], e),
                    c = t.get(n[1], e);
                Fg(h) ? a[0] = f.toGlobalCoord(f.getExtent()["x0" === n[0] ? 0 : 1]) : Fg(c) && (a[1] = p.toGlobalCoord(p.getExtent()["y0" === n[1] ? 0 : 1])) }
            isNaN(l) || (a[0] = l), isNaN(u) || (a[1] = u) } else a = [l, u]; return a }

    function Zg(t, e, n) { var i, r, a = ["x0", "y0", "x1", "y1"];
        t ? (i = p(t && t.dimensions, function(t) { var n = e.getData(),
                i = n.getDimensionInfo(n.mapDimension(t)) || {}; return s({ name: t }, i) }), r = new PT(p(a, function(t, e) { return { name: t, type: i[e % 2].type } }), n)) : (i = [{ name: "value", type: "float" }], r = new PT(i, n)); var o = p(n.get("data"), x(Lk, e, t, n));
        t && (o = v(o, x(Gg, t))); var l = t ? function(t, e, n, i) { return t.coord[Math.floor(i / 2)][i % 2] } : function(t) { return t.value }; return r.initData(o, null, l), r.hasItemOption = !0, r }

    function Ug(t) { var e = t.type,
            n = { number: "value", time: "time" }; if (n[e] && (t.axisType = n[e], delete t.type), Xg(t), Yg(t, "controlPosition")) { var i = t.controlStyle || (t.controlStyle = {});
            Yg(i, "position") || (i.position = t.controlPosition), "none" !== i.position || Yg(i, "show") || (i.show = !1, delete i.position), delete t.controlPosition }
        f(t.data || [], function(t) { M(t) && !_(t) && (!Yg(t, "value") && Yg(t, "name") && (t.value = t.name), Xg(t)) }) }

    function Xg(t) { var e = t.itemStyle || (t.itemStyle = {}),
            n = e.emphasis || (e.emphasis = {}),
            i = t.label || t.label || {},
            r = i.normal || (i.normal = {}),
            a = { normal: 1, emphasis: 1 };
        f(i, function(t, e) { a[e] || Yg(r, e) || (r[e] = t) }), n.label && !Yg(i, "emphasis") && (i.emphasis = n.label, delete n.label) }

    function Yg(t, e) { return t.hasOwnProperty(e) }

    function jg(t, e) { return Qo(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }, t.get("padding")) }

    function qg(t, e, n, r) { var a = ba(t.get(e).replace(/^path:\/\//, ""), i(r || {}), new Cn(n[0], n[1], n[2], n[3]), "center"); return a }

    function Kg(t, e, n, i, a, o) { var s = e.get("color"); if (a) a.setColor(s), n.add(a), o && o.onUpdate(a);
        else { var l = t.get("symbol");
            a = $h(l, -1, -1, 2, 2, s), a.setStyle("strokeNoScale", !0), n.add(a), o && o.onCreate(a) } var u = e.getItemStyle(["color", "symbol", "symbolSize"]);
        a.setStyle(u), i = r({ rectHover: !0, z2: 100 }, i, !0); var h = t.get("symbolSize");
        h = h instanceof Array ? h.slice() : [+h, +h], h[0] /= 2, h[1] /= 2, i.scale = h; var c = t.get("symbolOffset"); if (c) { var d = i.position = i.position || [0, 0];
            d[0] += So(c[0], h[0]), d[1] += So(c[1], h[1]) } var f = t.get("symbolRotate"); return i.rotation = (f || 0) * Math.PI / 180 || 0, a.attr(i), a.updateTransform(), a }

    function $g(t, e, n, i, r) { if (!t.dragging) { var a = i.getModel("checkpointStyle"),
                o = n.dataToCoord(i.getData().get(["value"], e));
            r || !a.get("animation", !0) ? t.attr({ position: [o, 0] }) : (t.stopAnimation(!0), t.animateTo({ position: [o, 0] }, a.get("animationDuration", !0), a.get("animationEasing", !0))) } }

    function Qg(t) { return u(Wk, t) >= 0 }

    function Jg(t, e) { t = t.slice(); var n = p(t, jo);
        e = (e || []).slice(); var i = p(e, jo); return function(r, a) { f(t, function(t, o) { for (var s = { name: t, capital: n[o] }, l = 0; l < e.length; l++) s[e[l]] = t + i[l];
                r.call(a, s) }) } }

    function tv(t, e, n) {
        function i(t, e) { return u(e.nodes, t) >= 0 }

        function r(t, i) { var r = !1; return e(function(e) { f(n(t, e) || [], function(t) { i.records[e.name][t] && (r = !0) }) }), r }

        function a(t, i) { i.nodes.push(t), e(function(e) { f(n(t, e) || [], function(t) { i.records[e.name][t] = !0 }) }) } return function(n) {
            function o(t) {!i(t, s) && r(t, s) && (a(t, s), l = !0) } var s = { nodes: [], records: {} }; if (e(function(t) { s.records[t.name] = {} }), !n) return s;
            a(n, s); var l;
            do l = !1, t(o); while (l); return s } }

    function ev(t, e) { var n = t[e] - t[1 - e]; return { span: Math.abs(n), sign: n > 0 ? -1 : 0 > n ? 1 : e ? -1 : 1 } }

    function nv(t, e) { return Math.min(null != e[1] ? e[1] : 1 / 0, Math.max(null != e[0] ? e[0] : -1 / 0, t)) }

    function iv(t, e, n) { var i = [1 / 0, -1 / 0]; return Xk(n, function(t) { var n = t.getData();
            n && Xk(n.mapDimension(e, !0), function(t) { var e = n.getApproximateExtent(t);
                e[0] < i[0] && (i[0] = e[0]), e[1] > i[1] && (i[1] = e[1]) }) }), i[1] < i[0] && (i = [0 / 0, 0 / 0]), rv(t, i), i }

    function rv(t, e) { var n = t.getAxisModel(),
            i = n.getMin(!0),
            r = "category" === n.get("type"),
            a = r && n.getCategories().length;
        null != i && "dataMin" !== i && "function" != typeof i ? e[0] = i : r && (e[0] = a > 0 ? 0 : 0 / 0); var o = n.getMax(!0); return null != o && "dataMax" !== o && "function" != typeof o ? e[1] = o : r && (e[1] = a > 0 ? a - 1 : 0 / 0), n.get("scale", !0) || (e[0] > 0 && (e[0] = 0), e[1] < 0 && (e[1] = 0)), e }

    function av(t, e) { var n = t.getAxisModel(),
            i = t._percentWindow,
            r = t._valueWindow; if (i) { var a = Do(r, [0, 500]);
            a = Math.min(a, 20); var o = e || 0 === i[0] && 100 === i[1];
            n.setRange(o ? null : +r[0].toFixed(a), o ? null : +r[1].toFixed(a)) } }

    function ov(t) { var e = t._minMaxSpan = {},
            n = t._dataZoomModel,
            i = t._dataExtent;
        Xk(["min", "max"], function(r) { var a = n.get(r + "Span"),
                o = n.get(r + "ValueSpan");
            null != o && (o = t.getAxisModel().axis.scale.parse(o)), null != o ? a = Mo(i[0] + o, i, [0, 100], !0) : null != a && (o = Mo(a, [0, 100], i, !0) - i[0]), e[r + "Span"] = a, e[r + "ValueSpan"] = o }) }

    function sv(t) { var e = {}; return qk(["start", "end", "startValue", "endValue", "throttle"], function(n) { t.hasOwnProperty(n) && (e[n] = t[n]) }), e }

    function lv(t, e) { var n = t._rangePropMode,
            i = t.get("rangeMode");
        qk([
            ["start", "startValue"],
            ["end", "endValue"]
        ], function(t, r) { var a = null != e[t[0]],
                o = null != e[t[1]];
            a && !o ? n[r] = "percent" : !a && o ? n[r] = "value" : i ? n[r] = i[r] : a && (n[r] = "percent") }) }

    function uv(t) { var e = { x: "y", y: "x", radius: "angle", angle: "radius" }; return e[t] }

    function hv(t) { return "vertical" === t ? "ns-resize" : "ew-resize" }

    function cv(t, e) { var n = pv(t),
            i = e.dataZoomId,
            r = e.coordId;
        f(n, function(t) { var n = t.dataZoomInfos;
            n[i] && u(e.allCoordIds, r) < 0 && (delete n[i], t.count--) }), vv(n); var a = n[r];
        a || (a = n[r] = { coordId: r, dataZoomInfos: {}, count: 0 }, a.controller = gv(t, a), a.dispatchAction = x(mv, t)), !a.dataZoomInfos[i] && a.count++, a.dataZoomInfos[i] = e; var o = yv(a.dataZoomInfos);
        a.controller.enable(o.controlType, o.opt), a.controller.setPointerChecker(e.containsPoint), xl(a, "dispatchAction", e.dataZoomModel.get("throttle", !0), "fixRate") }

    function dv(t, e) { var n = pv(t);
        f(n, function(t) { t.controller.dispose(); var n = t.dataZoomInfos;
            n[e] && (delete n[e], t.count--) }), vv(n) }

    function fv(t) { return t.type + "\x00_" + t.id }

    function pv(t) { var e = t.getZr(); return e[dP] || (e[dP] = {}) }

    function gv(t, e) { var n = new Df(t.getZr()); return f(["pan", "zoom", "scrollMove"], function(t) { n.on(t, function(n) { var i = [];
                f(e.dataZoomInfos, function(r) { if (n.isAvailableBehavior(r.dataZoomModel.option)) { var a = (r.getRange || {})[t],
                            o = a && a(e.controller, n);!r.dataZoomModel.get("disabled", !0) && o && i.push({ dataZoomId: r.dataZoomId, start: o[0], end: o[1] }) } }), i.length && e.dispatchAction(i) }) }), n }

    function vv(t) { f(t, function(e, n) { e.count || (e.controller.dispose(), delete t[n]) }) }

    function mv(t, e) { t.dispatchAction({ type: "dataZoom", batch: e }) }

    function yv(t) { var e, n = "type_",
            i = { type_true: 2, type_move: 1, type_false: 0, type_undefined: -1 },
            r = !0; return f(t, function(t) { var a = t.dataZoomModel,
                o = a.get("disabled", !0) ? !1 : a.get("zoomLock", !0) ? "move" : !0;
            i[n + o] > i[n + e] && (e = o), r &= a.get("preventDefaultMouseMove", !0) }), { controlType: e, opt: { zoomOnMouseWheel: !0, moveOnMouseMove: !0, moveOnMouseWheel: !0, preventDefaultMouseMove: !!r } } }

    function xv(t) { return function(e, n, i, r) { var a = this._range,
                o = a.slice(),
                s = e.axisModels[0]; if (s) { var l = t(o, s, e, n, i, r); return Uk(l, o, [0, 100], "all"), this._range = o, a[0] !== o[0] || a[1] !== o[1] ? o : void 0 } } }

    function _v(t) { var e = {};
        f(t, function(t) { e[t] = 1 }), t.length = 0, f(e, function(e, n) { t.push(n) }) }

    function bv(t) { var e = t.pieceList;
        t.hasSpecialVisual = !1, f(e, function(e, n) { e.originIndex = n, null != e.visual && (t.hasSpecialVisual = !0) }) }

    function wv(t) { var e = t.categories,
            n = t.visual,
            i = t.categoryMap = {}; if (xP(e, function(t, e) { i[t] = e }), !_(n)) { var r = [];
            M(n) ? xP(n, function(t, e) { var n = i[e];
                r[null != n ? n : bP] = t }) : r[bP] = n, n = Pv(t, r) } for (var a = e.length - 1; a >= 0; a--) null == n[a] && (delete i[e[a]], e.pop()) }

    function Mv(t, e) { var n = t.visual,
            i = [];
        M(n) ? xP(n, function(t) { i.push(t) }) : null != n && i.push(n); var r = { color: 1, symbol: 1 };
        e || 1 !== i.length || r.hasOwnProperty(t.type) || (i[1] = i[0]), Pv(t, i) }

    function Sv(t) { return { applyVisual: function(e, n, i) { e = this.mapValueToVisual(e), i("color", t(n("color"), e)) }, _doMap: Dv([0, 1]) } }

    function Iv(t) { var e = this.option.visual; return e[Math.round(Mo(t, [0, 1], [0, e.length - 1], !0))] || {} }

    function Tv(t) { return function(e, n, i) { i(t, this.mapValueToVisual(e)) } }

    function Cv(t) { var e = this.option.visual; return e[this.option.loop && t !== bP ? t % e.length : t] }

    function Av() { return this.option.visual[0] }

    function Dv(t) { return { linear: function(e) { return Mo(e, t, this.option.visual, !0) }, category: Cv, piecewise: function(e, n) { var i = kv.call(this, n); return null == i && (i = Mo(e, t, this.option.visual, !0)), i }, fixed: Av } }

    function kv(t) { var e = this.option,
            n = e.pieceList; if (e.hasSpecialVisual) { var i = wP.findPieceIndex(t, n),
                r = n[i]; if (r && r.visual) return r.visual[this.type] } }

    function Pv(t, e) { return t.visual = e, "color" === t.type && (t.parsedVisual = p(e, function(t) { return tn(t) })), e }

    function Lv(t, e, n) { return t ? n >= e : n > e }

    function Ov(t) { if (t)
            for (var e in t)
                if (t.hasOwnProperty(e)) return !0 }

    function zv(t, e, n) {
        function r() { var t = function() {};
            t.prototype.__hidden = t.prototype; var e = new t; return e } var a = {}; return IP(e, function(e) { var o = a[e] = r();
            IP(t[e], function(t, r) { if (wP.isValidType(r)) { var a = { type: r, visual: t };
                    n && n(a, e), o[r] = new wP(a), "opacity" === r && (a = i(a), a.type = "colorAlpha", o.__hidden.__alphaForOpacity = new wP(a)) } }) }), a }

    function Ev(t, e, n) { var r;
        f(n, function(t) { e.hasOwnProperty(t) && Ov(e[t]) && (r = !0) }), r && f(n, function(n) { e.hasOwnProperty(n) && Ov(e[n]) ? t[n] = i(e[n]) : delete t[n] }) }

    function Rv(t, e, n, i, r, a) {
        function o(t) { return n.getItemVisual(h, t) }

        function s(t, e) { n.setItemVisual(h, t, e) }

        function l(t, l) { h = null == a ? t : l; var c = n.getRawDataItem(h); if (!c || c.visualMap !== !1)
                for (var d = i.call(r, t), f = e[d], p = u[d], g = 0, v = p.length; v > g; g++) { var m = p[g];
                    f[m] && f[m].applyVisual(t, o, s) } } var u = {};
        f(t, function(t) { var n = wP.prepareVisualTypes(e[t]);
            u[t] = n }); var h;
        null == a ? n.each(l) : n.each([a], l) }

    function Bv(t, e, n, i) {
        function r(t, r) {
            function o(t) { return r.getItemVisual(l, t) }

            function s(t, e) { r.setItemVisual(l, t, e) }
            null != i && (i = r.getDimension(i)); for (var l; null != (l = t.next());) { var u = r.getRawDataItem(l); if (!u || u.visualMap !== !1)
                    for (var h = null != i ? r.get(i, l, !0) : l, c = n(h), d = e[c], f = a[c], p = 0, g = f.length; g > p; p++) { var v = f[p];
                        d[v] && d[v].applyVisual(h, o, s) } } } var a = {}; return f(t, function(t) { var n = wP.prepareVisualTypes(e[t]);
            a[t] = n }), { progress: r } }

    function Nv(t) { var e = ["x", "y"],
            n = ["width", "height"]; return { point: function(e, n, i) { if (e) { var r = i.range,
                        a = e[t]; return Vv(a, r) } }, rect: function(i, r, a) { if (i) { var o = a.range,
                        s = [i[e[t]], i[e[t]] + i[n[t]]]; return s[1] < s[0] && s.reverse(), Vv(s[0], o) || Vv(s[1], o) || Vv(o[0], s) || Vv(o[1], s) } } } }

    function Vv(t, e) { return e[0] <= t && t <= e[1] }

    function Fv(t) { return t = Wv(t),
            function(e) { return lo(e, t) } }

    function Hv(t, e) { return t = Wv(t),
            function(n) { var i = null != e ? e : n,
                    r = i ? t.width : t.height,
                    a = i ? t.x : t.y; return [a, a + (r || 0)] } }

    function Gv(t, e, n) { return t = Wv(t),
            function(i, r) { return t.contain(r[0], r[1]) && !Ff(i, e, n) } }

    function Wv(t) { return Cn.create(t) }

    function Zv(t, e, n) { var i = this._targetInfoList = [],
            r = {},
            a = Xv(e, t);
        CP(OP, function(t, e) {
            (!n || !n.include || AP(n.include, e) >= 0) && t(a, i, r) }) }

    function Uv(t) { return t[0] > t[1] && t.reverse(), t }

    function Xv(t, e) { return dr(t, e, { includeMainTypes: PP }) }

    function Yv(t, e, n, i) { var r = n.getAxis(["x", "y"][t]),
            a = Uv(p([0, 1], function(t) { return e ? r.coordToData(r.toLocalCoord(i[t])) : r.toGlobalCoord(r.dataToCoord(i[t])) })),
            o = []; return o[t] = a, o[1 - t] = [0 / 0, 0 / 0], { values: a, xyMinMax: o } }

    function jv(t, e, n, i) { return [e[0] - i[t] * n[0], e[1] - i[t] * n[1]] }

    function qv(t, e) { var n = Kv(t),
            i = Kv(e),
            r = [n[0] / i[0], n[1] / i[1]]; return isNaN(r[0]) && (r[0] = 1), isNaN(r[1]) && (r[1] = 1), r }

    function Kv(t) { return t ? [t[0][1] - t[0][0], t[1][1] - t[1][0]] : [0 / 0, 0 / 0] }

    function $v(t) { t.eachComponent({ mainType: "brush" }, function(e) { var n = e.brushTargetManager = new Zv(e.option, t);
            n.setInputRanges(e.areas, t) }) }

    function Qv(t, e, n, i, r) { if (r) { var a = t.getZr(); if (!a[FP]) { a[VP] || (a[VP] = Jv); var o = xl(a, VP, n, e);
                o(t, i) } } }

    function Jv(t, e) { if (!t.isDisposed()) { var n = t.getZr();
            n[FP] = !0, t.dispatchAction({ type: "brushSelect", batch: e }), n[FP] = !1 } }

    function tm(t, e, n, i) { for (var r = 0, a = e.length; a > r; r++) { var o = e[r]; if (t[o.brushType](i, n, o.selectors, o)) return !0 } }

    function em(t) { var e = t.brushSelector; if (w(e)) { var n = []; return f(TP, function(t, i) { n[i] = function(n, i, r, a) { var o = i.getItemLayout(n); return t[e](o, r, a) } }), n } if (b(e)) { var i = {}; return f(TP, function(t, n) { i[n] = e }), i } return e }

    function nm(t, e) { var n = t.option.seriesIndex; return null != n && "all" !== n && (_(n) ? u(n, e) < 0 : e !== n) }

    function im(t) { var e = t.selectors = {}; return f(TP[t.brushType], function(n, i) { e[i] = function(i) { return n(i, e, t) } }), t }

    function rm(t) { return new Cn(t[0][0], t[1][0], t[0][1] - t[0][0], t[1][1] - t[1][0]) }

    function am(t, e) { return r({ brushType: t.brushType, brushMode: t.brushMode, transformable: t.transformable, brushStyle: new vo(t.brushStyle).getItemStyle(), removeOnClick: t.removeOnClick, z: t.z }, e, !0) }

    function om(t) { Xx.call(this), this._zr = t, this.group = new N_, this._brushType, this._brushOption, this._panels, this._track = [], this._dragging, this._covers = [], this._creatingCover, this._creatingPanel, this._enableGlobalPan, this._uid = "brushController_" + iL++, this._handlers = {}, UP(rL, function(t, e) { this._handlers[e] = y(t, this) }, this) }

    function sm(t, e) { var n = t._zr;
        t._enableGlobalPan || If(n, JP, t._uid), um(n, t._handlers), t._brushType = e.brushType, t._brushOption = r(i(nL), e, !0) }

    function lm(t) { var e = t._zr;
        Tf(e, JP, t._uid), hm(e, t._handlers), t._brushType = t._brushOption = null }

    function um(t, e) { UP(e, function(e, n) { t.on(n, e) }) }

    function hm(t, e) { UP(e, function(e, n) { t.off(n, e) }) }

    function cm(t, e) { var n = aL[e.brushType].createCover(t, e); return n.__brushOption = e, pm(n, e), t.group.add(n), n }

    function dm(t, e) { var n = vm(e); return n.endCreating && (n.endCreating(t, e), pm(e, e.__brushOption)), e }

    function fm(t, e) { var n = e.__brushOption;
        vm(e).updateCoverShape(t, e, n.range, n) }

    function pm(t, e) { var n = e.z;
        null == n && (n = KP), t.traverse(function(t) { t.z = n, t.z2 = n }) }

    function gm(t, e) { vm(e).updateCommon(t, e), fm(t, e) }

    function vm(t) { return aL[t.__brushOption.brushType] }

    function mm(t, e, n) { var i = t._panels; if (!i) return !0; var r, a = t._transform; return UP(i, function(t) { t.isTargetByCursor(e, n, a) && (r = t) }), r }

    function ym(t, e) { var n = t._panels; if (!n) return !0; var i = e.__brushOption.panelId; return null != i ? n[i] : !0 }

    function xm(t) { var e = t._covers,
            n = e.length; return UP(e, function(e) { t.group.remove(e) }, t), e.length = 0, !!n }

    function _m(t, e) { var n = XP(t._covers, function(t) { var e = t.__brushOption,
                n = i(e.range); return { brushType: e.brushType, panelId: e.panelId, range: n } });
        t.trigger("brush", n, { isEnd: !!e.isEnd, removeOnClick: !!e.removeOnClick }) }

    function bm(t) { var e = t._track; if (!e.length) return !1; var n = e[e.length - 1],
            i = e[0],
            r = n[0] - i[0],
            a = n[1] - i[1],
            o = qP(r * r + a * a, .5); return o > $P }

    function wm(t) { var e = t.length - 1; return 0 > e && (e = 0), [t[0], t[e]] }

    function Mm(t, e, n, i) { var r = new N_; return r.add(new cM({ name: "main", style: Cm(n), silent: !0, draggable: !0, cursor: "move", drift: ZP(t, e, r, "nswe"), ondragend: ZP(_m, e, { isEnd: !0 }) })), UP(i, function(n) { r.add(new cM({ name: n, style: { opacity: 0 }, draggable: !0, silent: !0, invisible: !0, drift: ZP(t, e, r, n), ondragend: ZP(_m, e, { isEnd: !0 }) })) }), r }

    function Sm(t, e, n, i) { var r = i.brushStyle.lineWidth || 0,
            a = jP(r, QP),
            o = n[0][0],
            s = n[1][0],
            l = o - r / 2,
            u = s - r / 2,
            h = n[0][1],
            c = n[1][1],
            d = h - a + r / 2,
            f = c - a + r / 2,
            p = h - o,
            g = c - s,
            v = p + r,
            m = g + r;
        Tm(t, e, "main", o, s, p, g), i.transformable && (Tm(t, e, "w", l, u, a, m), Tm(t, e, "e", d, u, a, m), Tm(t, e, "n", l, u, v, a), Tm(t, e, "s", l, f, v, a), Tm(t, e, "nw", l, u, a, a), Tm(t, e, "ne", d, u, a, a), Tm(t, e, "sw", l, f, a, a), Tm(t, e, "se", d, f, a, a)) }

    function Im(t, e) { var n = e.__brushOption,
            i = n.transformable,
            r = e.childAt(0);
        r.useStyle(Cm(n)), r.attr({ silent: !i, cursor: i ? "move" : "default" }), UP(["w", "e", "n", "s", "se", "sw", "ne", "nw"], function(n) { var r = e.childOfName(n),
                a = km(t, n);
            r && r.attr({ silent: !i, invisible: !i, cursor: i ? eL[a] + "-resize" : null }) }) }

    function Tm(t, e, n, i, r, a, o) { var s = e.childOfName(n);
        s && s.setShape(Em(zm(t, e, [
            [i, r],
            [i + a, r + o]
        ]))) }

    function Cm(t) { return s({ strokeNoScale: !0 }, t.brushStyle) }

    function Am(t, e, n, i) { var r = [YP(t, n), YP(e, i)],
            a = [jP(t, n), jP(e, i)]; return [
            [r[0], a[0]],
            [r[1], a[1]]
        ] }

    function Dm(t) { return ro(t.group) }

    function km(t, e) { if (e.length > 1) { e = e.split(""); var n = [km(t, e[0]), km(t, e[1])]; return ("e" === n[0] || "w" === n[0]) && n.reverse(), n.join("") } var i = { w: "left", e: "right", n: "top", s: "bottom" },
            r = { left: "w", right: "e", top: "n", bottom: "s" },
            n = oo(i[e], Dm(t)); return r[n] }

    function Pm(t, e, n, i, r, a, o) { var s = i.__brushOption,
            l = t(s.range),
            u = Om(n, a, o);
        UP(r.split(""), function(t) { var e = tL[t];
            l[e[0]][e[1]] += u[e[0]] }), s.range = e(Am(l[0][0], l[1][0], l[0][1], l[1][1])), gm(n, i), _m(n, { isEnd: !1 }) }

    function Lm(t, e, n, i) { var r = e.__brushOption.range,
            a = Om(t, n, i);
        UP(r, function(t) { t[0] += a[0], t[1] += a[1] }), gm(t, e), _m(t, { isEnd: !1 }) }

    function Om(t, e, n) { var i = t.group,
            r = i.transformCoordToLocal(e, n),
            a = i.transformCoordToLocal(0, 0); return [r[0] - a[0], r[1] - a[1]] }

    function zm(t, e, n) { var r = ym(t, e); return r && r !== !0 ? r.clipPath(n, t._transform) : i(n) }

    function Em(t) { var e = YP(t[0][0], t[1][0]),
            n = YP(t[0][1], t[1][1]),
            i = jP(t[0][0], t[1][0]),
            r = jP(t[0][1], t[1][1]); return { x: e, y: n, width: i - e, height: r - n } }

    function Rm(t, e, n) { if (t._brushType && !Gm(t, e)) { var i = t._zr,
                r = t._covers,
                a = mm(t, e, n); if (!t._dragging)
                for (var o = 0; o < r.length; o++) { var s = r[o].__brushOption; if (a && (a === !0 || s.panelId === a.panelId) && aL[s.brushType].contain(r[o], n[0], n[1])) return }
            a && i.setCursorStyle("crosshair") } }

    function Bm(t) { var e = t.event;
        e.preventDefault && e.preventDefault() }

    function Nm(t, e, n) { return t.childOfName("main").contain(e, n) }

    function Vm(t, e, n, r) { var a, o = t._creatingCover,
            s = t._creatingPanel,
            l = t._brushOption; if (t._track.push(n.slice()), bm(t) || o) { if (s && !o) { "single" === l.brushMode && xm(t); var u = i(l);
                u.brushType = Fm(u.brushType, s), u.panelId = s === !0 ? null : s.panelId, o = t._creatingCover = cm(t, u), t._covers.push(o) } if (o) { var h = aL[Fm(t._brushType, s)],
                    c = o.__brushOption;
                c.range = h.getCreatingRange(zm(t, o, t._track)), r && (dm(t, o), h.updateCommon(t, o)), fm(t, o), a = { isEnd: r } } } else r && "single" === l.brushMode && l.removeOnClick && mm(t, e, n) && xm(t) && (a = { isEnd: r, removeOnClick: !0 }); return a }

    function Fm(t, e) { return "auto" === t ? e.defaultBrushType : t }

    function Hm(t, e) { if (t._dragging) { Bm(e); var n = e.offsetX,
                i = e.offsetY,
                r = t.group.transformCoordToLocal(n, i),
                a = Vm(t, e, r, !0);
            t._dragging = !1, t._track = [], t._creatingCover = null, a && _m(t, a) } }

    function Gm(t, e, n) { var i = t._zr; return 0 > e || e > i.getWidth() || 0 > n || n > i.getHeight() }

    function Wm(t) { return { createCover: function(e, n) { return Mm(ZP(Pm, function(e) { var n = [e, [0, 100]]; return t && n.reverse(), n }, function(e) { return e[t] }), e, n, [
                    ["w", "e"],
                    ["n", "s"]
                ][t]) }, getCreatingRange: function(e) { var n = wm(e),
                    i = YP(n[0][t], n[1][t]),
                    r = jP(n[0][t], n[1][t]); return [i, r] }, updateCoverShape: function(e, n, i, r) { var a, o = ym(e, n); if (o !== !0 && o.getLinearBrushOtherExtent) a = o.getLinearBrushOtherExtent(t, e._transform);
                else { var s = e._zr;
                    a = [0, [s.getWidth(), s.getHeight()][1 - t]] } var l = [i, a];
                t && l.reverse(), Sm(e, n, l, r) }, updateCommon: Im, contain: Nm } }

    function Zm(t, e, n, i) {
        (!i || i.$from !== t.id) && this._brushController.setPanels(t.brushTargetManager.makePanelOpts(n)).enableBrush(t.brushOption).updateCovers(t.areas.slice()) }

    function Um(t, e) { oL[t] = e }

    function Xm(t) { return oL[t] }

    function Ym(t, e, n) { this.model = t, this.ecModel = e, this.api = n, this._brushType, this._brushMode }

    function jm(t, e) { return t && t.hasOwnProperty && t.hasOwnProperty(e) }

    function qm(t, e, n, i) {
        function r(t) { return l[t] }

        function a(t, e) { l[t] = e } for (var o = e.targetVisuals[i], s = wP.prepareVisualTypes(o), l = { color: t.getData().getVisual("color") }, u = 0, h = s.length; h > u; u++) { var c = s[u],
                d = o["opacity" === c ? "__alphaForOpacity" : c];
            d && d.applyVisual(n, r, a) } return l.color }

    function Km(t, e, n) { if (n[0] === n[1]) return n.slice(); for (var i = 200, r = (n[1] - n[0]) / i, a = n[0], o = [], s = 0; i >= s && a < n[1]; s++) o.push(a), a += r; return o.push(n[1]), o }

    function $m(t, e, n) { var i = t.option,
            r = i.align; if (null != r && "auto" !== r) return r; for (var a = { width: e.getWidth(), height: e.getHeight() }, o = "horizontal" === i.orient ? 1 : 0, s = [
                ["left", "right", "width"],
                ["top", "bottom", "height"]
            ], l = s[o], u = [0, null, 10], h = {}, c = 0; 3 > c; c++) h[s[1 - o][c]] = u[c], h[l[c]] = 2 === c ? n[0] : i[l[c]]; var d = [
                ["x", "width", 3],
                ["y", "height", 0]
            ][o],
            f = Qo(h, a, i.padding); return l[(f.margin[d[2]] || 0) + f[d[0]] + .5 * f[d[1]] < .5 * a[d[1]] ? 0 : 1] }

    function Qm(t, e) { return f(t || [], function(t) { null != t.dataIndex && (t.dataIndexInside = t.dataIndex, t.dataIndex = null), t.highlightKey = "visualMap" + (e ? e.componentIndex : "") }), t }

    function Jm(t, e, n, i) { return new sM({ shape: { points: t }, draggable: !!n, cursor: e, drift: n, onmousemove: function(t) { Jx(t.event) }, ondragend: i }) }

    function ty(t, e) { return 0 === t ? [
            [0, 0],
            [e, 0],
            [e, -e]
        ] : [
            [0, 0],
            [e, 0],
            [e, e]
        ] }

    function ey(t, e, n, i) { return t ? [
            [0, -CL(e, AL(n, 0))],
            [kL, 0],
            [0, CL(e, AL(i - n, 0))]
        ] : [
            [0, 0],
            [5, -5],
            [5, 5]
        ] }

    function ny(t, e, n) { var i = DL / 2,
            r = t.get("hoverLinkDataSize"); return r && (i = IL(r, e, n, !0) / 2), i }

    function iy(t) { var e = t.get("hoverLinkOnHandle"); return !!(null == e ? t.get("realtime") : e) }

    function ry(t) { return "vertical" === t ? "ns-resize" : "ew-resize" }

    function ay(t, e) { var n = t.inverse;
        ("vertical" === t.orient ? !n : n) && e.reverse() }

    function oy(t) { return 0 === t.indexOf("my") }

    function sy(t) { this.model = t }

    function ly(t) {
        this.model = t
    }

    function uy(t) { var e = {},
            n = [],
            i = []; return t.eachRawSeries(function(t) { var r = t.coordinateSystem; if (!r || "cartesian2d" !== r.type && "polar" !== r.type) n.push(t);
            else { var a = r.getBaseAxis(); if ("category" === a.type) { var o = a.dim + "_" + a.index;
                    e[o] || (e[o] = { categoryAxis: a, valueAxis: r.getOtherAxis(a), series: [] }, i.push({ axisDim: a.dim, axisIndex: a.index })), e[o].series.push(t) } else n.push(t) } }), { seriesGroupByCategoryAxis: e, other: n, meta: i } }

    function hy(t) { var e = []; return f(t, function(t) { var n = t.categoryAxis,
                i = t.valueAxis,
                r = i.dim,
                a = [" "].concat(p(t.series, function(t) { return t.name })),
                o = [n.model.getCategories()];
            f(t.series, function(t) { o.push(t.getRawData().mapArray(r, function(t) { return t })) }); for (var s = [a.join(UL)], l = 0; l < o[0].length; l++) { for (var u = [], h = 0; h < o.length; h++) u.push(o[h][l]);
                s.push(u.join(UL)) }
            e.push(s.join("\n")) }), e.join("\n\n" + ZL + "\n\n") }

    function cy(t) { return p(t, function(t) { var e = t.getRawData(),
                n = [t.name],
                i = []; return e.each(e.dimensions, function() { for (var t = arguments.length, r = arguments[t - 1], a = e.getName(r), o = 0; t - 1 > o; o++) i[o] = arguments[o];
                n.push((a ? a + UL : "") + i.join(UL)) }), n.join("\n") }).join("\n\n" + ZL + "\n\n") }

    function dy(t) { var e = uy(t); return { value: v([hy(e.seriesGroupByCategoryAxis), cy(e.other)], function(t) { return t.replace(/[\n\t\s]/g, "") }).join("\n\n" + ZL + "\n\n"), meta: e.meta } }

    function fy(t) { return t.replace(/^\s\s*/, "").replace(/\s\s*$/, "") }

    function py(t) { var e = t.slice(0, t.indexOf("\n")); return e.indexOf(UL) >= 0 ? !0 : void 0 }

    function gy(t) { for (var e = t.split(/\n+/g), n = fy(e.shift()).split(XL), i = [], r = p(n, function(t) { return { name: t, data: [] } }), a = 0; a < e.length; a++) { var o = fy(e[a]).split(XL);
            i.push(o.shift()); for (var s = 0; s < o.length; s++) r[s] && (r[s].data[a] = o[s]) } return { series: r, categories: i } }

    function vy(t) { for (var e = t.split(/\n+/g), n = fy(e.shift()), i = [], r = 0; r < e.length; r++) { var a, o = fy(e[r]).split(XL),
                s = "",
                l = !1;
            isNaN(o[0]) ? (l = !0, s = o[0], o = o.slice(1), i[r] = { name: s, value: [] }, a = i[r].value) : a = i[r] = []; for (var u = 0; u < o.length; u++) a.push(+o[u]);
            1 === a.length && (l ? i[r].value = a[0] : i[r] = a[0]) } return { name: n, data: i } }

    function my(t, e) { var n = t.split(new RegExp("\n*" + ZL + "\n*", "g")),
            i = { series: [] }; return f(n, function(t, n) { if (py(t)) { var r = gy(t),
                    a = e[n],
                    o = a.axisDim + "Axis";
                a && (i[o] = i[o] || [], i[o][a.axisIndex] = { data: r.categories }, i.series = i.series.concat(r.series)) } else { var r = vy(t);
                i.series.push(r) } }), i }

    function yy(t) { this._dom = null, this.model = t }

    function xy(t, e) { return p(t, function(t, n) { var i = e && e[n]; return M(i) && !_(i) ? (M(t) && !_(t) && (t = t.value), s({ value: t }, i)) : t }) }

    function _y(t, e) { var n = Sy(t);
        YL(e, function(e, i) { for (var r = n.length - 1; r >= 0; r--) { var a = n[r]; if (a[i]) break } if (0 > r) { var o = t.queryComponents({ mainType: "dataZoom", subType: "select", id: i })[0]; if (o) { var s = o.getPercentRange();
                    n[0][i] = { dataZoomId: i, start: s[0], end: s[1] } } } }), n.push(e) }

    function by(t) { var e = Sy(t),
            n = e[e.length - 1];
        e.length > 1 && e.pop(); var i = {}; return YL(n, function(t, n) { for (var r = e.length - 1; r >= 0; r--) { var t = e[r][n]; if (t) { i[n] = t; break } } }), i }

    function wy(t) { t[jL] = null }

    function My(t) { return Sy(t).length }

    function Sy(t) { var e = t[jL]; return e || (e = t[jL] = [{}]), e }

    function Iy(t, e, n) {
        (this._brushController = new om(n.getZr())).on("brush", y(this._onBrush, this)).mount(), this._isZoomActive }

    function Ty(t) { var e = {}; return f(["xAxisIndex", "yAxisIndex"], function(n) { e[n] = t[n], null == e[n] && (e[n] = "all"), (e[n] === !1 || "none" === e[n]) && (e[n] = []) }), e }

    function Cy(t, e) { t.setIconStatus("back", My(e) > 1 ? "emphasis" : "normal") }

    function Ay(t, e, n, i, r) { var a = n._isZoomActive;
        i && "takeGlobalCursor" === i.type && (a = "dataZoomSelect" === i.key ? i.dataZoomSelectActive : !1), n._isZoomActive = a, t.setIconStatus("zoom", a ? "emphasis" : "normal"); var o = new Zv(Ty(t.option), e, { include: ["grid"] });
        n._brushController.setPanels(o.makePanelOpts(r, function(t) { return t.xAxisDeclared && !t.yAxisDeclared ? "lineX" : !t.xAxisDeclared && t.yAxisDeclared ? "lineY" : "rect" })).enableBrush(a ? { brushType: "auto", brushStyle: { lineWidth: 0, fill: "rgba(0,0,0,0.2)" } } : !1) }

    function Dy(t) { this.model = t }

    function ky(t, e, n, i) { var r = n.type,
            a = nO.hasOwnProperty(r) ? nO[r] : _a(r),
            o = new a(n);
        e.add(o), i.set(t, o), o.__ecGraphicId = t }

    function Py(t, e) { var n = t && t.parent;
        n && ("group" === t.type && t.traverse(function(t) { Py(t, e) }), e.removeKey(t.__ecGraphicId), n.remove(t)) }

    function Ly(t) { return t = o({}, t), f(["id", "parentId", "$action", "hv", "bounding"].concat(nS), function(e) { delete t[e] }), t }

    function Oy(t, e) { var n; return f(e, function(e) { null != t[e] && "auto" !== t[e] && (n = !0) }), n }

    function zy(t, e) { var n = t.exist; if (e.id = t.keyInfo.id, !e.type && n && (e.type = n.type), null == e.parentId) { var i = e.parentOption;
            i ? e.parentId = i.id : n && (e.parentId = n.parentId) }
        e.parentOption = null }

    function Ey(t, e, n) { var i = o({}, n),
            a = t[e],
            s = n.$action || "merge"; "merge" === s ? a ? (r(a, i, !0), ts(a, i, { ignoreSize: !0 }), ns(n, a)) : t[e] = i : "replace" === s ? t[e] = i : "remove" === s && a && (t[e] = null) }

    function Ry(t, e) { t && (t.hv = e.hv = [Oy(e, ["left", "right"]), Oy(e, ["top", "bottom"])], "group" === t.type && (null == t.width && (t.width = e.width = 0), null == t.height && (t.height = e.height = 0))) }

    function By(t, e) { var n = t.eventData;
        t.silent || t.ignore || n || (n = t.eventData = { componentType: "graphic", componentIndex: e.componentIndex, name: t.name }), n && (n.info = t.info) }

    function Ny(t) { return rO(t) }

    function Vy() { if (!sO && lO) { sO = !0; var t = lO.styleSheets;
            t.length < 31 ? lO.createStyleSheet().addRule(".zrvml", "behavior:url(#default#VML)") : t[0].addRule(".zrvml", "behavior:url(#default#VML)") } }

    function Fy(t) { return parseInt(t, 10) }

    function Hy(t, e) { Vy(), this.root = t, this.storage = e; var n = document.createElement("div"),
            i = document.createElement("div");
        n.style.cssText = "display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;", i.style.cssText = "position:absolute;left:0;top:0;", t.appendChild(n), this._vmlRoot = i, this._vmlViewport = n, this.resize(); var r = e.delFromStorage,
            a = e.addToStorage;
        e.delFromStorage = function(t) { r.call(e, t), t && t.onRemove && t.onRemove(i) }, e.addToStorage = function(t) { t.onAdd && t.onAdd(i), a.call(e, t) }, this._firstPaint = !0 }

    function Gy(t) { return function() { L_('In IE8.0 VML mode painter not support method "' + t + '"') } }

    function Wy(t) { return document.createElementNS(QO, t) }

    function Zy(t) { return nz(1e4 * t) / 1e4 }

    function Uy(t) { return lz > t && t > -lz }

    function Xy(t, e) { var n = e ? t.textFill : t.fill; return null != n && n !== ez }

    function Yy(t, e) { var n = e ? t.textStroke : t.stroke; return null != n && n !== ez }

    function jy(t, e) { e && qy(t, "transform", "matrix(" + tz.call(e, ",") + ")") }

    function qy(t, e, n) {
        (!n || "linear" !== n.type && "radial" !== n.type) && t.setAttribute(e, n) }

    function Ky(t, e, n) { t.setAttributeNS("http://www.w3.org/1999/xlink", e, n) }

    function $y(t, e, n, i) { if (Xy(e, n)) { var r = n ? e.textFill : e.fill;
            r = "transparent" === r ? ez : r, qy(t, "fill", r), qy(t, "fill-opacity", null != e.fillOpacity ? e.fillOpacity * e.opacity : e.opacity) } else qy(t, "fill", ez); if (Yy(e, n)) { var a = n ? e.textStroke : e.stroke;
            a = "transparent" === a ? ez : a, qy(t, "stroke", a); var o = n ? e.textStrokeWidth : e.lineWidth,
                s = !n && e.strokeNoScale ? i.getLineScale() : 1;
            qy(t, "stroke-width", o / s), qy(t, "paint-order", n ? "stroke" : "fill"), qy(t, "stroke-opacity", null != e.strokeOpacity ? e.strokeOpacity : e.opacity); var l = e.lineDash;
            l ? (qy(t, "stroke-dasharray", e.lineDash.join(",")), qy(t, "stroke-dashoffset", nz(e.lineDashOffset || 0))) : qy(t, "stroke-dasharray", ""), e.lineCap && qy(t, "stroke-linecap", e.lineCap), e.lineJoin && qy(t, "stroke-linejoin", e.lineJoin), e.miterLimit && qy(t, "stroke-miterlimit", e.miterLimit) } else qy(t, "stroke", ez) }

    function Qy(t) { for (var e = [], n = t.data, i = t.len(), r = 0; i > r;) { var a = n[r++],
                o = "",
                s = 0; switch (a) {
                case JO.M:
                    o = "M", s = 2; break;
                case JO.L:
                    o = "L", s = 2; break;
                case JO.Q:
                    o = "Q", s = 4; break;
                case JO.C:
                    o = "C", s = 6; break;
                case JO.A:
                    var l = n[r++],
                        u = n[r++],
                        h = n[r++],
                        c = n[r++],
                        d = n[r++],
                        f = n[r++],
                        p = n[r++],
                        g = n[r++],
                        v = Math.abs(f),
                        m = Uy(v - oz) || (g ? f >= oz : -f >= oz),
                        y = f > 0 ? f % oz : f % oz + oz,
                        x = !1;
                    x = m ? !0 : Uy(v) ? !1 : y >= az == !!g; var _ = Zy(l + h * rz(d)),
                        b = Zy(u + c * iz(d));
                    m && (f = g ? oz - 1e-4 : -oz + 1e-4, x = !0, 9 === r && e.push("M", _, b)); var w = Zy(l + h * rz(d + f)),
                        M = Zy(u + c * iz(d + f));
                    e.push("A", Zy(h), Zy(c), nz(p * sz), +x, +g, w, M); break;
                case JO.Z:
                    o = "Z"; break;
                case JO.R:
                    var w = Zy(n[r++]),
                        M = Zy(n[r++]),
                        S = Zy(n[r++]),
                        I = Zy(n[r++]);
                    e.push("M", w, M, "L", w + S, M, "L", w + S, M + I, "L", w, M + I, "L", w, M) }
            o && e.push(o); for (var T = 0; s > T; T++) e.push(Zy(n[r++])) } return e.join(" ") }

    function Jy(t, e, n, i, r, a, o) { ze(pz), e && n && Ee(pz, n); var s = i.textRotation; if (r && s) { var l = i.textOrigin; "center" === l ? (a = r.width / 2 + r.x, o = r.height / 2 + r.y) : l && (a = l[0] + r.x, o = l[1] + r.y), pz[4] -= a, pz[5] -= o, Ne(pz, pz, s), pz[4] += a, pz[5] += o }
        jy(t, pz) }

    function tx(t, e, n) { return "right" === e ? t - n[1] : "center" === e ? t + n[3] / 2 - n[1] / 2 : t + n[3] }

    function ex(t, e, n, i) { qy(t, "dominant-baseline", "middle"), qy(t, "text-anchor", gz[e]), qy(t, "x", n), qy(t, "y", i) }

    function nx(t) { t && t.__textSvgEl && (t.__textSvgEl.parentNode && t.__textSvgEl.parentNode.removeChild(t.__textSvgEl), t.__textSvgEl = null, t.__tspanList = [], t.__text = null) }

    function ix() {}

    function rx(t, e) { for (var n = 0, i = e.length, r = 0, a = 0; i > n; n++) { var o = e[n]; if (o.removed) { for (var s = [], l = a; l < a + o.count; l++) s.push(l);
                o.indices = s, a += o.count } else { for (var s = [], l = r; l < r + o.count; l++) s.push(l);
                o.indices = s, r += o.count, o.added || (a += o.count) } } return e }

    function ax(t) { return { newPos: t.newPos, components: t.components.slice(0) } }

    function ox(t, e, n, i, r) { this._zrId = t, this._svgRoot = e, this._tagNames = "string" == typeof n ? [n] : n, this._markLabel = i, this._domName = r || "_dom", this.nextId = 0 }

    function sx(t, e) { ox.call(this, t, e, ["linearGradient", "radialGradient"], "__gradient_in_use__") }

    function lx(t, e) { ox.call(this, t, e, "clipPath", "__clippath_in_use__") }

    function ux(t, e) { ox.call(this, t, e, ["filter"], "__filter_in_use__", "_shadowDom") }

    function hx(t) { return t && (t.shadowBlur || t.shadowOffsetX || t.shadowOffsetY || t.textShadowBlur || t.textShadowOffsetX || t.textShadowOffsetY) }

    function cx(t) { return parseInt(t, 10) }

    function dx(t) { return t instanceof ia ? uz : t instanceof Di ? hz : t instanceof Jw ? cz : uz }

    function fx(t, e) { return e && t && e.parentNode !== t }

    function px(t, e, n) { if (fx(t, e) && n) { var i = n.nextSibling;
            i ? t.insertBefore(e, i) : t.appendChild(e) } }

    function gx(t, e) { if (fx(t, e)) { var n = t.firstChild;
            n ? t.insertBefore(e, n) : t.appendChild(e) } }

    function vx(t, e) { e && t && e.parentNode === t && t.removeChild(e) }

    function mx(t) { return t.__textSvgEl }

    function yx(t) { return t.__svgEl }

    function xx(t) { return function() { L_('In SVG mode painter not support method "' + t + '"') } }
    var _x = 2311,
        bx = function() { return _x++ },
        Mx = {};
    Mx = "object" == typeof wx && "function" == typeof wx.getSystemInfoSync ? { browser: {}, os: {}, node: !1, wxa: !0, canvasSupported: !0, svgSupported: !1, touchEventsSupported: !0, domSupported: !1 } : "undefined" == typeof document && "undefined" != typeof self ? { browser: {}, os: {}, node: !1, worker: !0, canvasSupported: !0, domSupported: !1 } : "undefined" == typeof navigator ? { browser: {}, os: {}, node: !0, worker: !1, canvasSupported: !0, svgSupported: !0, domSupported: !1 } : e(navigator.userAgent);
    var Sx = Mx,
        Ix = { "[object Function]": 1, "[object RegExp]": 1, "[object Date]": 1, "[object Error]": 1, "[object CanvasGradient]": 1, "[object CanvasPattern]": 1, "[object Image]": 1, "[object Canvas]": 1 },
        Tx = { "[object Int8Array]": 1, "[object Uint8Array]": 1, "[object Uint8ClampedArray]": 1, "[object Int16Array]": 1, "[object Uint16Array]": 1, "[object Int32Array]": 1, "[object Uint32Array]": 1, "[object Float32Array]": 1, "[object Float64Array]": 1 },
        Cx = Object.prototype.toString,
        Ax = Array.prototype,
        Dx = Ax.forEach,
        kx = Ax.filter,
        Px = Ax.slice,
        Lx = Ax.map,
        Ox = Ax.reduce,
        zx = {},
        Ex = function() { return zx.createCanvas() };
    zx.createCanvas = function() { return document.createElement("canvas") };
    var Rx, Bx = "__ec_primitive__";
    B.prototype = { constructor: B, get: function(t) { return this.data.hasOwnProperty(t) ? this.data[t] : null }, set: function(t, e) { return this.data[t] = e }, each: function(t, e) { void 0 !== e && (t = y(t, e)); for (var n in this.data) this.data.hasOwnProperty(n) && t(this.data[n], n) }, removeKey: function(t) { delete this.data[t] } };
    var Nx = (Object.freeze || Object)({ $override: n, clone: i, merge: r, mergeAll: a, extend: o, defaults: s, createCanvas: Ex, getContext: l, indexOf: u, inherits: h, mixin: c, isArrayLike: d, each: f, map: p, reduce: g, filter: v, find: m, bind: y, curry: x, isArray: _, isFunction: b, isString: w, isObject: M, isBuiltInObject: S, isTypedArray: I, isDom: T, eqNaN: C, retrieve: A, retrieve2: D, retrieve3: k, slice: P, normalizeCssArray: L, assert: O, trim: z, setAsPrimitive: E, isPrimitive: R, createHashMap: N, concatArray: V, noop: F }),
        Vx = "undefined" == typeof Float32Array ? Array : Float32Array,
        Fx = j,
        Hx = q,
        Gx = ee,
        Wx = ne,
        Zx = (Object.freeze || Object)({ create: H, copy: G, clone: W, set: Z, add: U, scaleAndAdd: X, sub: Y, len: j, length: Fx, lenSquare: q, lengthSquare: Hx, mul: K, div: $, dot: Q, scale: J, normalize: te, distance: ee, dist: Gx, distanceSquare: ne, distSquare: Wx, negate: ie, lerp: re, applyTransform: ae, min: oe, max: se });
    le.prototype = { constructor: le, _dragStart: function(t) { for (var e = t.target; e && !e.draggable;) e = e.parent;
            e && (this._draggingTarget = e, e.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this.dispatchToElement(ue(e, t), "dragstart", t.event)) }, _drag: function(t) { var e = this._draggingTarget; if (e) { var n = t.offsetX,
                    i = t.offsetY,
                    r = n - this._x,
                    a = i - this._y;
                this._x = n, this._y = i, e.drift(r, a, t), this.dispatchToElement(ue(e, t), "drag", t.event); var o = this.findHover(n, i, e).target,
                    s = this._dropTarget;
                this._dropTarget = o, e !== o && (s && o !== s && this.dispatchToElement(ue(s, t), "dragleave", t.event), o && o !== s && this.dispatchToElement(ue(o, t), "dragenter", t.event)) } }, _dragEnd: function(t) { var e = this._draggingTarget;
            e && (e.dragging = !1), this.dispatchToElement(ue(e, t), "dragend", t.event), this._dropTarget && this.dispatchToElement(ue(this._dropTarget, t), "drop", t.event), this._draggingTarget = null, this._dropTarget = null } };
    var Ux = Array.prototype.slice,
        Xx = function(t) { this._$handlers = {}, this._$eventProcessor = t };
    Xx.prototype = { constructor: Xx, one: function(t, e, n, i) { return ce(this, t, e, n, i, !0) }, on: function(t, e, n, i) { return ce(this, t, e, n, i, !1) }, isSilent: function(t) { var e = this._$handlers; return !e[t] || !e[t].length }, off: function(t, e) { var n = this._$handlers; if (!t) return this._$handlers = {}, this; if (e) { if (n[t]) { for (var i = [], r = 0, a = n[t].length; a > r; r++) n[t][r].h !== e && i.push(n[t][r]);
                    n[t] = i }
                n[t] && 0 === n[t].length && delete n[t] } else delete n[t]; return this }, trigger: function(t) { var e = this._$handlers[t],
                n = this._$eventProcessor; if (e) { var i = arguments,
                    r = i.length;
                r > 3 && (i = Ux.call(i, 1)); for (var a = e.length, o = 0; a > o;) { var s = e[o]; if (n && n.filter && null != s.query && !n.filter(t, s.query)) o++;
                    else { switch (r) {
                            case 1:
                                s.h.call(s.ctx); break;
                            case 2:
                                s.h.call(s.ctx, i[1]); break;
                            case 3:
                                s.h.call(s.ctx, i[1], i[2]); break;
                            default:
                                s.h.apply(s.ctx, i) }
                        s.one ? (e.splice(o, 1), a--) : o++ } } } return n && n.afterTrigger && n.afterTrigger(t), this }, triggerWithContext: function(t) { var e = this._$handlers[t],
                n = this._$eventProcessor; if (e) { var i = arguments,
                    r = i.length;
                r > 4 && (i = Ux.call(i, 1, i.length - 1)); for (var a = i[i.length - 1], o = e.length, s = 0; o > s;) { var l = e[s]; if (n && n.filter && null != l.query && !n.filter(t, l.query)) s++;
                    else { switch (r) {
                            case 1:
                                l.h.call(a); break;
                            case 2:
                                l.h.call(a, i[1]); break;
                            case 3:
                                l.h.call(a, i[1], i[2]); break;
                            default:
                                l.h.apply(a, i) }
                        l.one ? (e.splice(s, 1), o--) : s++ } } } return n && n.afterTrigger && n.afterTrigger(t), this } };
    var Yx = Math.log(2),
        jx = "___zrEVENTSAVED",
        qx = [],
        Kx = "undefined" != typeof window && !!window.addEventListener,
        $x = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
        Qx = [],
        Jx = Kx ? function(t) { t.preventDefault(), t.stopPropagation(), t.cancelBubble = !0 } : function(t) { t.returnValue = !1, t.cancelBubble = !0 },
        t_ = function() { this._track = [] };
    t_.prototype = { constructor: t_, recognize: function(t, e, n) { return this._doTrack(t, e, n), this._recognize(t) }, clear: function() { return this._track.length = 0, this }, _doTrack: function(t, e, n) { var i = t.touches; if (i) { for (var r = { points: [], touches: [], target: e, event: t }, a = 0, o = i.length; o > a; a++) { var s = i[a],
                        l = xe(n, s, {});
                    r.points.push([l.zrX, l.zrY]), r.touches.push(s) }
                this._track.push(r) } }, _recognize: function(t) { for (var e in e_)
                if (e_.hasOwnProperty(e)) { var n = e_[e](this._track, t); if (n) return n } } };
    var e_ = { pinch: function(t, e) { var n = t.length; if (n) { var i = (t[n - 1] || {}).points,
                        r = (t[n - 2] || {}).points || i; if (r && r.length > 1 && i && i.length > 1) { var a = Te(i) / Te(r);!isFinite(a) && (a = 1), e.pinchScale = a; var o = Ce(i); return e.pinchX = o[0], e.pinchY = o[1], { type: "pinch", target: t[0].target, event: e } } } } },
        n_ = "silent";
    ke.prototype.dispose = function() {};
    var i_ = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"],
        r_ = function(t, e, n, i) { Xx.call(this), this.storage = t, this.painter = e, this.painterRoot = i, n = n || new ke, this.proxy = null, this._hovered = {}, this._lastTouchMoment, this._lastX, this._lastY, this._gestureMgr, le.call(this), this.setHandlerProxy(n) };
    r_.prototype = { constructor: r_, setHandlerProxy: function(t) { this.proxy && this.proxy.dispose(), t && (f(i_, function(e) { t.on && t.on(e, this[e], this) }, this), t.handler = this), this.proxy = t }, mousemove: function(t) { var e = t.zrX,
                n = t.zrY,
                i = Le(this, e, n),
                r = this._hovered,
                a = r.target;
            a && !a.__zr && (r = this.findHover(r.x, r.y), a = r.target); var o = this._hovered = i ? { x: e, y: n } : this.findHover(e, n),
                s = o.target,
                l = this.proxy;
            l.setCursor && l.setCursor(s ? s.cursor : "default"), a && s !== a && this.dispatchToElement(r, "mouseout", t), this.dispatchToElement(o, "mousemove", t), s && s !== a && this.dispatchToElement(o, "mouseover", t) }, mouseout: function(t) { var e = t.zrEventControl,
                n = t.zrIsToLocalDOM; "only_globalout" !== e && this.dispatchToElement(this._hovered, "mouseout", t), "no_globalout" !== e && !n && this.trigger("globalout", { type: "globalout", event: t }) }, resize: function() { this._hovered = {} }, dispatch: function(t, e) { var n = this[t];
            n && n.call(this, e) }, dispose: function() { this.proxy.dispose(), this.storage = this.proxy = this.painter = null }, setCursorStyle: function(t) { var e = this.proxy;
            e.setCursor && e.setCursor(t) }, dispatchToElement: function(t, e, n) { t = t || {}; var i = t.target; if (!i || !i.silent) { for (var r = "on" + e, a = Ae(e, t, n); i && (i[r] && (a.cancelBubble = i[r].call(i, a)), i.trigger(e, a), i = i.parent, !a.cancelBubble););
                a.cancelBubble || (this.trigger(e, a), this.painter && this.painter.eachOtherLayer(function(t) { "function" == typeof t[r] && t[r].call(t, a), t.trigger && t.trigger(e, a) })) } }, findHover: function(t, e, n) { for (var i = this.storage.getDisplayList(), r = { x: t, y: e }, a = i.length - 1; a >= 0; a--) { var o; if (i[a] !== n && !i[a].ignore && (o = Pe(i[a], t, e)) && (!r.topTarget && (r.topTarget = i[a]), o !== n_)) { r.target = i[a]; break } } return r }, processGesture: function(t, e) { this._gestureMgr || (this._gestureMgr = new t_); var n = this._gestureMgr; "start" === e && n.clear(); var i = n.recognize(t, this.findHover(t.zrX, t.zrY, null).target, this.proxy.dom); if ("end" === e && n.clear(), i) { var r = i.type;
                t.gestureEvent = r, this.dispatchToElement({ target: i.target }, r, i.event) } } }, f(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(t) { r_.prototype[t] = function(e) { var n, i, r = e.zrX,
                a = e.zrY,
                o = Le(this, r, a); if ("mouseup" === t && o || (n = this.findHover(r, a), i = n.target), "mousedown" === t) this._downEl = i, this._downPoint = [e.zrX, e.zrY], this._upEl = i;
            else if ("mouseup" === t) this._upEl = i;
            else if ("click" === t) { if (this._downEl !== this._upEl || !this._downPoint || Gx(this._downPoint, [e.zrX, e.zrY]) > 4) return;
                this._downPoint = null }
            this.dispatchToElement(n, t, e) } }), c(r_, Xx), c(r_, le);
    var a_ = "undefined" == typeof Float32Array ? Array : Float32Array,
        o_ = (Object.freeze || Object)({ create: Oe, identity: ze, copy: Ee, mul: Re, translate: Be, rotate: Ne, scale: Ve, invert: Fe, clone: He }),
        s_ = ze,
        l_ = 5e-5,
        u_ = function(t) { t = t || {}, t.position || (this.position = [0, 0]), null == t.rotation && (this.rotation = 0), t.scale || (this.scale = [1, 1]), this.origin = this.origin || null },
        h_ = u_.prototype;
    h_.transform = null, h_.needLocalTransform = function() { return Ge(this.rotation) || Ge(this.position[0]) || Ge(this.position[1]) || Ge(this.scale[0] - 1) || Ge(this.scale[1] - 1) };
    var c_ = [];
    h_.updateTransform = function() { var t = this.parent,
            e = t && t.transform,
            n = this.needLocalTransform(),
            i = this.transform; if (!n && !e) return void(i && s_(i));
        i = i || Oe(), n ? this.getLocalTransform(i) : s_(i), e && (n ? Re(i, t.transform, i) : Ee(i, t.transform)), this.transform = i; var r = this.globalScaleRatio; if (null != r && 1 !== r) { this.getGlobalScale(c_); var a = c_[0] < 0 ? -1 : 1,
                o = c_[1] < 0 ? -1 : 1,
                s = ((c_[0] - a) * r + a) / c_[0] || 0,
                l = ((c_[1] - o) * r + o) / c_[1] || 0;
            i[0] *= s, i[1] *= s, i[2] *= l, i[3] *= l }
        this.invTransform = this.invTransform || Oe(), Fe(this.invTransform, i) }, h_.getLocalTransform = function(t) { return u_.getLocalTransform(this, t) }, h_.setTransform = function(t) { var e = this.transform,
            n = t.dpr || 1;
        e ? t.setTransform(n * e[0], n * e[1], n * e[2], n * e[3], n * e[4], n * e[5]) : t.setTransform(n, 0, 0, n, 0, 0) }, h_.restoreTransform = function(t) { var e = t.dpr || 1;
        t.setTransform(e, 0, 0, e, 0, 0) };
    var d_ = [],
        f_ = Oe();
    h_.setLocalTransform = function(t) { if (t) { var e = t[0] * t[0] + t[1] * t[1],
                n = t[2] * t[2] + t[3] * t[3],
                i = this.position,
                r = this.scale;
            Ge(e - 1) && (e = Math.sqrt(e)), Ge(n - 1) && (n = Math.sqrt(n)), t[0] < 0 && (e = -e), t[3] < 0 && (n = -n), i[0] = t[4], i[1] = t[5], r[0] = e, r[1] = n, this.rotation = Math.atan2(-t[1] / n, t[0] / e) } }, h_.decomposeTransform = function() { if (this.transform) { var t = this.parent,
                e = this.transform;
            t && t.transform && (Re(d_, t.invTransform, e), e = d_); var n = this.origin;
            n && (n[0] || n[1]) && (f_[4] = n[0], f_[5] = n[1], Re(d_, e, f_), d_[4] -= n[0], d_[5] -= n[1], e = d_), this.setLocalTransform(e) } }, h_.getGlobalScale = function(t) { var e = this.transform; return t = t || [], e ? (t[0] = Math.sqrt(e[0] * e[0] + e[1] * e[1]), t[1] = Math.sqrt(e[2] * e[2] + e[3] * e[3]), e[0] < 0 && (t[0] = -t[0]), e[3] < 0 && (t[1] = -t[1]), t) : (t[0] = 1, t[1] = 1, t) }, h_.transformCoordToLocal = function(t, e) { var n = [t, e],
            i = this.invTransform; return i && ae(n, n, i), n }, h_.transformCoordToGlobal = function(t, e) { var n = [t, e],
            i = this.transform; return i && ae(n, n, i), n }, u_.getLocalTransform = function(t, e) { e = e || [], s_(e); var n = t.origin,
            i = t.scale || [1, 1],
            r = t.rotation || 0,
            a = t.position || [0, 0]; return n && (e[4] -= n[0], e[5] -= n[1]), Ve(e, e, i), r && Ne(e, e, r), n && (e[4] += n[0], e[5] += n[1]), e[4] += a[0], e[5] += a[1], e };
    var p_ = { linear: function(t) { return t }, quadraticIn: function(t) { return t * t }, quadraticOut: function(t) { return t * (2 - t) }, quadraticInOut: function(t) { return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1) }, cubicIn: function(t) { return t * t * t }, cubicOut: function(t) { return --t * t * t + 1 }, cubicInOut: function(t) { return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2) }, quarticIn: function(t) { return t * t * t * t }, quarticOut: function(t) { return 1 - --t * t * t * t }, quarticInOut: function(t) { return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2) }, quinticIn: function(t) { return t * t * t * t * t }, quinticOut: function(t) { return --t * t * t * t * t + 1 }, quinticInOut: function(t) { return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2) }, sinusoidalIn: function(t) { return 1 - Math.cos(t * Math.PI / 2) }, sinusoidalOut: function(t) { return Math.sin(t * Math.PI / 2) }, sinusoidalInOut: function(t) { return .5 * (1 - Math.cos(Math.PI * t)) }, exponentialIn: function(t) { return 0 === t ? 0 : Math.pow(1024, t - 1) }, exponentialOut: function(t) { return 1 === t ? 1 : 1 - Math.pow(2, -10 * t) }, exponentialInOut: function(t) { return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (-Math.pow(2, -10 * (t - 1)) + 2) }, circularIn: function(t) { return 1 - Math.sqrt(1 - t * t) }, circularOut: function(t) { return Math.sqrt(1 - --t * t) }, circularInOut: function(t) { return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1) }, elasticIn: function(t) { var e, n = .1,
                i = .4; return 0 === t ? 0 : 1 === t ? 1 : (!n || 1 > n ? (n = 1, e = i / 4) : e = i * Math.asin(1 / n) / (2 * Math.PI), -(n * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / i))) }, elasticOut: function(t) { var e, n = .1,
                i = .4; return 0 === t ? 0 : 1 === t ? 1 : (!n || 1 > n ? (n = 1, e = i / 4) : e = i * Math.asin(1 / n) / (2 * Math.PI), n * Math.pow(2, -10 * t) * Math.sin(2 * (t - e) * Math.PI / i) + 1) }, elasticInOut: function(t) { var e, n = .1,
                i = .4; return 0 === t ? 0 : 1 === t ? 1 : (!n || 1 > n ? (n = 1, e = i / 4) : e = i * Math.asin(1 / n) / (2 * Math.PI), (t *= 2) < 1 ? -.5 * n * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / i) : n * Math.pow(2, -10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / i) * .5 + 1) }, backIn: function(t) { var e = 1.70158; return t * t * ((e + 1) * t - e) }, backOut: function(t) { var e = 1.70158; return --t * t * ((e + 1) * t + e) + 1 }, backInOut: function(t) { var e = 2.5949095; return (t *= 2) < 1 ? .5 * t * t * ((e + 1) * t - e) : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2) }, bounceIn: function(t) { return 1 - p_.bounceOut(1 - t) }, bounceOut: function(t) { return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375 }, bounceInOut: function(t) { return .5 > t ? .5 * p_.bounceIn(2 * t) : .5 * p_.bounceOut(2 * t - 1) + .5 } };
    We.prototype = { constructor: We, step: function(t, e) { if (this._initialized || (this._startTime = t + this._delay, this._initialized = !0), this._paused) return void(this._pausedTime += e); var n = (t - this._startTime - this._pausedTime) / this._life; if (!(0 > n)) { n = Math.min(n, 1); var i = this.easing,
                    r = "string" == typeof i ? p_[i] : i,
                    a = "function" == typeof r ? r(n) : n; return this.fire("frame", a), 1 === n ? this.loop ? (this.restart(t), "restart") : (this._needsRemove = !0, "destroy") : null } }, restart: function(t) { var e = (t - this._startTime - this._pausedTime) % this._life;
            this._startTime = t - e + this.gap, this._pausedTime = 0, this._needsRemove = !1 }, fire: function(t, e) { t = "on" + t, this[t] && this[t](this._target, e) }, pause: function() { this._paused = !0 }, resume: function() { this._paused = !1 } };
    var g_ = function() { this.head = null, this.tail = null, this._len = 0 },
        v_ = g_.prototype;
    v_.insert = function(t) { var e = new m_(t); return this.insertEntry(e), e }, v_.insertEntry = function(t) { this.head ? (this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++ }, v_.remove = function(t) { var e = t.prev,
            n = t.next;
        e ? e.next = n : this.head = n, n ? n.prev = e : this.tail = e, t.next = t.prev = null, this._len-- }, v_.len = function() { return this._len }, v_.clear = function() { this.head = this.tail = null, this._len = 0 };
    var m_ = function(t) { this.value = t, this.next, this.prev },
        y_ = function(t) { this._list = new g_, this._map = {}, this._maxSize = t || 10, this._lastRemovedEntry = null },
        x_ = y_.prototype;
    x_.put = function(t, e) { var n = this._list,
            i = this._map,
            r = null; if (null == i[t]) { var a = n.len(),
                o = this._lastRemovedEntry; if (a >= this._maxSize && a > 0) { var s = n.head;
                n.remove(s), delete i[s.key], r = s.value, this._lastRemovedEntry = s }
            o ? o.value = e : o = new m_(e), o.key = t, n.insertEntry(o), i[t] = o } return r }, x_.get = function(t) { var e = this._map[t],
            n = this._list; return null != e ? (e !== n.tail && (n.remove(e), n.insertEntry(e)), e.value) : void 0 }, x_.clear = function() { this._list.clear(), this._map = {} };
    var __ = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] },
        b_ = new y_(20),
        w_ = null,
        M_ = on,
        S_ = sn,
        I_ = (Object.freeze || Object)({ parse: tn, lift: rn, toHex: an, fastLerp: on, fastMapToColor: M_, lerp: sn, mapToColor: S_, modifyHSL: ln, modifyAlpha: un, stringify: hn }),
        T_ = Array.prototype.slice,
        C_ = function(t, e, n, i) { this._tracks = {}, this._target = t, this._loop = e || !1, this._getter = n || cn, this._setter = i || dn, this._clipCount = 0, this._delay = 0, this._doneList = [], this._onframeList = [], this._clipList = [] };
    C_.prototype = { when: function(t, e) { var n = this._tracks; for (var i in e)
                if (e.hasOwnProperty(i)) { if (!n[i]) { n[i] = []; var r = this._getter(this._target, i); if (null == r) continue;
                        0 !== t && n[i].push({ time: 0, value: _n(r) }) }
                    n[i].push({ time: t, value: e[i] }) }
            return this }, during: function(t) { return this._onframeList.push(t), this }, pause: function() { for (var t = 0; t < this._clipList.length; t++) this._clipList[t].pause();
            this._paused = !0 }, resume: function() { for (var t = 0; t < this._clipList.length; t++) this._clipList[t].resume();
            this._paused = !1 }, isPaused: function() { return !!this._paused }, _doneCallback: function() { this._tracks = {}, this._clipList.length = 0; for (var t = this._doneList, e = t.length, n = 0; e > n; n++) t[n].call(this) }, start: function(t, e) { var n, i = this,
                r = 0,
                a = function() { r--, r || i._doneCallback() }; for (var o in this._tracks)
                if (this._tracks.hasOwnProperty(o)) { var s = Mn(this, t, a, this._tracks[o], o, e);
                    s && (this._clipList.push(s), r++, this.animation && this.animation.addClip(s), n = s) }
            if (n) { var l = n.onframe;
                n.onframe = function(t, e) { l(t, e); for (var n = 0; n < i._onframeList.length; n++) i._onframeList[n](t, e) } } return r || this._doneCallback(), this }, stop: function(t) { for (var e = this._clipList, n = this.animation, i = 0; i < e.length; i++) { var r = e[i];
                t && r.onframe(this._target, 1), n && n.removeClip(r) }
            e.length = 0 }, delay: function(t) { return this._delay = t, this }, done: function(t) { return t && this._doneList.push(t), this }, getClips: function() { return this._clipList } };
    var A_ = 1;
    "undefined" != typeof window && (A_ = Math.max(window.devicePixelRatio || 1, 1));
    var D_ = 0,
        k_ = A_,
        P_ = function() {};
    1 === D_ && (P_ = console.error);
    var L_ = P_,
        O_ = function() { this.animators = [] };
    O_.prototype = { constructor: O_, animate: function(t, e) { var n, i = !1,
                r = this,
                a = this.__zr; if (t) { var o = t.split("."),
                    s = r;
                i = "shape" === o[0]; for (var l = 0, h = o.length; h > l; l++) s && (s = s[o[l]]);
                s && (n = s) } else n = r; if (!n) return void L_('Property "' + t + '" is not existed in element ' + r.id); var c = r.animators,
                d = new C_(n, e); return d.during(function() { r.dirty(i) }).done(function() { c.splice(u(c, d), 1) }), c.push(d), a && a.animation.addAnimator(d), d }, stopAnimation: function(t) { for (var e = this.animators, n = e.length, i = 0; n > i; i++) e[i].stop(t); return e.length = 0, this }, animateTo: function(t, e, n, i, r, a) { Sn(this, t, e, n, i, r, a) }, animateFrom: function(t, e, n, i, r, a) { Sn(this, t, e, n, i, r, a, !0) } };
    var z_ = function(t) { u_.call(this, t), Xx.call(this, t), O_.call(this, t), this.id = t.id || bx() };
    z_.prototype = {
        type: "element",
        name: "",
        __zr: null,
        ignore: !1,
        clipPath: null,
        isGroup: !1,
        drift: function(t, e) { switch (this.draggable) {
                case "horizontal":
                    e = 0; break;
                case "vertical":
                    t = 0 } var n = this.transform;
            n || (n = this.transform = [1, 0, 0, 1, 0, 0]), n[4] += t, n[5] += e, this.decomposeTransform(), this.dirty(!1) },
        beforeUpdate: function() {},
        afterUpdate: function() {},
        update: function() { this.updateTransform() },
        traverse: function() {},
        attrKV: function(t, e) { if ("position" === t || "scale" === t || "origin" === t) { if (e) { var n = this[t];
                    n || (n = this[t] = []), n[0] = e[0], n[1] = e[1] } } else this[t] = e },
        hide: function() {
            this.ignore = !0, this.__zr && this.__zr.refresh()
        },
        show: function() { this.ignore = !1, this.__zr && this.__zr.refresh() },
        attr: function(t, e) { if ("string" == typeof t) this.attrKV(t, e);
            else if (M(t))
                for (var n in t) t.hasOwnProperty(n) && this.attrKV(n, t[n]); return this.dirty(!1), this },
        setClipPath: function(t) { var e = this.__zr;
            e && t.addSelfToZr(e), this.clipPath && this.clipPath !== t && this.removeClipPath(), this.clipPath = t, t.__zr = e, t.__clipTarget = this, this.dirty(!1) },
        removeClipPath: function() { var t = this.clipPath;
            t && (t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__clipTarget = null, this.clipPath = null, this.dirty(!1)) },
        addSelfToZr: function(t) { this.__zr = t; var e = this.animators; if (e)
                for (var n = 0; n < e.length; n++) t.animation.addAnimator(e[n]);
            this.clipPath && this.clipPath.addSelfToZr(t) },
        removeSelfFromZr: function(t) { this.__zr = null; var e = this.animators; if (e)
                for (var n = 0; n < e.length; n++) t.animation.removeAnimator(e[n]);
            this.clipPath && this.clipPath.removeSelfFromZr(t) }
    }, c(z_, O_), c(z_, u_), c(z_, Xx);
    var E_ = ae,
        R_ = Math.min,
        B_ = Math.max;
    Cn.prototype = { constructor: Cn, union: function(t) { var e = R_(t.x, this.x),
                n = R_(t.y, this.y);
            this.width = B_(t.x + t.width, this.x + this.width) - e, this.height = B_(t.y + t.height, this.y + this.height) - n, this.x = e, this.y = n }, applyTransform: function() { var t = [],
                e = [],
                n = [],
                i = []; return function(r) { if (r) { t[0] = n[0] = this.x, t[1] = i[1] = this.y, e[0] = i[0] = this.x + this.width, e[1] = n[1] = this.y + this.height, E_(t, t, r), E_(e, e, r), E_(n, n, r), E_(i, i, r), this.x = R_(t[0], e[0], n[0], i[0]), this.y = R_(t[1], e[1], n[1], i[1]); var a = B_(t[0], e[0], n[0], i[0]),
                        o = B_(t[1], e[1], n[1], i[1]);
                    this.width = a - this.x, this.height = o - this.y } } }(), calculateTransform: function(t) { var e = this,
                n = t.width / e.width,
                i = t.height / e.height,
                r = Oe(); return Be(r, r, [-e.x, -e.y]), Ve(r, r, [n, i]), Be(r, r, [t.x, t.y]), r }, intersect: function(t) { if (!t) return !1;
            t instanceof Cn || (t = Cn.create(t)); var e = this,
                n = e.x,
                i = e.x + e.width,
                r = e.y,
                a = e.y + e.height,
                o = t.x,
                s = t.x + t.width,
                l = t.y,
                u = t.y + t.height; return !(o > i || n > s || l > a || r > u) }, contain: function(t, e) { var n = this; return t >= n.x && t <= n.x + n.width && e >= n.y && e <= n.y + n.height }, clone: function() { return new Cn(this.x, this.y, this.width, this.height) }, copy: function(t) { this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height }, plain: function() { return { x: this.x, y: this.y, width: this.width, height: this.height } } }, Cn.create = function(t) { return new Cn(t.x, t.y, t.width, t.height) };
    var N_ = function(t) { t = t || {}, z_.call(this, t); for (var e in t) t.hasOwnProperty(e) && (this[e] = t[e]);
        this._children = [], this.__storage = null, this.__dirty = !0 };
    N_.prototype = { constructor: N_, isGroup: !0, type: "group", silent: !1, children: function() { return this._children.slice() }, childAt: function(t) { return this._children[t] }, childOfName: function(t) { for (var e = this._children, n = 0; n < e.length; n++)
                if (e[n].name === t) return e[n] }, childCount: function() { return this._children.length }, add: function(t) { return t && t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), this }, addBefore: function(t, e) { if (t && t !== this && t.parent !== this && e && e.parent === this) { var n = this._children,
                    i = n.indexOf(e);
                i >= 0 && (n.splice(i, 0, t), this._doAdd(t)) } return this }, _doAdd: function(t) { t.parent && t.parent.remove(t), t.parent = this; var e = this.__storage,
                n = this.__zr;
            e && e !== t.__storage && (e.addToStorage(t), t instanceof N_ && t.addChildrenToStorage(e)), n && n.refresh() }, remove: function(t) { var e = this.__zr,
                n = this.__storage,
                i = this._children,
                r = u(i, t); return 0 > r ? this : (i.splice(r, 1), t.parent = null, n && (n.delFromStorage(t), t instanceof N_ && t.delChildrenFromStorage(n)), e && e.refresh(), this) }, removeAll: function() { var t, e, n = this._children,
                i = this.__storage; for (e = 0; e < n.length; e++) t = n[e], i && (i.delFromStorage(t), t instanceof N_ && t.delChildrenFromStorage(i)), t.parent = null; return n.length = 0, this }, eachChild: function(t, e) { for (var n = this._children, i = 0; i < n.length; i++) { var r = n[i];
                t.call(e, r, i) } return this }, traverse: function(t, e) { for (var n = 0; n < this._children.length; n++) { var i = this._children[n];
                t.call(e, i), "group" === i.type && i.traverse(t, e) } return this }, addChildrenToStorage: function(t) { for (var e = 0; e < this._children.length; e++) { var n = this._children[e];
                t.addToStorage(n), n instanceof N_ && n.addChildrenToStorage(t) } }, delChildrenFromStorage: function(t) { for (var e = 0; e < this._children.length; e++) { var n = this._children[e];
                t.delFromStorage(n), n instanceof N_ && n.delChildrenFromStorage(t) } }, dirty: function() { return this.__dirty = !0, this.__zr && this.__zr.refresh(), this }, getBoundingRect: function(t) { for (var e = null, n = new Cn(0, 0, 0, 0), i = t || this._children, r = [], a = 0; a < i.length; a++) { var o = i[a]; if (!o.ignore && !o.invisible) { var s = o.getBoundingRect(),
                        l = o.getLocalTransform(r);
                    l ? (n.copy(s), n.applyTransform(l), e = e || n.clone(), e.union(n)) : (e = e || s.clone(), e.union(s)) } } return e || n } }, h(N_, z_);
    var V_ = 32,
        F_ = 7,
        H_ = function() { this._roots = [], this._displayList = [], this._displayListLen = 0 };
    H_.prototype = { constructor: H_, traverse: function(t, e) { for (var n = 0; n < this._roots.length; n++) this._roots[n].traverse(t, e) }, getDisplayList: function(t, e) { return e = e || !1, t && this.updateDisplayList(e), this._displayList }, updateDisplayList: function(t) { this._displayListLen = 0; for (var e = this._roots, n = this._displayList, i = 0, r = e.length; r > i; i++) this._updateAndAddDisplayable(e[i], null, t);
            n.length = this._displayListLen, Sx.canvasSupported && En(n, Rn) }, _updateAndAddDisplayable: function(t, e, n) { if (!t.ignore || n) { t.beforeUpdate(), t.__dirty && t.update(), t.afterUpdate(); var i = t.clipPath; if (i) { e = e ? e.slice() : []; for (var r = i, a = t; r;) r.parent = a, r.updateTransform(), e.push(r), a = r, r = r.clipPath } if (t.isGroup) { for (var o = t._children, s = 0; s < o.length; s++) { var l = o[s];
                        t.__dirty && (l.__dirty = !0), this._updateAndAddDisplayable(l, e, n) }
                    t.__dirty = !1 } else t.__clipPaths = e, this._displayList[this._displayListLen++] = t } }, addRoot: function(t) { t.__storage !== this && (t instanceof N_ && t.addChildrenToStorage(this), this.addToStorage(t), this._roots.push(t)) }, delRoot: function(t) { if (null == t) { for (var e = 0; e < this._roots.length; e++) { var n = this._roots[e];
                    n instanceof N_ && n.delChildrenFromStorage(this) } return this._roots = [], this._displayList = [], void(this._displayListLen = 0) } if (t instanceof Array)
                for (var e = 0, i = t.length; i > e; e++) this.delRoot(t[e]);
            else { var r = u(this._roots, t);
                r >= 0 && (this.delFromStorage(t), this._roots.splice(r, 1), t instanceof N_ && t.delChildrenFromStorage(this)) } }, addToStorage: function(t) { return t && (t.__storage = this, t.dirty(!1)), this }, delFromStorage: function(t) { return t && (t.__storage = null), this }, dispose: function() { this._renderList = this._roots = null }, displayableSortFunc: Rn };
    var G_ = { shadowBlur: 1, shadowOffsetX: 1, shadowOffsetY: 1, textShadowBlur: 1, textShadowOffsetX: 1, textShadowOffsetY: 1, textBoxShadowBlur: 1, textBoxShadowOffsetX: 1, textBoxShadowOffsetY: 1 },
        W_ = function(t, e, n) { return G_.hasOwnProperty(e) ? n *= t.dpr : n },
        Z_ = { NONE: 0, STYLE_BIND: 1, PLAIN_TEXT: 2 },
        U_ = 9,
        X_ = [
            ["shadowBlur", 0],
            ["shadowOffsetX", 0],
            ["shadowOffsetY", 0],
            ["shadowColor", "#000"],
            ["lineCap", "butt"],
            ["lineJoin", "miter"],
            ["miterLimit", 10]
        ],
        Y_ = function(t) { this.extendFrom(t, !1) };
    Y_.prototype = { constructor: Y_, fill: "#000", stroke: null, opacity: 1, fillOpacity: null, strokeOpacity: null, lineDash: null, lineDashOffset: 0, shadowBlur: 0, shadowOffsetX: 0, shadowOffsetY: 0, lineWidth: 1, strokeNoScale: !1, text: null, font: null, textFont: null, fontStyle: null, fontWeight: null, fontSize: null, fontFamily: null, textTag: null, textFill: "#000", textStroke: null, textWidth: null, textHeight: null, textStrokeWidth: 0, textLineHeight: null, textPosition: "inside", textRect: null, textOffset: null, textAlign: null, textVerticalAlign: null, textDistance: 5, textShadowColor: "transparent", textShadowBlur: 0, textShadowOffsetX: 0, textShadowOffsetY: 0, textBoxShadowColor: "transparent", textBoxShadowBlur: 0, textBoxShadowOffsetX: 0, textBoxShadowOffsetY: 0, transformText: !1, textRotation: 0, textOrigin: null, textBackgroundColor: null, textBorderColor: null, textBorderWidth: 0, textBorderRadius: 0, textPadding: null, rich: null, truncate: null, blend: null, bind: function(t, e, n) { var i = this,
                r = n && n.style,
                a = !r || t.__attrCachedBy !== Z_.STYLE_BIND;
            t.__attrCachedBy = Z_.STYLE_BIND; for (var o = 0; o < X_.length; o++) { var s = X_[o],
                    l = s[0];
                (a || i[l] !== r[l]) && (t[l] = W_(t, l, i[l] || s[1])) } if ((a || i.fill !== r.fill) && (t.fillStyle = i.fill), (a || i.stroke !== r.stroke) && (t.strokeStyle = i.stroke), (a || i.opacity !== r.opacity) && (t.globalAlpha = null == i.opacity ? 1 : i.opacity), (a || i.blend !== r.blend) && (t.globalCompositeOperation = i.blend || "source-over"), this.hasStroke()) { var u = i.lineWidth;
                t.lineWidth = u / (this.strokeNoScale && e && e.getLineScale ? e.getLineScale() : 1) } }, hasFill: function() { var t = this.fill; return null != t && "none" !== t }, hasStroke: function() { var t = this.stroke; return null != t && "none" !== t && this.lineWidth > 0 }, extendFrom: function(t, e) { if (t)
                for (var n in t) !t.hasOwnProperty(n) || e !== !0 && (e === !1 ? this.hasOwnProperty(n) : null == t[n]) || (this[n] = t[n]) }, set: function(t, e) { "string" == typeof t ? this[t] = e : this.extendFrom(t, !0) }, clone: function() { var t = new this.constructor; return t.extendFrom(this, !0), t }, getGradient: function(t, e, n) { for (var i = "radial" === e.type ? Nn : Bn, r = i(t, e, n), a = e.colorStops, o = 0; o < a.length; o++) r.addColorStop(a[o].offset, a[o].color); return r } };
    for (var j_ = Y_.prototype, q_ = 0; q_ < X_.length; q_++) { var K_ = X_[q_];
        K_[0] in j_ || (j_[K_[0]] = K_[1]) }
    Y_.getGradient = j_.getGradient;
    var $_ = function(t, e) { this.image = t, this.repeat = e, this.type = "pattern" };
    $_.prototype.getCanvasPattern = function(t) { return t.createPattern(this.image, this.repeat || "repeat") };
    var Q_ = function(t, e, n) { var i;
        n = n || k_, "string" == typeof t ? i = Fn(t, e, n) : M(t) && (i = t, t = i.id), this.id = t, this.dom = i; var r = i.style;
        r && (i.onselectstart = Vn, r["-webkit-user-select"] = "none", r["user-select"] = "none", r["-webkit-touch-callout"] = "none", r["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)", r.padding = 0, r.margin = 0, r["border-width"] = 0), this.domBack = null, this.ctxBack = null, this.painter = e, this.config = null, this.clearColor = 0, this.motionBlur = !1, this.lastFrameAlpha = .7, this.dpr = n };
    Q_.prototype = { constructor: Q_, __dirty: !0, __used: !1, __drawIndex: 0, __startIndex: 0, __endIndex: 0, incremental: !1, getElementCount: function() { return this.__endIndex - this.__startIndex }, initContext: function() { this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr }, createBackBuffer: function() { var t = this.dpr;
            this.domBack = Fn("back-" + this.id, this.painter, t), this.ctxBack = this.domBack.getContext("2d"), 1 !== t && this.ctxBack.scale(t, t) }, resize: function(t, e) { var n = this.dpr,
                i = this.dom,
                r = i.style,
                a = this.domBack;
            r && (r.width = t + "px", r.height = e + "px"), i.width = t * n, i.height = e * n, a && (a.width = t * n, a.height = e * n, 1 !== n && this.ctxBack.scale(n, n)) }, clear: function(t, e) { var n = this.dom,
                i = this.ctx,
                r = n.width,
                a = n.height,
                e = e || this.clearColor,
                o = this.motionBlur && !t,
                s = this.lastFrameAlpha,
                l = this.dpr; if (o && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(n, 0, 0, r / l, a / l)), i.clearRect(0, 0, r, a), e && "transparent" !== e) { var u;
                e.colorStops ? (u = e.__canvasGradient || Y_.getGradient(i, e, { x: 0, y: 0, width: r, height: a }), e.__canvasGradient = u) : e.image && (u = $_.prototype.getCanvasPattern.call(e, i)), i.save(), i.fillStyle = u || e, i.fillRect(0, 0, r, a), i.restore() } if (o) { var h = this.domBack;
                i.save(), i.globalAlpha = s, i.drawImage(h, 0, 0, r, a), i.restore() } } };
    var J_ = "undefined" != typeof window && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(t) { setTimeout(t, 16) },
        tb = new y_(50),
        eb = {},
        nb = 0,
        ib = 5e3,
        rb = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g,
        ab = "12px sans-serif",
        ob = {};
    ob.measureText = function(t, e) { var n = l(); return n.font = e || ab, n.measureText(t) };
    var sb = ab,
        lb = { left: 1, right: 1, center: 1 },
        ub = { top: 1, bottom: 1, middle: 1 },
        hb = [
            ["textShadowBlur", "shadowBlur", 0],
            ["textShadowOffsetX", "shadowOffsetX", 0],
            ["textShadowOffsetY", "shadowOffsetY", 0],
            ["textShadowColor", "shadowColor", "transparent"]
        ],
        cb = {},
        db = {},
        fb = new Cn,
        pb = function() {};
    pb.prototype = { constructor: pb, drawRectText: function(t, e) { var n = this.style;
            e = n.textRect || e, this.__dirty && hi(n, !0); var i = n.text; if (null != i && (i += ""), Ci(i, n)) { t.save(); var r = this.transform;
                n.transformText ? this.setTransform(t) : r && (fb.copy(e), fb.applyTransform(r), e = fb), di(this, t, i, n, e, U_), t.restore() } } }, Ai.prototype = { constructor: Ai, type: "displayable", __dirty: !0, invisible: !1, z: 0, z2: 0, zlevel: 0, draggable: !1, dragging: !1, silent: !1, culling: !1, cursor: "pointer", rectHover: !1, progressive: !1, incremental: !1, globalScaleRatio: 1, beforeBrush: function() {}, afterBrush: function() {}, brush: function() {}, getBoundingRect: function() {}, contain: function(t, e) { return this.rectContain(t, e) }, traverse: function(t, e) { t.call(e, this) }, rectContain: function(t, e) { var n = this.transformCoordToLocal(t, e),
                i = this.getBoundingRect(); return i.contain(n[0], n[1]) }, dirty: function() { this.__dirty = this.__dirtyText = !0, this._rect = null, this.__zr && this.__zr.refresh() }, animateStyle: function(t) { return this.animate("style", t) }, attrKV: function(t, e) { "style" !== t ? z_.prototype.attrKV.call(this, t, e) : this.style.set(e) }, setStyle: function(t, e) { return this.style.set(t, e), this.dirty(!1), this }, useStyle: function(t) { return this.style = new Y_(t, this), this.dirty(!1), this }, calculateTextPosition: null }, h(Ai, z_), c(Ai, pb), Di.prototype = { constructor: Di, type: "image", brush: function(t, e) { var n = this.style,
                i = n.image;
            n.bind(t, this, e); var r = this._image = Gn(i, this._image, this, this.onload); if (r && Zn(r)) { var a = n.x || 0,
                    o = n.y || 0,
                    s = n.width,
                    l = n.height,
                    u = r.width / r.height; if (null == s && null != l ? s = l * u : null == l && null != s ? l = s / u : null == s && null == l && (s = r.width, l = r.height), this.setTransform(t), n.sWidth && n.sHeight) { var h = n.sx || 0,
                        c = n.sy || 0;
                    t.drawImage(r, h, c, n.sWidth, n.sHeight, a, o, s, l) } else if (n.sx && n.sy) { var h = n.sx,
                        c = n.sy,
                        d = s - h,
                        f = l - c;
                    t.drawImage(r, h, c, d, f, a, o, s, l) } else t.drawImage(r, a, o, s, l);
                null != n.text && (this.restoreTransform(t), this.drawRectText(t, this.getBoundingRect())) } }, getBoundingRect: function() { var t = this.style; return this._rect || (this._rect = new Cn(t.x || 0, t.y || 0, t.width || 0, t.height || 0)), this._rect } }, h(Di, Ai);
    var gb = 1e5,
        vb = 314159,
        mb = .01,
        yb = .001,
        xb = new Cn(0, 0, 0, 0),
        _b = new Cn(0, 0, 0, 0),
        bb = function(t, e, n) { this.type = "canvas"; var i = !t.nodeName || "CANVAS" === t.nodeName.toUpperCase();
            this._opts = n = o({}, n || {}), this.dpr = n.devicePixelRatio || k_, this._singleCanvas = i, this.root = t; var r = t.style;
            r && (r["-webkit-tap-highlight-color"] = "transparent", r["-webkit-user-select"] = r["user-select"] = r["-webkit-touch-callout"] = "none", t.innerHTML = ""), this.storage = e; var a = this._zlevelList = [],
                s = this._layers = {}; if (this._layerConfig = {}, this._needsManuallyCompositing = !1, i) { var l = t.width,
                    u = t.height;
                null != n.width && (l = n.width), null != n.height && (u = n.height), this.dpr = n.devicePixelRatio || 1, t.width = l * this.dpr, t.height = u * this.dpr, this._width = l, this._height = u; var h = new Q_(t, this, this.dpr);
                h.__builtin__ = !0, h.initContext(), s[vb] = h, h.zlevel = vb, a.push(vb), this._domRoot = t } else { this._width = this._getSize(0), this._height = this._getSize(1); var c = this._domRoot = Ei(this._width, this._height);
                t.appendChild(c) }
            this._hoverlayer = null, this._hoverElements = [] };
    bb.prototype = { constructor: bb, getType: function() { return "canvas" }, isSingleCanvas: function() { return this._singleCanvas }, getViewportRoot: function() { return this._domRoot }, getViewportRootOffset: function() { var t = this.getViewportRoot(); return t ? { offsetLeft: t.offsetLeft || 0, offsetTop: t.offsetTop || 0 } : void 0 }, refresh: function(t) { var e = this.storage.getDisplayList(!0),
                n = this._zlevelList;
            this._redrawId = Math.random(), this._paintList(e, t, this._redrawId); for (var i = 0; i < n.length; i++) { var r = n[i],
                    a = this._layers[r]; if (!a.__builtin__ && a.refresh) { var o = 0 === i ? this._backgroundColor : null;
                    a.refresh(o) } } return this.refreshHover(), this }, addHover: function(t, e) { if (!t.__hoverMir) { var n = new t.constructor({ style: t.style, shape: t.shape, z: t.z, z2: t.z2, silent: t.silent }); return n.__from = t, t.__hoverMir = n, e && n.setStyle(e), this._hoverElements.push(n), n } }, removeHover: function(t) { var e = t.__hoverMir,
                n = this._hoverElements,
                i = u(n, e);
            i >= 0 && n.splice(i, 1), t.__hoverMir = null }, clearHover: function() { for (var t = this._hoverElements, e = 0; e < t.length; e++) { var n = t[e].__from;
                n && (n.__hoverMir = null) }
            t.length = 0 }, refreshHover: function() { var t = this._hoverElements,
                e = t.length,
                n = this._hoverlayer; if (n && n.clear(), e) { En(t, this.storage.displayableSortFunc), n || (n = this._hoverlayer = this.getLayer(gb)); var i = {};
                n.ctx.save(); for (var r = 0; e > r;) { var a = t[r],
                        o = a.__from;
                    o && o.__zr ? (r++, o.invisible || (a.transform = o.transform, a.invTransform = o.invTransform, a.__clipPaths = o.__clipPaths, this._doPaintEl(a, n, !0, i))) : (t.splice(r, 1), o.__hoverMir = null, e--) }
                n.ctx.restore() } }, getHoverLayer: function() { return this.getLayer(gb) }, _paintList: function(t, e, n) { if (this._redrawId === n) { e = e || !1, this._updateLayerStatus(t); var i = this._doPaintList(t, e); if (this._needsManuallyCompositing && this._compositeManually(), !i) { var r = this;
                    J_(function() { r._paintList(t, e, n) }) } } }, _compositeManually: function() { var t = this.getLayer(vb).ctx,
                e = this._domRoot.width,
                n = this._domRoot.height;
            t.clearRect(0, 0, e, n), this.eachBuiltinLayer(function(i) { i.virtual && t.drawImage(i.dom, 0, 0, e, n) }) }, _doPaintList: function(t, e) { for (var n = [], i = 0; i < this._zlevelList.length; i++) { var r = this._zlevelList[i],
                    a = this._layers[r];
                a.__builtin__ && a !== this._hoverlayer && (a.__dirty || e) && n.push(a) } for (var o = !0, s = 0; s < n.length; s++) { var a = n[s],
                    l = a.ctx,
                    u = {};
                l.save(); var h = e ? a.__startIndex : a.__drawIndex,
                    c = !e && a.incremental && Date.now,
                    d = c && Date.now(),
                    p = a.zlevel === this._zlevelList[0] ? this._backgroundColor : null; if (a.__startIndex === a.__endIndex) a.clear(!1, p);
                else if (h === a.__startIndex) { var g = t[h];
                    g.incremental && g.notClear && !e || a.clear(!1, p) } - 1 === h && (console.error("For some unknown reason. drawIndex is -1"), h = a.__startIndex); for (var v = h; v < a.__endIndex; v++) { var m = t[v]; if (this._doPaintEl(m, a, e, u), m.__dirty = m.__dirtyText = !1, c) { var y = Date.now() - d; if (y > 15) break } }
                a.__drawIndex = v, a.__drawIndex < a.__endIndex && (o = !1), u.prevElClipPaths && l.restore(), l.restore() } return Sx.wxa && f(this._layers, function(t) { t && t.ctx && t.ctx.draw && t.ctx.draw() }), o }, _doPaintEl: function(t, e, n, i) { var r = e.ctx,
                a = t.transform; if (!(!e.__dirty && !n || t.invisible || 0 === t.style.opacity || a && !a[0] && !a[3] || t.culling && Li(t, this._width, this._height))) { var o = t.__clipPaths,
                    s = i.prevElClipPaths;
                (!s || Oi(o, s)) && (s && (r.restore(), i.prevElClipPaths = null, i.prevEl = null), o && (r.save(), zi(o, r), i.prevElClipPaths = o)), t.beforeBrush && t.beforeBrush(r), t.brush(r, i.prevEl || null), i.prevEl = t, t.afterBrush && t.afterBrush(r) } }, getLayer: function(t, e) { this._singleCanvas && !this._needsManuallyCompositing && (t = vb); var n = this._layers[t]; return n || (n = new Q_("zr_" + t, this, this.dpr), n.zlevel = t, n.__builtin__ = !0, this._layerConfig[t] && r(n, this._layerConfig[t], !0), e && (n.virtual = e), this.insertLayer(t, n), n.initContext()), n }, insertLayer: function(t, e) { var n = this._layers,
                i = this._zlevelList,
                r = i.length,
                a = null,
                o = -1,
                s = this._domRoot; if (n[t]) return void L_("ZLevel " + t + " has been used already"); if (!Pi(e)) return void L_("Layer of zlevel " + t + " is not valid"); if (r > 0 && t > i[0]) { for (o = 0; r - 1 > o && !(i[o] < t && i[o + 1] > t); o++);
                a = n[i[o]] } if (i.splice(o + 1, 0, t), n[t] = e, !e.virtual)
                if (a) { var l = a.dom;
                    l.nextSibling ? s.insertBefore(e.dom, l.nextSibling) : s.appendChild(e.dom) } else s.firstChild ? s.insertBefore(e.dom, s.firstChild) : s.appendChild(e.dom) }, eachLayer: function(t, e) { var n, i, r = this._zlevelList; for (i = 0; i < r.length; i++) n = r[i], t.call(e, this._layers[n], n) }, eachBuiltinLayer: function(t, e) { var n, i, r, a = this._zlevelList; for (r = 0; r < a.length; r++) i = a[r], n = this._layers[i], n.__builtin__ && t.call(e, n, i) }, eachOtherLayer: function(t, e) { var n, i, r, a = this._zlevelList; for (r = 0; r < a.length; r++) i = a[r], n = this._layers[i], n.__builtin__ || t.call(e, n, i) }, getLayers: function() { return this._layers }, _updateLayerStatus: function(t) {
            function e(t) { r && (r.__endIndex !== t && (r.__dirty = !0), r.__endIndex = t) } if (this.eachBuiltinLayer(function(t) { t.__dirty = t.__used = !1 }), this._singleCanvas)
                for (var n = 1; n < t.length; n++) { var i = t[n]; if (i.zlevel !== t[n - 1].zlevel || i.incremental) { this._needsManuallyCompositing = !0; break } }
            for (var r = null, a = 0, n = 0; n < t.length; n++) { var o, i = t[n],
                    s = i.zlevel;
                i.incremental ? (o = this.getLayer(s + yb, this._needsManuallyCompositing), o.incremental = !0, a = 1) : o = this.getLayer(s + (a > 0 ? mb : 0), this._needsManuallyCompositing), o.__builtin__ || L_("ZLevel " + s + " has been used by unkown layer " + o.id), o !== r && (o.__used = !0, o.__startIndex !== n && (o.__dirty = !0), o.__startIndex = n, o.__drawIndex = o.incremental ? -1 : n, e(n), r = o), i.__dirty && (o.__dirty = !0, o.incremental && o.__drawIndex < 0 && (o.__drawIndex = n)) }
            e(n), this.eachBuiltinLayer(function(t) {!t.__used && t.getElementCount() > 0 && (t.__dirty = !0, t.__startIndex = t.__endIndex = t.__drawIndex = 0), t.__dirty && t.__drawIndex < 0 && (t.__drawIndex = t.__startIndex) }) }, clear: function() { return this.eachBuiltinLayer(this._clearLayer), this }, _clearLayer: function(t) { t.clear() }, setBackgroundColor: function(t) { this._backgroundColor = t }, configLayer: function(t, e) { if (e) { var n = this._layerConfig;
                n[t] ? r(n[t], e, !0) : n[t] = e; for (var i = 0; i < this._zlevelList.length; i++) { var a = this._zlevelList[i]; if (a === t || a === t + mb) { var o = this._layers[a];
                        r(o, n[t], !0) } } } }, delLayer: function(t) { var e = this._layers,
                n = this._zlevelList,
                i = e[t];
            i && (i.dom.parentNode.removeChild(i.dom), delete e[t], n.splice(u(n, t), 1)) }, resize: function(t, e) { if (this._domRoot.style) { var n = this._domRoot;
                n.style.display = "none"; var i = this._opts; if (null != t && (i.width = t), null != e && (i.height = e), t = this._getSize(0), e = this._getSize(1), n.style.display = "", this._width !== t || e !== this._height) { n.style.width = t + "px", n.style.height = e + "px"; for (var r in this._layers) this._layers.hasOwnProperty(r) && this._layers[r].resize(t, e);
                    f(this._progressiveLayers, function(n) { n.resize(t, e) }), this.refresh(!0) }
                this._width = t, this._height = e } else { if (null == t || null == e) return;
                this._width = t, this._height = e, this.getLayer(vb).resize(t, e) } return this }, clearLayer: function(t) { var e = this._layers[t];
            e && e.clear() }, dispose: function() { this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null }, getRenderedCanvas: function(t) { if (t = t || {}, this._singleCanvas && !this._compositeManually) return this._layers[vb].dom; var e = new Q_("image", this, t.pixelRatio || this.dpr); if (e.initContext(), e.clear(!1, t.backgroundColor || this._backgroundColor), t.pixelRatio <= this.dpr) { this.refresh(); var n = e.dom.width,
                    i = e.dom.height,
                    r = e.ctx;
                this.eachLayer(function(t) { t.__builtin__ ? r.drawImage(t.dom, 0, 0, n, i) : t.renderToCanvas && (e.ctx.save(), t.renderToCanvas(e.ctx), e.ctx.restore()) }) } else
                for (var a = {}, o = this.storage.getDisplayList(!0), s = 0; s < o.length; s++) { var l = o[s];
                    this._doPaintEl(l, e, !0, a) }
            return e.dom }, getWidth: function() { return this._width }, getHeight: function() { return this._height }, _getSize: function(t) { var e = this._opts,
                n = ["width", "height"][t],
                i = ["clientWidth", "clientHeight"][t],
                r = ["paddingLeft", "paddingTop"][t],
                a = ["paddingRight", "paddingBottom"][t]; if (null != e[n] && "auto" !== e[n]) return parseFloat(e[n]); var o = this.root,
                s = document.defaultView.getComputedStyle(o); return (o[i] || ki(s[n]) || ki(o.style[n])) - (ki(s[r]) || 0) - (ki(s[a]) || 0) | 0 }, pathToImage: function(t, e) { e = e || this.dpr; var n = document.createElement("canvas"),
                i = n.getContext("2d"),
                r = t.getBoundingRect(),
                a = t.style,
                o = a.shadowBlur * e,
                s = a.shadowOffsetX * e,
                l = a.shadowOffsetY * e,
                u = a.hasStroke() ? a.lineWidth : 0,
                h = Math.max(u / 2, -s + o),
                c = Math.max(u / 2, s + o),
                d = Math.max(u / 2, -l + o),
                f = Math.max(u / 2, l + o),
                p = r.width + h + c,
                g = r.height + d + f;
            n.width = p * e, n.height = g * e, i.scale(e, e), i.clearRect(0, 0, p, g), i.dpr = e; var v = { position: t.position, rotation: t.rotation, scale: t.scale };
            t.position = [h - r.x, d - r.y], t.rotation = 0, t.scale = [1, 1], t.updateTransform(), t && t.brush(i); var m = Di,
                y = new m({ style: { x: 0, y: 0, image: n } }); return null != v.position && (y.position = t.position = v.position), null != v.rotation && (y.rotation = t.rotation = v.rotation), null != v.scale && (y.scale = t.scale = v.scale), y } };
    var wb = function(t) { t = t || {}, this.stage = t.stage || {}, this.onframe = t.onframe || function() {}, this._clips = [], this._running = !1, this._time, this._pausedTime, this._pauseStart, this._paused = !1, Xx.call(this) };
    wb.prototype = { constructor: wb, addClip: function(t) { this._clips.push(t) }, addAnimator: function(t) { t.animation = this; for (var e = t.getClips(), n = 0; n < e.length; n++) this.addClip(e[n]) }, removeClip: function(t) { var e = u(this._clips, t);
            e >= 0 && this._clips.splice(e, 1) }, removeAnimator: function(t) { for (var e = t.getClips(), n = 0; n < e.length; n++) this.removeClip(e[n]);
            t.animation = null }, _update: function() { for (var t = (new Date).getTime() - this._pausedTime, e = t - this._time, n = this._clips, i = n.length, r = [], a = [], o = 0; i > o; o++) { var s = n[o],
                    l = s.step(t, e);
                l && (r.push(l), a.push(s)) } for (var o = 0; i > o;) n[o]._needsRemove ? (n[o] = n[i - 1], n.pop(), i--) : o++;
            i = r.length; for (var o = 0; i > o; o++) a[o].fire(r[o]);
            this._time = t, this.onframe(e), this.trigger("frame", e), this.stage.update && this.stage.update() }, _startLoop: function() {
            function t() { e._running && (J_(t), !e._paused && e._update()) } var e = this;
            this._running = !0, J_(t) }, start: function() { this._time = (new Date).getTime(), this._pausedTime = 0, this._startLoop() }, stop: function() { this._running = !1 }, pause: function() { this._paused || (this._pauseStart = (new Date).getTime(), this._paused = !0) }, resume: function() { this._paused && (this._pausedTime += (new Date).getTime() - this._pauseStart, this._paused = !1) }, clear: function() { this._clips = [] }, isFinished: function() { return !this._clips.length }, animate: function(t, e) { e = e || {}; var n = new C_(t, e.loop, e.getter, e.setter); return this.addAnimator(n), n } }, c(wb, Xx);
    var Mb = 300,
        Sb = Sx.domSupported,
        Ib = function() { var t = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"],
                e = ["touchstart", "touchend", "touchmove"],
                n = { pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1 },
                i = p(t, function(t) { var e = t.replace("mouse", "pointer"); return n.hasOwnProperty(e) ? e : t }); return { mouse: t, touch: e, pointer: i } }(),
        Tb = { mouse: ["mousemove", "mouseup"], pointer: ["pointermove", "pointerup"] },
        Cb = Gi.prototype;
    Cb.stopPropagation = Cb.stopImmediatePropagation = Cb.preventDefault = F;
    var Ab = { mousedown: function(t) { t = we(this.dom, t), this._mayPointerCapture = [t.zrX, t.zrY], this.trigger("mousedown", t) }, mousemove: function(t) { t = we(this.dom, t); var e = this._mayPointerCapture;!e || t.zrX === e[0] && t.zrY === e[1] || Yi(this, !0), this.trigger("mousemove", t) }, mouseup: function(t) { t = we(this.dom, t), Yi(this, !1), this.trigger("mouseup", t) }, mouseout: function(t) { t = we(this.dom, t), this._pointerCapturing && (t.zrEventControl = "no_globalout"); var e = t.toElement || t.relatedTarget;
            t.zrIsToLocalDOM = Hi(this, e), this.trigger("mouseout", t) }, touchstart: function(t) { t = we(this.dom, t), Vi(t), this._lastTouchMoment = new Date, this.handler.processGesture(t, "start"), Ab.mousemove.call(this, t), Ab.mousedown.call(this, t) }, touchmove: function(t) { t = we(this.dom, t), Vi(t), this.handler.processGesture(t, "change"), Ab.mousemove.call(this, t) }, touchend: function(t) { t = we(this.dom, t), Vi(t), this.handler.processGesture(t, "end"), Ab.mouseup.call(this, t), +new Date - this._lastTouchMoment < Mb && Ab.click.call(this, t) }, pointerdown: function(t) { Ab.mousedown.call(this, t) }, pointermove: function(t) { Bi(t) || Ab.mousemove.call(this, t) }, pointerup: function(t) { Ab.mouseup.call(this, t) }, pointerout: function(t) { Bi(t) || Ab.mouseout.call(this, t) } };
    f(["click", "mousewheel", "dblclick", "contextmenu"], function(t) { Ab[t] = function(e) { e = we(this.dom, e), this.trigger(t, e) } });
    var Db = { pointermove: function(t) { Bi(t) || Db.mousemove.call(this, t) }, pointerup: function(t) { Db.mouseup.call(this, t) }, mousemove: function(t) { this.trigger("mousemove", t) }, mouseup: function(t) { var e = this._pointerCapturing;
                Yi(this, !1), this.trigger("mouseup", t), e && (t.zrEventControl = "only_globalout", this.trigger("mouseout", t)) } },
        kb = qi.prototype;
    kb.dispose = function() { Xi(this._localHandlerScope), Sb && Xi(this._globalHandlerScope) }, kb.setCursor = function(t) { this.dom.style && (this.dom.style.cursor = t || "default") }, c(qi, Xx);
    var Pb = !Sx.canvasSupported,
        Lb = { canvas: bb },
        Ob = {},
        zb = "4.3.0",
        Eb = function(t, e, n) { n = n || {}, this.dom = e, this.id = t; var i = this,
                r = new H_,
                a = n.renderer; if (Pb) { if (!Lb.vml) throw new Error("You need to require 'zrender/vml/vml' to support IE8");
                a = "vml" } else a && Lb[a] || (a = "canvas"); var o = new Lb[a](e, r, n, t);
            this.storage = r, this.painter = o; var s = Sx.node || Sx.worker ? null : new qi(o.getViewportRoot(), o.root);
            this.handler = new r_(r, o, s, o.root), this.animation = new wb({ stage: { update: y(this.flush, this) } }), this.animation.start(), this._needsRefresh; var l = r.delFromStorage,
                u = r.addToStorage;
            r.delFromStorage = function(t) { l.call(r, t), t && t.removeSelfFromZr(i) }, r.addToStorage = function(t) { u.call(r, t), t.addSelfToZr(i) } };
    Eb.prototype = { constructor: Eb, getId: function() { return this.id }, add: function(t) { this.storage.addRoot(t), this._needsRefresh = !0 }, remove: function(t) { this.storage.delRoot(t), this._needsRefresh = !0 }, configLayer: function(t, e) { this.painter.configLayer && this.painter.configLayer(t, e), this._needsRefresh = !0 }, setBackgroundColor: function(t) { this.painter.setBackgroundColor && this.painter.setBackgroundColor(t), this._needsRefresh = !0 }, refreshImmediately: function() { this._needsRefresh = this._needsRefreshHover = !1, this.painter.refresh(), this._needsRefresh = this._needsRefreshHover = !1 }, refresh: function() { this._needsRefresh = !0 }, flush: function() { var t;
            this._needsRefresh && (t = !0, this.refreshImmediately()), this._needsRefreshHover && (t = !0, this.refreshHoverImmediately()), t && this.trigger("rendered") }, addHover: function(t, e) { if (this.painter.addHover) { var n = this.painter.addHover(t, e); return this.refreshHover(), n } }, removeHover: function(t) { this.painter.removeHover && (this.painter.removeHover(t), this.refreshHover()) }, clearHover: function() { this.painter.clearHover && (this.painter.clearHover(), this.refreshHover()) }, refreshHover: function() { this._needsRefreshHover = !0 }, refreshHoverImmediately: function() { this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.refreshHover() }, resize: function(t) { t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize() }, clearAnimation: function() { this.animation.clear() }, getWidth: function() { return this.painter.getWidth() }, getHeight: function() { return this.painter.getHeight() }, pathToImage: function(t, e) { return this.painter.pathToImage(t, e) }, setCursorStyle: function(t) { this.handler.setCursorStyle(t) }, findHover: function(t, e) { return this.handler.findHover(t, e) }, on: function(t, e, n) { this.handler.on(t, e, n) }, off: function(t, e) { this.handler.off(t, e) }, trigger: function(t, e) { this.handler.trigger(t, e) }, clear: function() { this.storage.delRoot(), this.painter.clear() }, dispose: function() { this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, tr(this.id) } };
    var Rb = (Object.freeze || Object)({ version: zb, init: Ki, dispose: $i, getInstance: Qi, registerPainter: Ji }),
        Bb = f,
        Nb = M,
        Vb = _,
        Fb = "series\x00",
        Hb = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"],
        Gb = 0,
        Wb = ".",
        Zb = "___EC__COMPONENT__CONTAINER___",
        Ub = 0,
        Xb = function(t) { for (var e = 0; e < t.length; e++) t[e][1] || (t[e][1] = t[e][0]); return function(e, n, i) { for (var r = {}, a = 0; a < t.length; a++) { var o = t[a][1]; if (!(n && u(n, o) >= 0 || i && u(i, o) < 0)) { var s = e.getShallow(o);
                        null != s && (r[t[a][0]] = s) } } return r } },
        Yb = Xb([
            ["lineWidth", "width"],
            ["stroke", "color"],
            ["opacity"],
            ["shadowBlur"],
            ["shadowOffsetX"],
            ["shadowOffsetY"],
            ["shadowColor"]
        ]),
        jb = { getLineStyle: function(t) { var e = Yb(this, t); return e.lineDash = this.getLineDash(e.lineWidth), e }, getLineDash: function(t) { null == t && (t = 1); var e = this.get("type"),
                    n = Math.max(t, 2),
                    i = 4 * t; return "solid" === e || null == e ? !1 : "dashed" === e ? [i, i] : [n, n] } },
        qb = Xb([
            ["fill", "color"],
            ["shadowBlur"],
            ["shadowOffsetX"],
            ["shadowOffsetY"],
            ["opacity"],
            ["shadowColor"]
        ]),
        Kb = { getAreaStyle: function(t, e) { return qb(this, t, e) } },
        $b = Math.pow,
        Qb = Math.sqrt,
        Jb = 1e-8,
        tw = 1e-4,
        ew = Qb(3),
        nw = 1 / 3,
        iw = H(),
        rw = H(),
        aw = H(),
        ow = Math.min,
        sw = Math.max,
        lw = Math.sin,
        uw = Math.cos,
        hw = 2 * Math.PI,
        cw = H(),
        dw = H(),
        fw = H(),
        pw = [],
        gw = [],
        vw = { M: 1, L: 2, C: 3, Q: 4, A: 5, Z: 6, R: 7 },
        mw = [],
        yw = [],
        xw = [],
        _w = [],
        bw = Math.min,
        ww = Math.max,
        Mw = Math.cos,
        Sw = Math.sin,
        Iw = Math.sqrt,
        Tw = Math.abs,
        Cw = "undefined" != typeof Float32Array,
        Aw = function(t) { this._saveData = !t, this._saveData && (this.data = []), this._ctx = null };
    Aw.prototype = {
        constructor: Aw,
        _xi: 0,
        _yi: 0,
        _x0: 0,
        _y0: 0,
        _ux: 0,
        _uy: 0,
        _len: 0,
        _lineDash: null,
        _dashOffset: 0,
        _dashIdx: 0,
        _dashSum: 0,
        setScale: function(t, e, n) { n = n || 0, this._ux = Tw(n / k_ / t) || 0, this._uy = Tw(n / k_ / e) || 0 },
        getContext: function() { return this._ctx },
        beginPath: function(t) { return this._ctx = t, t && t.beginPath(), t && (this.dpr = t.dpr), this._saveData && (this._len = 0), this._lineDash && (this._lineDash = null, this._dashOffset = 0), this },
        moveTo: function(t, e) { return this.addData(vw.M, t, e), this._ctx && this._ctx.moveTo(t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this },
        lineTo: function(t, e) {
            var n = Tw(t - this._xi) > this._ux || Tw(e - this._yi) > this._uy || this._len < 5;
            return this.addData(vw.L, t, e), this._ctx && n && (this._needsDash() ? this._dashedLineTo(t, e) : this._ctx.lineTo(t, e)), n && (this._xi = t, this._yi = e), this
        },
        bezierCurveTo: function(t, e, n, i, r, a) { return this.addData(vw.C, t, e, n, i, r, a), this._ctx && (this._needsDash() ? this._dashedBezierTo(t, e, n, i, r, a) : this._ctx.bezierCurveTo(t, e, n, i, r, a)), this._xi = r, this._yi = a, this },
        quadraticCurveTo: function(t, e, n, i) { return this.addData(vw.Q, t, e, n, i), this._ctx && (this._needsDash() ? this._dashedQuadraticTo(t, e, n, i) : this._ctx.quadraticCurveTo(t, e, n, i)), this._xi = n, this._yi = i, this },
        arc: function(t, e, n, i, r, a) { return this.addData(vw.A, t, e, n, n, i, r - i, 0, a ? 0 : 1), this._ctx && this._ctx.arc(t, e, n, i, r, a), this._xi = Mw(r) * n + t, this._yi = Sw(r) * n + e, this },
        arcTo: function(t, e, n, i, r) { return this._ctx && this._ctx.arcTo(t, e, n, i, r), this },
        rect: function(t, e, n, i) { return this._ctx && this._ctx.rect(t, e, n, i), this.addData(vw.R, t, e, n, i), this },
        closePath: function() { this.addData(vw.Z); var t = this._ctx,
                e = this._x0,
                n = this._y0; return t && (this._needsDash() && this._dashedLineTo(e, n), t.closePath()), this._xi = e, this._yi = n, this },
        fill: function(t) { t && t.fill(), this.toStatic() },
        stroke: function(t) { t && t.stroke(), this.toStatic() },
        setLineDash: function(t) { if (t instanceof Array) { this._lineDash = t, this._dashIdx = 0; for (var e = 0, n = 0; n < t.length; n++) e += t[n];
                this._dashSum = e } return this },
        setLineDashOffset: function(t) { return this._dashOffset = t, this },
        len: function() { return this._len },
        setData: function(t) { var e = t.length;
            this.data && this.data.length === e || !Cw || (this.data = new Float32Array(e)); for (var n = 0; e > n; n++) this.data[n] = t[n];
            this._len = e },
        appendPath: function(t) { t instanceof Array || (t = [t]); for (var e = t.length, n = 0, i = this._len, r = 0; e > r; r++) n += t[r].len();
            Cw && this.data instanceof Float32Array && (this.data = new Float32Array(i + n)); for (var r = 0; e > r; r++)
                for (var a = t[r].data, o = 0; o < a.length; o++) this.data[i++] = a[o];
            this._len = i },
        addData: function(t) { if (this._saveData) { var e = this.data;
                this._len + arguments.length > e.length && (this._expandData(), e = this.data); for (var n = 0; n < arguments.length; n++) e[this._len++] = arguments[n];
                this._prevCmd = t } },
        _expandData: function() { if (!(this.data instanceof Array)) { for (var t = [], e = 0; e < this._len; e++) t[e] = this.data[e];
                this.data = t } },
        _needsDash: function() { return this._lineDash },
        _dashedLineTo: function(t, e) { var n, i, r = this._dashSum,
                a = this._dashOffset,
                o = this._lineDash,
                s = this._ctx,
                l = this._xi,
                u = this._yi,
                h = t - l,
                c = e - u,
                d = Iw(h * h + c * c),
                f = l,
                p = u,
                g = o.length; for (h /= d, c /= d, 0 > a && (a = r + a), a %= r, f -= a * h, p -= a * c; h > 0 && t >= f || 0 > h && f >= t || 0 === h && (c > 0 && e >= p || 0 > c && p >= e);) i = this._dashIdx, n = o[i], f += h * n, p += c * n, this._dashIdx = (i + 1) % g, h > 0 && l > f || 0 > h && f > l || c > 0 && u > p || 0 > c && p > u || s[i % 2 ? "moveTo" : "lineTo"](h >= 0 ? bw(f, t) : ww(f, t), c >= 0 ? bw(p, e) : ww(p, e));
            h = f - t, c = p - e, this._dashOffset = -Iw(h * h + c * c) },
        _dashedBezierTo: function(t, e, n, i, r, a) { var o, s, l, u, h, c = this._dashSum,
                d = this._dashOffset,
                f = this._lineDash,
                p = this._ctx,
                g = this._xi,
                v = this._yi,
                m = Tr,
                y = 0,
                x = this._dashIdx,
                _ = f.length,
                b = 0; for (0 > d && (d = c + d), d %= c, o = 0; 1 > o; o += .1) s = m(g, t, n, r, o + .1) - m(g, t, n, r, o), l = m(v, e, i, a, o + .1) - m(v, e, i, a, o), y += Iw(s * s + l * l); for (; _ > x && (b += f[x], !(b > d)); x++); for (o = (b - d) / y; 1 >= o;) u = m(g, t, n, r, o), h = m(v, e, i, a, o), x % 2 ? p.moveTo(u, h) : p.lineTo(u, h), o += f[x] / y, x = (x + 1) % _;
            x % 2 !== 0 && p.lineTo(r, a), s = r - u, l = a - h, this._dashOffset = -Iw(s * s + l * l) },
        _dashedQuadraticTo: function(t, e, n, i) { var r = n,
                a = i;
            n = (n + 2 * t) / 3, i = (i + 2 * e) / 3, t = (this._xi + 2 * t) / 3, e = (this._yi + 2 * e) / 3, this._dashedBezierTo(t, e, n, i, r, a) },
        toStatic: function() { var t = this.data;
            t instanceof Array && (t.length = this._len, Cw && (this.data = new Float32Array(t))) },
        getBoundingRect: function() { mw[0] = mw[1] = xw[0] = xw[1] = Number.MAX_VALUE, yw[0] = yw[1] = _w[0] = _w[1] = -Number.MAX_VALUE; for (var t = this.data, e = 0, n = 0, i = 0, r = 0, a = 0; a < t.length;) { var o = t[a++]; switch (1 === a && (e = t[a], n = t[a + 1], i = e, r = n), o) {
                    case vw.M:
                        i = t[a++], r = t[a++], e = i, n = r, xw[0] = i, xw[1] = r, _w[0] = i, _w[1] = r; break;
                    case vw.L:
                        Vr(e, n, t[a], t[a + 1], xw, _w), e = t[a++], n = t[a++]; break;
                    case vw.C:
                        Fr(e, n, t[a++], t[a++], t[a++], t[a++], t[a], t[a + 1], xw, _w), e = t[a++], n = t[a++]; break;
                    case vw.Q:
                        Hr(e, n, t[a++], t[a++], t[a], t[a + 1], xw, _w), e = t[a++], n = t[a++]; break;
                    case vw.A:
                        var s = t[a++],
                            l = t[a++],
                            u = t[a++],
                            h = t[a++],
                            c = t[a++],
                            d = t[a++] + c;
                        a += 1; var f = 1 - t[a++];
                        1 === a && (i = Mw(c) * u + s, r = Sw(c) * h + l), Gr(s, l, u, h, c, d, f, xw, _w), e = Mw(d) * u + s, n = Sw(d) * h + l; break;
                    case vw.R:
                        i = e = t[a++], r = n = t[a++]; var p = t[a++],
                            g = t[a++];
                        Vr(i, r, i + p, r + g, xw, _w); break;
                    case vw.Z:
                        e = i, n = r }
                oe(mw, mw, xw), se(yw, yw, _w) } return 0 === a && (mw[0] = mw[1] = yw[0] = yw[1] = 0), new Cn(mw[0], mw[1], yw[0] - mw[0], yw[1] - mw[1]) },
        rebuildPath: function(t) { for (var e, n, i, r, a, o, s = this.data, l = this._ux, u = this._uy, h = this._len, c = 0; h > c;) { var d = s[c++]; switch (1 === c && (i = s[c], r = s[c + 1], e = i, n = r), d) {
                    case vw.M:
                        e = i = s[c++], n = r = s[c++], t.moveTo(i, r); break;
                    case vw.L:
                        a = s[c++], o = s[c++], (Tw(a - i) > l || Tw(o - r) > u || c === h - 1) && (t.lineTo(a, o), i = a, r = o); break;
                    case vw.C:
                        t.bezierCurveTo(s[c++], s[c++], s[c++], s[c++], s[c++], s[c++]), i = s[c - 2], r = s[c - 1]; break;
                    case vw.Q:
                        t.quadraticCurveTo(s[c++], s[c++], s[c++], s[c++]), i = s[c - 2], r = s[c - 1]; break;
                    case vw.A:
                        var f = s[c++],
                            p = s[c++],
                            g = s[c++],
                            v = s[c++],
                            m = s[c++],
                            y = s[c++],
                            x = s[c++],
                            _ = s[c++],
                            b = g > v ? g : v,
                            w = g > v ? 1 : g / v,
                            M = g > v ? v / g : 1,
                            S = Math.abs(g - v) > .001,
                            I = m + y;
                        S ? (t.translate(f, p), t.rotate(x), t.scale(w, M), t.arc(0, 0, b, m, I, 1 - _), t.scale(1 / w, 1 / M), t.rotate(-x), t.translate(-f, -p)) : t.arc(f, p, b, m, I, 1 - _), 1 === c && (e = Mw(m) * g + f, n = Sw(m) * v + p), i = Mw(I) * g + f, r = Sw(I) * v + p; break;
                    case vw.R:
                        e = i = s[c], n = r = s[c + 1], t.rect(s[c++], s[c++], s[c++], s[c++]); break;
                    case vw.Z:
                        t.closePath(), i = e, r = n } } }
    }, Aw.CMD = vw;
    var Dw = 2 * Math.PI,
        kw = 2 * Math.PI,
        Pw = Aw.CMD,
        Lw = 2 * Math.PI,
        Ow = 1e-4,
        zw = [-1, -1, -1],
        Ew = [-1, -1],
        Rw = $_.prototype.getCanvasPattern,
        Bw = Math.abs,
        Nw = new Aw(!0);
    ia.prototype = { constructor: ia, type: "path", __dirtyPath: !0, strokeContainThreshold: 5, segmentIgnoreThreshold: 0, subPixelOptimize: !1, brush: function(t, e) { var n = this.style,
                i = this.path || Nw,
                r = n.hasStroke(),
                a = n.hasFill(),
                o = n.fill,
                s = n.stroke,
                l = a && !!o.colorStops,
                u = r && !!s.colorStops,
                h = a && !!o.image,
                c = r && !!s.image; if (n.bind(t, this, e), this.setTransform(t), this.__dirty) { var d;
                l && (d = d || this.getBoundingRect(), this._fillGradient = n.getGradient(t, o, d)), u && (d = d || this.getBoundingRect(), this._strokeGradient = n.getGradient(t, s, d)) }
            l ? t.fillStyle = this._fillGradient : h && (t.fillStyle = Rw.call(o, t)), u ? t.strokeStyle = this._strokeGradient : c && (t.strokeStyle = Rw.call(s, t)); var f = n.lineDash,
                p = n.lineDashOffset,
                g = !!t.setLineDash,
                v = this.getGlobalScale(); if (i.setScale(v[0], v[1], this.segmentIgnoreThreshold), this.__dirtyPath || f && !g && r ? (i.beginPath(t), f && !g && (i.setLineDash(f), i.setLineDashOffset(p)), this.buildPath(i, this.shape, !1), this.path && (this.__dirtyPath = !1)) : (t.beginPath(), this.path.rebuildPath(t)), a)
                if (null != n.fillOpacity) { var m = t.globalAlpha;
                    t.globalAlpha = n.fillOpacity * n.opacity, i.fill(t), t.globalAlpha = m } else i.fill(t);
            if (f && g && (t.setLineDash(f), t.lineDashOffset = p), r)
                if (null != n.strokeOpacity) { var m = t.globalAlpha;
                    t.globalAlpha = n.strokeOpacity * n.opacity, i.stroke(t), t.globalAlpha = m } else i.stroke(t);
            f && g && t.setLineDash([]), null != n.text && (this.restoreTransform(t), this.drawRectText(t, this.getBoundingRect())) }, buildPath: function() {}, createPathProxy: function() { this.path = new Aw }, getBoundingRect: function() { var t = this._rect,
                e = this.style,
                n = !t; if (n) { var i = this.path;
                i || (i = this.path = new Aw), this.__dirtyPath && (i.beginPath(), this.buildPath(i, this.shape, !1)), t = i.getBoundingRect() } if (this._rect = t, e.hasStroke()) { var r = this._rectWithStroke || (this._rectWithStroke = t.clone()); if (this.__dirty || n) { r.copy(t); var a = e.lineWidth,
                        o = e.strokeNoScale ? this.getLineScale() : 1;
                    e.hasFill() || (a = Math.max(a, this.strokeContainThreshold || 4)), o > 1e-10 && (r.width += a / o, r.height += a / o, r.x -= a / o / 2, r.y -= a / o / 2) } return r } return t }, contain: function(t, e) { var n = this.transformCoordToLocal(t, e),
                i = this.getBoundingRect(),
                r = this.style; if (t = n[0], e = n[1], i.contain(t, e)) { var a = this.path.data; if (r.hasStroke()) { var o = r.lineWidth,
                        s = r.strokeNoScale ? this.getLineScale() : 1; if (s > 1e-10 && (r.hasFill() || (o = Math.max(o, this.strokeContainThreshold)), na(a, o / s, t, e))) return !0 } if (r.hasFill()) return ea(a, t, e) } return !1 }, dirty: function(t) { null == t && (t = !0), t && (this.__dirtyPath = t, this._rect = null), this.__dirty = this.__dirtyText = !0, this.__zr && this.__zr.refresh(), this.__clipTarget && this.__clipTarget.dirty() }, animateShape: function(t) { return this.animate("shape", t) }, attrKV: function(t, e) { "shape" === t ? (this.setShape(e), this.__dirtyPath = !0, this._rect = null) : Ai.prototype.attrKV.call(this, t, e) }, setShape: function(t, e) { var n = this.shape; if (n) { if (M(t))
                    for (var i in t) t.hasOwnProperty(i) && (n[i] = t[i]);
                else n[t] = e;
                this.dirty(!0) } return this }, getLineScale: function() { var t = this.transform; return t && Bw(t[0] - 1) > 1e-10 && Bw(t[3] - 1) > 1e-10 ? Math.sqrt(Bw(t[0] * t[3] - t[2] * t[1])) : 1 } }, ia.extend = function(t) { var e = function(e) { ia.call(this, e), t.style && this.style.extendFrom(t.style, !1); var n = t.shape; if (n) { this.shape = this.shape || {}; var i = this.shape; for (var r in n) !i.hasOwnProperty(r) && n.hasOwnProperty(r) && (i[r] = n[r]) }
            t.init && t.init.call(this, e) };
        h(e, ia); for (var n in t) "style" !== n && "shape" !== n && (e.prototype[n] = t[n]); return e }, h(ia, Ai);
    var Vw = Aw.CMD,
        Fw = [
            [],
            [],
            []
        ],
        Hw = Math.sqrt,
        Gw = Math.atan2,
        Ww = function(t, e) { var n, i, r, a, o, s, l = t.data,
                u = Vw.M,
                h = Vw.C,
                c = Vw.L,
                d = Vw.R,
                f = Vw.A,
                p = Vw.Q; for (r = 0, a = 0; r < l.length;) { switch (n = l[r++], a = r, i = 0, n) {
                    case u:
                        i = 1; break;
                    case c:
                        i = 1; break;
                    case h:
                        i = 3; break;
                    case p:
                        i = 2; break;
                    case f:
                        var g = e[4],
                            v = e[5],
                            m = Hw(e[0] * e[0] + e[1] * e[1]),
                            y = Hw(e[2] * e[2] + e[3] * e[3]),
                            x = Gw(-e[1] / y, e[0] / m);
                        l[r] *= m, l[r++] += g, l[r] *= y, l[r++] += v, l[r++] *= m, l[r++] *= y, l[r++] += x, l[r++] += x, r += 2, a = r; break;
                    case d:
                        s[0] = l[r++], s[1] = l[r++], ae(s, s, e), l[a++] = s[0], l[a++] = s[1], s[0] += l[r++], s[1] += l[r++], ae(s, s, e), l[a++] = s[0], l[a++] = s[1] } for (o = 0; i > o; o++) { var s = Fw[o];
                    s[0] = l[r++], s[1] = l[r++], ae(s, s, e), l[a++] = s[0], l[a++] = s[1] } } },
        Zw = Math.sqrt,
        Uw = Math.sin,
        Xw = Math.cos,
        Yw = Math.PI,
        jw = function(t) { return Math.sqrt(t[0] * t[0] + t[1] * t[1]) },
        qw = function(t, e) { return (t[0] * e[0] + t[1] * e[1]) / (jw(t) * jw(e)) },
        Kw = function(t, e) { return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(qw(t, e)) },
        $w = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/gi,
        Qw = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g,
        Jw = function(t) { Ai.call(this, t) };
    Jw.prototype = { constructor: Jw, type: "text", brush: function(t, e) { var n = this.style;
            this.__dirty && hi(n, !0), n.fill = n.stroke = n.shadowBlur = n.shadowColor = n.shadowOffsetX = n.shadowOffsetY = null; var i = n.text; return null != i && (i += ""), Ci(i, n) ? (this.setTransform(t), di(this, t, i, n, null, e), void this.restoreTransform(t)) : void(t.__attrCachedBy = Z_.NONE) }, getBoundingRect: function() { var t = this.style; if (this.__dirty && hi(t, !0), !this._rect) { var e = t.text;
                null != e ? e += "" : e = ""; var n = Yn(t.text + "", t.font, t.textAlign, t.textVerticalAlign, t.textPadding, t.textLineHeight, t.rich); if (n.x += t.x || 0, n.y += t.y || 0, Mi(t.textStroke, t.textStrokeWidth)) { var i = t.textStrokeWidth;
                    n.x -= i / 2, n.y -= i / 2, n.width += i, n.height += i }
                this._rect = n } return this._rect } }, h(Jw, Ai);
    var tM = ia.extend({ type: "circle", shape: { cx: 0, cy: 0, r: 0 }, buildPath: function(t, e, n) { n && t.moveTo(e.cx + e.r, e.cy), t.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI, !0) } }),
        eM = [
            ["shadowBlur", 0],
            ["shadowColor", "#000"],
            ["shadowOffsetX", 0],
            ["shadowOffsetY", 0]
        ],
        nM = function(t) { return Sx.browser.ie && Sx.browser.version >= 11 ? function() { var e, n = this.__clipPaths,
                    i = this.style; if (n)
                    for (var r = 0; r < n.length; r++) { var a = n[r],
                            o = a && a.shape,
                            s = a && a.type; if (o && ("sector" === s && o.startAngle === o.endAngle || "rect" === s && (!o.width || !o.height))) { for (var l = 0; l < eM.length; l++) eM[l][2] = i[eM[l][0]], i[eM[l][0]] = eM[l][1];
                            e = !0; break } }
                if (t.apply(this, arguments), e)
                    for (var l = 0; l < eM.length; l++) i[eM[l][0]] = eM[l][2] } : t },
        iM = ia.extend({ type: "sector", shape: { cx: 0, cy: 0, r0: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0 }, brush: nM(ia.prototype.brush), buildPath: function(t, e) { var n = e.cx,
                    i = e.cy,
                    r = Math.max(e.r0 || 0, 0),
                    a = Math.max(e.r, 0),
                    o = e.startAngle,
                    s = e.endAngle,
                    l = e.clockwise,
                    u = Math.cos(o),
                    h = Math.sin(o);
                t.moveTo(u * r + n, h * r + i), t.lineTo(u * a + n, h * a + i), t.arc(n, i, a, o, s, !l), t.lineTo(Math.cos(s) * r + n, Math.sin(s) * r + i), 0 !== r && t.arc(n, i, r, s, o, l), t.closePath() } }),
        rM = ia.extend({ type: "ring", shape: { cx: 0, cy: 0, r: 0, r0: 0 }, buildPath: function(t, e) { var n = e.cx,
                    i = e.cy,
                    r = 2 * Math.PI;
                t.moveTo(n + e.r, i), t.arc(n, i, e.r, 0, r, !1), t.moveTo(n + e.r0, i), t.arc(n, i, e.r0, 0, r, !0) } }),
        aM = function(t, e) { for (var n = t.length, i = [], r = 0, a = 1; n > a; a++) r += ee(t[a - 1], t[a]); var o = r / 2;
            o = n > o ? n : o; for (var a = 0; o > a; a++) { var s, l, u, h = a / (o - 1) * (e ? n : n - 1),
                    c = Math.floor(h),
                    d = h - c,
                    f = t[c % n];
                e ? (s = t[(c - 1 + n) % n], l = t[(c + 1) % n], u = t[(c + 2) % n]) : (s = t[0 === c ? c : c - 1], l = t[c > n - 2 ? n - 1 : c + 1], u = t[c > n - 3 ? n - 1 : c + 2]); var p = d * d,
                    g = d * p;
                i.push([ha(s[0], f[0], l[0], u[0], d, p, g), ha(s[1], f[1], l[1], u[1], d, p, g)]) } return i },
        oM = function(t, e, n, i) { var r, a, o, s, l = [],
                u = [],
                h = [],
                c = []; if (i) { o = [1 / 0, 1 / 0], s = [-1 / 0, -1 / 0]; for (var d = 0, f = t.length; f > d; d++) oe(o, o, t[d]), se(s, s, t[d]);
                oe(o, o, i[0]), se(s, s, i[1]) } for (var d = 0, f = t.length; f > d; d++) { var p = t[d]; if (n) r = t[d ? d - 1 : f - 1], a = t[(d + 1) % f];
                else { if (0 === d || d === f - 1) { l.push(W(t[d])); continue }
                    r = t[d - 1], a = t[d + 1] }
                Y(u, a, r), J(u, u, e); var g = ee(p, r),
                    v = ee(p, a),
                    m = g + v;
                0 !== m && (g /= m, v /= m), J(h, u, -g), J(c, u, v); var y = U([], p, h),
                    x = U([], p, c);
                i && (se(y, y, o), oe(y, y, s), se(x, x, o), oe(x, x, s)), l.push(y), l.push(x) } return n && l.push(l.shift()), l },
        sM = ia.extend({ type: "polygon", shape: { points: null, smooth: !1, smoothConstraint: null }, buildPath: function(t, e) { ca(t, e, !0) } }),
        lM = ia.extend({ type: "polyline", shape: { points: null, smooth: !1, smoothConstraint: null }, style: { stroke: "#000", fill: null }, buildPath: function(t, e) { ca(t, e, !1) } }),
        uM = Math.round,
        hM = {},
        cM = ia.extend({ type: "rect", shape: { r: 0, x: 0, y: 0, width: 0, height: 0 }, buildPath: function(t, e) { var n, i, r, a;
                this.subPixelOptimize ? (fa(hM, e, this.style), n = hM.x, i = hM.y, r = hM.width, a = hM.height, hM.r = e.r, e = hM) : (n = e.x, i = e.y, r = e.width, a = e.height), e.r ? ui(t, e) : t.rect(n, i, r, a), t.closePath() } }),
        dM = {},
        fM = ia.extend({ type: "line", shape: { x1: 0, y1: 0, x2: 0, y2: 0, percent: 1 }, style: { stroke: "#000", fill: null }, buildPath: function(t, e) { var n, i, r, a;
                this.subPixelOptimize ? (da(dM, e, this.style), n = dM.x1, i = dM.y1, r = dM.x2, a = dM.y2) : (n = e.x1, i = e.y1, r = e.x2, a = e.y2); var o = e.percent;
                0 !== o && (t.moveTo(n, i), 1 > o && (r = n * (1 - o) + r * o, a = i * (1 - o) + a * o), t.lineTo(r, a)) }, pointAt: function(t) { var e = this.shape; return [e.x1 * (1 - t) + e.x2 * t, e.y1 * (1 - t) + e.y2 * t] } }),
        pM = [],
        gM = ia.extend({ type: "bezier-curve", shape: { x1: 0, y1: 0, x2: 0, y2: 0, cpx1: 0, cpy1: 0, percent: 1 }, style: { stroke: "#000", fill: null }, buildPath: function(t, e) { var n = e.x1,
                    i = e.y1,
                    r = e.x2,
                    a = e.y2,
                    o = e.cpx1,
                    s = e.cpy1,
                    l = e.cpx2,
                    u = e.cpy2,
                    h = e.percent;
                0 !== h && (t.moveTo(n, i), null == l || null == u ? (1 > h && (Rr(n, o, r, h, pM), o = pM[1], r = pM[2], Rr(i, s, a, h, pM), s = pM[1], a = pM[2]), t.quadraticCurveTo(o, s, r, a)) : (1 > h && (kr(n, o, l, r, h, pM), o = pM[1], l = pM[2], r = pM[3], kr(i, s, u, a, h, pM), s = pM[1], u = pM[2], a = pM[3]), t.bezierCurveTo(o, s, l, u, r, a))) }, pointAt: function(t) { return ga(this.shape, t, !1) }, tangentAt: function(t) { var e = ga(this.shape, t, !0); return te(e, e) } }),
        vM = ia.extend({ type: "arc", shape: { cx: 0, cy: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0 }, style: { stroke: "#000", fill: null }, buildPath: function(t, e) { var n = e.cx,
                    i = e.cy,
                    r = Math.max(e.r, 0),
                    a = e.startAngle,
                    o = e.endAngle,
                    s = e.clockwise,
                    l = Math.cos(a),
                    u = Math.sin(a);
                t.moveTo(l * r + n, u * r + i), t.arc(n, i, r, a, o, !s) } }),
        mM = ia.extend({ type: "compound", shape: { paths: null }, _updatePathDirty: function() { for (var t = this.__dirtyPath, e = this.shape.paths, n = 0; n < e.length; n++) t = t || e[n].__dirtyPath;
                this.__dirtyPath = t, this.__dirty = this.__dirty || t }, beforeBrush: function() { this._updatePathDirty(); for (var t = this.shape.paths || [], e = this.getGlobalScale(), n = 0; n < t.length; n++) t[n].path || t[n].createPathProxy(), t[n].path.setScale(e[0], e[1], t[n].segmentIgnoreThreshold) }, buildPath: function(t, e) { for (var n = e.paths || [], i = 0; i < n.length; i++) n[i].buildPath(t, n[i].shape, !0) }, afterBrush: function() { for (var t = this.shape.paths || [], e = 0; e < t.length; e++) t[e].__dirtyPath = !1 }, getBoundingRect: function() { return this._updatePathDirty(), ia.prototype.getBoundingRect.call(this) } }),
        yM = function(t) { this.colorStops = t || [] };
    yM.prototype = { constructor: yM, addColorStop: function(t, e) { this.colorStops.push({ offset: t, color: e }) } };
    var xM = function(t, e, n, i, r, a) { this.x = null == t ? 0 : t, this.y = null == e ? 0 : e, this.x2 = null == n ? 1 : n, this.y2 = null == i ? 0 : i, this.type = "linear", this.global = a || !1, yM.call(this, r) };
    xM.prototype = { constructor: xM }, h(xM, yM);
    var _M = function(t, e, n, i, r) { this.x = null == t ? .5 : t, this.y = null == e ? .5 : e, this.r = null == n ? .5 : n, this.type = "radial", this.global = r || !1, yM.call(this, i) };
    _M.prototype = { constructor: _M }, h(_M, yM), va.prototype.incremental = !0, va.prototype.clearDisplaybles = function() { this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.dirty(), this.notClear = !1 }, va.prototype.addDisplayable = function(t, e) { e ? this._temporaryDisplayables.push(t) : this._displayables.push(t), this.dirty() }, va.prototype.addDisplayables = function(t, e) { e = e || !1; for (var n = 0; n < t.length; n++) this.addDisplayable(t[n], e) }, va.prototype.eachPendingDisplayable = function(t) { for (var e = this._cursor; e < this._displayables.length; e++) t && t(this._displayables[e]); for (var e = 0; e < this._temporaryDisplayables.length; e++) t && t(this._temporaryDisplayables[e]) }, va.prototype.update = function() { this.updateTransform(); for (var t = this._cursor; t < this._displayables.length; t++) { var e = this._displayables[t];
            e.parent = this, e.update(), e.parent = null } for (var t = 0; t < this._temporaryDisplayables.length; t++) { var e = this._temporaryDisplayables[t];
            e.parent = this, e.update(), e.parent = null } }, va.prototype.brush = function(t) { for (var e = this._cursor; e < this._displayables.length; e++) { var n = this._displayables[e];
            n.beforeBrush && n.beforeBrush(t), n.brush(t, e === this._cursor ? null : this._displayables[e - 1]), n.afterBrush && n.afterBrush(t) }
        this._cursor = e; for (var e = 0; e < this._temporaryDisplayables.length; e++) { var n = this._temporaryDisplayables[e];
            n.beforeBrush && n.beforeBrush(t), n.brush(t, 0 === e ? null : this._temporaryDisplayables[e - 1]), n.afterBrush && n.afterBrush(t) }
        this._temporaryDisplayables = [], this.notClear = !0 };
    var bM = [];
    va.prototype.getBoundingRect = function() { if (!this._rect) { for (var t = new Cn(1 / 0, 1 / 0, -1 / 0, -1 / 0), e = 0; e < this._displayables.length; e++) { var n = this._displayables[e],
                    i = n.getBoundingRect().clone();
                n.needLocalTransform() && i.applyTransform(n.getLocalTransform(bM)), t.union(i) }
            this._rect = t } return this._rect }, va.prototype.contain = function(t, e) { var n = this.transformCoordToLocal(t, e),
            i = this.getBoundingRect(); if (i.contain(n[0], n[1]))
            for (var r = 0; r < this._displayables.length; r++) { var a = this._displayables[r]; if (a.contain(t, e)) return !0 }
        return !1 }, h(va, Ai);
    var wM = Math.max,
        MM = Math.min,
        SM = {},
        IM = 1,
        TM = { color: "textFill", textBorderColor: "textStroke", textBorderWidth: "textStrokeWidth" },
        CM = "emphasis",
        AM = "normal",
        DM = 1,
        kM = {},
        PM = {},
        LM = ua,
        OM = pa,
        zM = N(),
        EM = 0;
    xa("circle", tM), xa("sector", iM), xa("ring", rM), xa("polygon", sM), xa("polyline", lM), xa("rect", cM), xa("line", fM), xa("bezierCurve", gM), xa("arc", vM);
    var RM = (Object.freeze || Object)({ Z2_EMPHASIS_LIFT: IM, CACHED_LABEL_STYLE_PROPERTIES: TM, extendShape: ma, extendPath: ya, registerShape: xa, getShapeClass: _a, makePath: ba, makeImage: wa, mergePath: LM, resizePath: Sa, subPixelOptimizeLine: Ia, subPixelOptimizeRect: Ta, subPixelOptimize: OM, setElementHoverStyle: za, setHoverStyle: Fa, setAsHighDownDispatcher: Ha, isHighDownDispatcher: Ga, getHighlightDigit: Wa, setLabelStyle: Za, modifyLabelStyle: Ua, setTextStyle: Xa, setText: Ya, getFont: to, updateProps: no, initProps: io, getTransform: ro, applyTransform: ao, transformDirection: oo, groupTransition: so, clipPointsByRect: lo, clipRectByRect: uo, createIcon: ho, linePolygonIntersect: co, lineLineIntersect: fo, Group: N_, Image: Di, Text: Jw, Circle: tM, Sector: iM, Ring: rM, Polygon: sM, Polyline: lM, Rect: cM, Line: fM, BezierCurve: gM, Arc: vM, IncrementalDisplayable: va, CompoundPath: mM, LinearGradient: xM, RadialGradient: _M, BoundingRect: Cn }),
        BM = ["textStyle", "color"],
        NM = { getTextColor: function(t) { var e = this.ecModel; return this.getShallow("color") || (!t && e ? e.get(BM) : null) }, getFont: function() { return to({ fontStyle: this.getShallow("fontStyle"), fontWeight: this.getShallow("fontWeight"), fontSize: this.getShallow("fontSize"), fontFamily: this.getShallow("fontFamily") }, this.ecModel) }, getTextRect: function(t) { return Yn(t, this.getFont(), this.getShallow("align"), this.getShallow("verticalAlign") || this.getShallow("baseline"), this.getShallow("padding"), this.getShallow("lineHeight"), this.getShallow("rich"), this.getShallow("truncateText")) } },
        VM = Xb([
            ["fill", "color"],
            ["stroke", "borderColor"],
            ["lineWidth", "borderWidth"],
            ["opacity"],
            ["shadowBlur"],
            ["shadowOffsetX"],
            ["shadowOffsetY"],
            ["shadowColor"],
            ["textPosition"],
            ["textAlign"]
        ]),
        FM = { getItemStyle: function(t, e) { var n = VM(this, t, e),
                    i = this.getBorderLineDash(); return i && (n.lineDash = i), n }, getBorderLineDash: function() { var t = this.get("borderType"); return "solid" === t || null == t ? null : "dashed" === t ? [5, 5] : [1, 1] } },
        HM = c,
        GM = cr();
    vo.prototype = { constructor: vo, init: null, mergeOption: function(t) { r(this.option, t, !0) }, get: function(t, e) { return null == t ? this.option : mo(this.option, this.parsePath(t), !e && yo(this, t)) }, getShallow: function(t, e) { var n = this.option,
                i = null == n ? n : n[t],
                r = !e && yo(this, t); return null == i && r && (i = r.getShallow(t)), i }, getModel: function(t, e) { var n, i = null == t ? this.option : mo(this.option, t = this.parsePath(t)); return e = e || (n = yo(this, t)) && n.getModel(t), new vo(i, e, this.ecModel) }, isEmpty: function() { return null == this.option }, restoreData: function() {}, clone: function() { var t = this.constructor; return new t(i(this.option)) }, setReadOnly: function() {}, parsePath: function(t) { return "string" == typeof t && (t = t.split(".")), t }, customizeGetParent: function(t) { GM(this).getParent = t }, isAnimationEnabled: function() { if (!Sx.node) { if (null != this.option.animation) return !!this.option.animation; if (this.parentModel) return this.parentModel.isAnimationEnabled() } } }, xr(vo), _r(vo), HM(vo, jb), HM(vo, Kb), HM(vo, NM), HM(vo, FM);
    var WM = 0,
        ZM = 1e-4,
        UM = 9007199254740991,
        XM = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/,
        YM = (Object.freeze || Object)({ linearMap: Mo, parsePercent: So, round: Io, asc: To, getPrecision: Co, getPrecisionSafe: Ao, getPixelPrecision: Do, getPercentWithPrecision: ko, MAX_SAFE_INTEGER: UM, remRadian: Po, isRadianAroundZero: Lo, parseDate: Oo, quantity: zo, quantityExponent: Eo, nice: Ro, quantile: Bo, reformIntervals: No, isNumeric: Vo }),
        jM = L,
        qM = /([&<>"'])/g,
        KM = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" },
        $M = ["a", "b", "c", "d", "e", "f", "g"],
        QM = function(t, e) { return "{" + t + (null == e ? "" : e) + "}" },
        JM = Jn,
        tS = (Object.freeze || Object)({ addCommas: Fo, toCamelCase: Ho, normalizeCssArray: jM, encodeHTML: Go, formatTpl: Wo, formatTplSimple: Zo, getTooltipMarker: Uo, formatTime: Yo, capitalFirst: jo, truncateText: JM, getTextBoundingRect: qo, getTextRect: Ko }),
        eS = f,
        nS = ["left", "right", "top", "bottom", "width", "height"],
        iS = [
            ["width", "left", "right"],
            ["height", "top", "bottom"]
        ],
        rS = $o,
        aS = (x($o, "vertical"), x($o, "horizontal"), { getBoxLayoutParams: function() { return { left: this.get("left"), top: this.get("top"), right: this.get("right"), bottom: this.get("bottom"), width: this.get("width"), height: this.get("height") } } }),
        oS = cr(),
        sS = vo.extend({ type: "component", id: "", name: "", mainType: "", subType: "", componentIndex: 0, defaultOption: null, ecModel: null, dependentModels: [], uid: null, layoutMode: null, $constructor: function(t, e, n, i) { vo.call(this, t, e, n, i), this.uid = xo("ec_cpt_model") }, init: function(t, e, n) { this.mergeDefaultAndTheme(t, n) }, mergeDefaultAndTheme: function(t, e) { var n = this.layoutMode,
                    i = n ? es(t) : {},
                    a = e.getTheme();
                r(t, a.get(this.mainType)), r(t, this.getDefaultOption()), n && ts(t, i, n) }, mergeOption: function(t) { r(this.option, t, !0); var e = this.layoutMode;
                e && ts(this.option, t, e) }, optionUpdated: function() {}, getDefaultOption: function() { var t = oS(this); if (!t.defaultOption) { for (var e = [], n = this.constructor; n;) { var i = n.prototype.defaultOption;
                        i && e.push(i), n = n.superClass } for (var a = {}, o = e.length - 1; o >= 0; o--) a = r(a, e[o], !0);
                    t.defaultOption = a } return t.defaultOption }, getReferringComponents: function(t) { return this.ecModel.queryComponents({ mainType: t, index: this.get(t + "Index", !0), id: this.get(t + "Id", !0) }) } });
    Mr(sS, { registerWhenExtend: !0 }), _o(sS), bo(sS, is), c(sS, aS);
    var lS = "";
    "undefined" != typeof navigator && (lS = navigator.platform || "");
    var uS = { color: ["#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3"], gradientColor: ["#f6efa6", "#d88273", "#bf444c"], textStyle: { fontFamily: lS.match(/^Win/) ? "Microsoft YaHei" : "sans-serif", fontSize: 12, fontStyle: "normal", fontWeight: "normal" }, blendMode: null, animation: "auto", animationDuration: 1e3, animationDurationUpdate: 300, animationEasing: "exponentialOut", animationEasingUpdate: "cubicOut", animationThreshold: 2e3, progressiveThreshold: 3e3, progressive: 400, hoverLayerThreshold: 3e3, useUTC: !1 },
        hS = cr(),
        cS = { clearColorPalette: function() { hS(this).colorIdx = 0, hS(this).colorNameMap = {} }, getColorFromPalette: function(t, e, n) { e = e || this; var i = hS(e),
                    r = i.colorIdx || 0,
                    a = i.colorNameMap = i.colorNameMap || {}; if (a.hasOwnProperty(t)) return a[t]; var o = er(this.get("color", !0)),
                    s = this.get("colorLayer", !0),
                    l = null != n && s ? rs(s, n) : o; if (l = l || o, l && l.length) { var u = l[r]; return t && (a[t] = u), i.colorIdx = (r + 1) % l.length, u } } },
        dS = "original",
        fS = "arrayRows",
        pS = "objectRows",
        gS = "keyedColumns",
        vS = "unknown",
        mS = "typedArray",
        yS = "column",
        xS = "row";
    as.seriesDataToSource = function(t) { return new as({ data: t, sourceFormat: I(t) ? mS : dS, fromDataset: !1 }) }, _r(as);
    var _S = { Must: 1, Might: 2, Not: 3 },
        bS = cr(),
        wS = "\x00_ec_inner",
        MS = vo.extend({ init: function(t, e, n, i) { n = n || {}, this.option = null, this._theme = new vo(n), this._optionManager = i }, setOption: function(t, e) { O(!(wS in t), "please use chart.getOption()"), this._optionManager.setOption(t, e), this.resetOption(null) }, resetOption: function(t) { var e = !1,
                    n = this._optionManager; if (!t || "recreate" === t) { var i = n.mountOption("recreate" === t);
                    this.option && "recreate" !== t ? (this.restoreData(), this.mergeOption(i)) : bs.call(this, i), e = !0 } if (("timeline" === t || "media" === t) && this.restoreData(), !t || "recreate" === t || "timeline" === t) { var r = n.getTimelineOption(this);
                    r && (this.mergeOption(r), e = !0) } if (!t || "recreate" === t || "media" === t) { var a = n.getMediaOption(this, this._api);
                    a.length && f(a, function(t) { this.mergeOption(t, e = !0) }, this) } return e }, mergeOption: function(t) {
                function e(e, i) { var r = er(t[e]),
                        s = ar(a.get(e), r);
                    or(s), f(s, function(t) { var n = t.option;
                        M(n) && (t.keyInfo.mainType = e, t.keyInfo.subType = Ms(e, n, t.exist)) }); var l = ws(a, i);
                    n[e] = [], a.set(e, []), f(s, function(t, i) { var r = t.exist,
                            s = t.option; if (O(M(s) || r, "Empty component definition"), s) { var u = sS.getClass(e, t.keyInfo.subType, !0); if (r && r.constructor === u) r.name = t.keyInfo.name, r.mergeOption(s, this), r.optionUpdated(s, !1);
                            else { var h = o({ dependentModels: l, componentIndex: i }, t.keyInfo);
                                r = new u(s, this, this, h), o(r, h), r.init(s, this, this, h), r.optionUpdated(null, !0) } } else r.mergeOption({}, this), r.optionUpdated({}, !1);
                        a.get(e)[i] = r, n[e][i] = r.option }, this), "series" === e && Ss(this, a.get("series")) } var n = this.option,
                    a = this._componentsMap,
                    s = [];
                ls(this), f(t, function(t, e) { null != t && (sS.hasClass(e) ? e && s.push(e) : n[e] = null == n[e] ? i(t) : r(n[e], t, !0)) }), sS.topologicalTravel(s, sS.getAllClassMainTypes(), e, this), this._seriesIndicesMap = N(this._seriesIndices = this._seriesIndices || []) }, getOption: function() { var t = i(this.option); return f(t, function(e, n) { if (sS.hasClass(n)) { for (var e = er(e), i = e.length - 1; i >= 0; i--) lr(e[i]) && e.splice(i, 1);
                        t[n] = e } }), delete t[wS], t }, getTheme: function() { return this._theme }, getComponent: function(t, e) { var n = this._componentsMap.get(t); return n ? n[e || 0] : void 0 }, queryComponents: function(t) { var e = t.mainType; if (!e) return []; var n = t.index,
                    i = t.id,
                    r = t.name,
                    a = this._componentsMap.get(e); if (!a || !a.length) return []; var o; if (null != n) _(n) || (n = [n]), o = v(p(n, function(t) { return a[t] }), function(t) { return !!t });
                else if (null != i) { var s = _(i);
                    o = v(a, function(t) { return s && u(i, t.id) >= 0 || !s && t.id === i }) } else if (null != r) { var l = _(r);
                    o = v(a, function(t) { return l && u(r, t.name) >= 0 || !l && t.name === r }) } else o = a.slice(); return Is(o, t) }, findComponents: function(t) {
                function e(t) { var e = r + "Index",
                        n = r + "Id",
                        i = r + "Name"; return !t || null == t[e] && null == t[n] && null == t[i] ? null : { mainType: r, index: t[e], id: t[n], name: t[i] } }

                function n(e) { return t.filter ? v(e, t.filter) : e } var i = t.query,
                    r = t.mainType,
                    a = e(i),
                    o = a ? this.queryComponents(a) : this._componentsMap.get(r); return n(Is(o, t)) }, eachComponent: function(t, e, n) { var i = this._componentsMap; if ("function" == typeof t) n = e, e = t, i.each(function(t, i) { f(t, function(t, r) { e.call(n, i, t, r) }) });
                else if (w(t)) f(i.get(t), e, n);
                else if (M(t)) { var r = this.findComponents(t);
                    f(r, e, n) } }, getSeriesByName: function(t) { var e = this._componentsMap.get("series"); return v(e, function(e) { return e.name === t }) }, getSeriesByIndex: function(t) { return this._componentsMap.get("series")[t] }, getSeriesByType: function(t) { var e = this._componentsMap.get("series"); return v(e, function(e) { return e.subType === t }) }, getSeries: function() { return this._componentsMap.get("series").slice() }, getSeriesCount: function() { return this._componentsMap.get("series").length }, eachSeries: function(t, e) { f(this._seriesIndices, function(n) { var i = this._componentsMap.get("series")[n];
                    t.call(e, i, n) }, this) }, eachRawSeries: function(t, e) { f(this._componentsMap.get("series"), t, e) }, eachSeriesByType: function(t, e, n) { f(this._seriesIndices, function(i) { var r = this._componentsMap.get("series")[i];
                    r.subType === t && e.call(n, r, i) }, this) }, eachRawSeriesByType: function(t, e, n) { return f(this.getSeriesByType(t), e, n) }, isSeriesFiltered: function(t) { return null == this._seriesIndicesMap.get(t.componentIndex) }, getCurrentSeriesIndices: function() { return (this._seriesIndices || []).slice() }, filterSeries: function(t, e) { var n = v(this._componentsMap.get("series"), t, e);
                Ss(this, n) }, restoreData: function(t) { var e = this._componentsMap;
                Ss(this, e.get("series")); var n = [];
                e.each(function(t, e) { n.push(e) }), sS.topologicalTravel(n, sS.getAllClassMainTypes(), function(n) { f(e.get(n), function(e) {
                        ("series" !== n || !xs(e, t)) && e.restoreData() }) }) } });
    c(MS, cS);
    var SS = ["getDom", "getZr", "getWidth", "getHeight", "getDevicePixelRatio", "dispatchAction", "isDisposed", "on", "off", "getDataURL", "getConnectedDataURL", "getModel", "getOption", "getViewOfComponentModel", "getViewOfSeriesModel"],
        IS = {};
    Cs.prototype = { constructor: Cs, create: function(t, e) { var n = [];
            f(IS, function(i) { var r = i.create(t, e);
                n = n.concat(r || []) }), this._coordinateSystems = n }, update: function(t, e) { f(this._coordinateSystems, function(n) { n.update && n.update(t, e) }) }, getCoordinateSystems: function() { return this._coordinateSystems.slice() } }, Cs.register = function(t, e) { IS[t] = e }, Cs.get = function(t) { return IS[t] };
    var TS = f,
        CS = i,
        AS = p,
        DS = r,
        kS = /^(min|max)?(.+)$/;
    As.prototype = { constructor: As, setOption: function(t, e) { t && f(er(t.series), function(t) { t && t.data && I(t.data) && E(t.data) }), t = CS(t); var n = this._optionBackup,
                i = Ds.call(this, t, e, !n);
            this._newBaseOption = i.baseOption, n ? (Os(n.baseOption, i.baseOption), i.timelineOptions.length && (n.timelineOptions = i.timelineOptions), i.mediaList.length && (n.mediaList = i.mediaList), i.mediaDefault && (n.mediaDefault = i.mediaDefault)) : this._optionBackup = i }, mountOption: function(t) { var e = this._optionBackup; return this._timelineOptions = AS(e.timelineOptions, CS), this._mediaList = AS(e.mediaList, CS), this._mediaDefault = CS(e.mediaDefault), this._currentMediaIndices = [], CS(t ? e.baseOption : this._newBaseOption) }, getTimelineOption: function(t) { var e, n = this._timelineOptions; if (n.length) { var i = t.getComponent("timeline");
                i && (e = CS(n[i.getCurrentIndex()], !0)) } return e }, getMediaOption: function() { var t = this._api.getWidth(),
                e = this._api.getHeight(),
                n = this._mediaList,
                i = this._mediaDefault,
                r = [],
                a = []; if (!n.length && !i) return a; for (var o = 0, s = n.length; s > o; o++) ks(n[o].query, t, e) && r.push(o); return !r.length && i && (r = [-1]), r.length && !Ls(r, this._currentMediaIndices) && (a = AS(r, function(t) { return CS(-1 === t ? i.option : n[t].option) })), this._currentMediaIndices = r, a } };
    var PS = f,
        LS = M,
        OS = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"],
        zS = function(t, e) { PS(Fs(t.series), function(t) { LS(t) && Vs(t) }); var n = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
            e && n.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), PS(n, function(e) { PS(Fs(t[e]), function(t) { t && (Bs(t, "axisLabel"), Bs(t.axisPointer, "label")) }) }), PS(Fs(t.parallel), function(t) { var e = t && t.parallelAxisDefault;
                Bs(e, "axisLabel"), Bs(e && e.axisPointer, "label") }), PS(Fs(t.calendar), function(t) { Es(t, "itemStyle"), Bs(t, "dayLabel"), Bs(t, "monthLabel"), Bs(t, "yearLabel") }), PS(Fs(t.radar), function(t) { Bs(t, "name") }), PS(Fs(t.geo), function(t) { LS(t) && (Ns(t), PS(Fs(t.regions), function(t) { Ns(t) })) }), PS(Fs(t.timeline), function(t) { Ns(t), Es(t, "label"), Es(t, "itemStyle"), Es(t, "controlStyle", !0); var e = t.data;
                _(e) && f(e, function(t) { M(t) && (Es(t, "label"), Es(t, "itemStyle")) }) }), PS(Fs(t.toolbox), function(t) { Es(t, "iconStyle"), PS(t.feature, function(t) { Es(t, "iconStyle") }) }), Bs(Hs(t.axisPointer), "label"), Bs(Hs(t.tooltip).axisPointer, "label") },
        ES = [
            ["x", "left"],
            ["y", "top"],
            ["x2", "right"],
            ["y2", "bottom"]
        ],
        RS = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"],
        BS = function(t, e) {
            zS(t, e), t.series = er(t.series), f(t.series, function(t) {
                if (M(t)) {
                    var e = t.type;
                    if ("line" === e) null != t.clipOverflow && (t.clip = t.clipOverflow);
                    else if ("pie" === e || "gauge" === e) null != t.clockWise && (t.clockwise = t.clockWise);
                    else if ("gauge" === e) { var n = Gs(t, "pointer.color");
                        null != n && Ws(t, "itemStyle.color", n) }
                    Zs(t)
                }
            }), t.dataRange && (t.visualMap = t.dataRange), f(RS, function(e) { var n = t[e];
                n && (_(n) || (n = [n]), f(n, function(t) { Zs(t) })) })
        },
        NS = function(t) { var e = N();
            t.eachSeries(function(t) { var n = t.get("stack"); if (n) { var i = e.get(n) || e.set(n, []),
                        r = t.getData(),
                        a = { stackResultDimension: r.getCalculationInfo("stackResultDimension"), stackedOverDimension: r.getCalculationInfo("stackedOverDimension"), stackedDimension: r.getCalculationInfo("stackedDimension"), stackedByDimension: r.getCalculationInfo("stackedByDimension"), isStackedByIndex: r.getCalculationInfo("isStackedByIndex"), data: r, seriesModel: t }; if (!a.stackedDimension || !a.isStackedByIndex && !a.stackedByDimension) return;
                    i.length && r.setCalculationInfo("stackedOnSeries", i[i.length - 1].seriesModel), i.push(a) } }), e.each(Us) },
        VS = Xs.prototype;
    VS.pure = !1, VS.persistent = !0, VS.getSource = function() { return this._source };
    var FS = { arrayRows_column: { pure: !0, count: function() { return Math.max(0, this._data.length - this._source.startIndex) }, getItem: function(t) { return this._data[t + this._source.startIndex] }, appendData: qs }, arrayRows_row: { pure: !0, count: function() { var t = this._data[0]; return t ? Math.max(0, t.length - this._source.startIndex) : 0 }, getItem: function(t) { t += this._source.startIndex; for (var e = [], n = this._data, i = 0; i < n.length; i++) { var r = n[i];
                        e.push(r ? r[t] : null) } return e }, appendData: function() { throw new Error('Do not support appendData when set seriesLayoutBy: "row".') } }, objectRows: { pure: !0, count: Ys, getItem: js, appendData: qs }, keyedColumns: { pure: !0, count: function() { var t = this._source.dimensionsDefine[0].name,
                        e = this._data[t]; return e ? e.length : 0 }, getItem: function(t) { for (var e = [], n = this._source.dimensionsDefine, i = 0; i < n.length; i++) { var r = this._data[n[i].name];
                        e.push(r ? r[t] : null) } return e }, appendData: function(t) { var e = this._data;
                    f(t, function(t, n) { for (var i = e[n] || (e[n] = []), r = 0; r < (t || []).length; r++) i.push(t[r]) }) } }, original: { count: Ys, getItem: js, appendData: qs }, typedArray: { persistent: !1, pure: !0, count: function() { return this._data ? this._data.length / this._dimSize : 0 }, getItem: function(t, e) { t -= this._offset, e = e || []; for (var n = this._dimSize * t, i = 0; i < this._dimSize; i++) e[i] = this._data[n + i]; return e }, appendData: function(t) { this._data = t }, clean: function() { this._offset += this.count(), this._data = null } } },
        HS = { arrayRows: Ks, objectRows: function(t, e, n, i) { return null != n ? t[i] : t }, keyedColumns: Ks, original: function(t, e, n) { var i = ir(t); return null != n && i instanceof Array ? i[n] : i }, typedArray: Ks },
        GS = { arrayRows: $s, objectRows: function(t, e) { return Qs(t[e], this._dimensionInfos[e]) }, keyedColumns: $s, original: function(t, e, n, i) { var r = t && (null == t.value ? t : t.value); return !this._rawData.pure && rr(t) && (this.hasItemOption = !0), Qs(r instanceof Array ? r[i] : r, this._dimensionInfos[e]) }, typedArray: function(t, e, n, i) { return t[i] } },
        WS = /\{@(.+?)\}/g,
        ZS = { getDataParams: function(t, e) { var n = this.getData(e),
                    i = this.getRawValue(t, e),
                    r = n.getRawIndex(t),
                    a = n.getName(t),
                    o = n.getRawDataItem(t),
                    s = n.getItemVisual(t, "color"),
                    l = n.getItemVisual(t, "borderColor"),
                    u = this.ecModel.getComponent("tooltip"),
                    h = u && u.get("renderMode"),
                    c = vr(h),
                    d = this.mainType,
                    f = "series" === d,
                    p = n.userOutput; return { componentType: d, componentSubType: this.subType, componentIndex: this.componentIndex, seriesType: f ? this.subType : null, seriesIndex: this.seriesIndex, seriesId: f ? this.id : null, seriesName: f ? this.name : null, name: a, dataIndex: r, data: o, dataType: e, value: i, color: s, borderColor: l, dimensionNames: p ? p.dimensionNames : null, encode: p ? p.encode : null, marker: Uo({ color: s, renderMode: c }), $vars: ["seriesName", "name", "value"] } }, getFormattedLabel: function(t, e, n, i, r) { e = e || "normal"; var a = this.getData(n),
                    o = a.getItemModel(t),
                    s = this.getDataParams(t, n);
                null != i && s.value instanceof Array && (s.value = s.value[i]); var l = o.get("normal" === e ? [r || "label", "formatter"] : [e, r || "label", "formatter"]); if ("function" == typeof l) return s.status = e, s.dimensionIndex = i, l(s); if ("string" == typeof l) { var u = Wo(l, s); return u.replace(WS, function(e, n) { var i = n.length; return "[" === n.charAt(0) && "]" === n.charAt(i - 1) && (n = +n.slice(1, i - 1)), Js(a, t, n) }) } }, getRawValue: function(t, e) { return Js(this.getData(e), t) }, formatTooltip: function() {} },
        US = nl.prototype;
    US.perform = function(t) {
        function e(t) { return !(t >= 1) && (t = 1), t } var n = this._upstream,
            i = t && t.skip; if (this._dirty && n) { var r = this.context;
            r.data = r.outputData = n.context.outputData }
        this.__pipeline && (this.__pipeline.currentTask = this); var a;
        this._plan && !i && (a = this._plan(this.context)); var o = e(this._modBy),
            s = this._modDataCount || 0,
            l = e(t && t.modBy),
            u = t && t.modDataCount || 0;
        (o !== l || s !== u) && (a = "reset"); var h;
        (this._dirty || "reset" === a) && (this._dirty = !1, h = rl(this, i)), this._modBy = l, this._modDataCount = u; var c = t && t.step; if (this._dueEnd = n ? n._outputDueEnd : this._count ? this._count(this.context) : 1 / 0, this._progress) { var d = this._dueIndex,
                f = Math.min(null != c ? this._dueIndex + c : 1 / 0, this._dueEnd); if (!i && (h || f > d)) { var p = this._progress; if (_(p))
                    for (var g = 0; g < p.length; g++) il(this, p[g], d, f, l, u);
                else il(this, p, d, f, l, u) }
            this._dueIndex = f; var v = null != this._settedOutputEnd ? this._settedOutputEnd : f;
            this._outputDueEnd = v } else this._dueIndex = this._outputDueEnd = null != this._settedOutputEnd ? this._settedOutputEnd : this._dueEnd; return this.unfinished() };
    var XS = function() {
        function t() { return n > i ? i++ : null }

        function e() { var t = i % o * r + Math.ceil(i / o),
                e = i >= n ? null : a > t ? t : i; return i++, e } var n, i, r, a, o, s = { reset: function(l, u, h, c) { i = l, n = u, r = h, a = c, o = Math.ceil(a / r), s.next = r > 1 && a > 0 ? e : t } }; return s }();
    US.dirty = function() { this._dirty = !0, this._onDirty && this._onDirty(this.context) }, US.unfinished = function() { return this._progress && this._dueIndex < this._dueEnd }, US.pipe = function(t) {
        (this._downstream !== t || this._dirty) && (this._downstream = t, t._upstream = this, t.dirty()) }, US.dispose = function() { this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0) }, US.getUpstream = function() { return this._upstream }, US.getDownstream = function() { return this._downstream }, US.setOutputEnd = function(t) { this._outputDueEnd = this._settedOutputEnd = t };
    var YS = cr(),
        jS = sS.extend({ type: "series.__base__", seriesIndex: 0, coordinateSystem: null, defaultOption: null, legendVisualProvider: null, visualColorAccessPath: "itemStyle.color", visualBorderColorAccessPath: "itemStyle.borderColor", layoutMode: null, init: function(t, e, n) { this.seriesIndex = this.componentIndex, this.dataTask = el({ count: sl, reset: ll }), this.dataTask.context = { model: this }, this.mergeDefaultAndTheme(t, n), us(this); var i = this.getInitialData(t, n);
                hl(i, this), this.dataTask.context.data = i, YS(this).dataBeforeProcessed = i, al(this) }, mergeDefaultAndTheme: function(t, e) { var n = this.layoutMode,
                    i = n ? es(t) : {},
                    a = this.subType;
                sS.hasClass(a) && (a += "Series"), r(t, e.getTheme().get(this.subType)), r(t, this.getDefaultOption()), nr(t, "label", ["show"]), this.fillDataTextStyle(t.data), n && ts(t, i, n) }, mergeOption: function(t, e) { t = r(this.option, t, !0), this.fillDataTextStyle(t.data); var n = this.layoutMode;
                n && ts(this.option, t, n), us(this); var i = this.getInitialData(t, e);
                hl(i, this), this.dataTask.dirty(), this.dataTask.context.data = i, YS(this).dataBeforeProcessed = i, al(this) }, fillDataTextStyle: function(t) { if (t && !I(t))
                    for (var e = ["show"], n = 0; n < t.length; n++) t[n] && t[n].label && nr(t[n], "label", e) }, getInitialData: function() {}, appendData: function(t) { var e = this.getRawData();
                e.appendData(t.data) }, getData: function(t) { var e = dl(this); if (e) { var n = e.context.data; return null == t ? n : n.getLinkedData(t) } return YS(this).data }, setData: function(t) { var e = dl(this); if (e) { var n = e.context;
                    n.data !== t && e.modifyOutputEnd && e.setOutputEnd(t.count()), n.outputData = t, e !== this.dataTask && (n.data = t) }
                YS(this).data = t }, getSource: function() { return ss(this) }, getRawData: function() { return YS(this).dataBeforeProcessed }, getBaseAxis: function() { var t = this.coordinateSystem; return t && t.getBaseAxis && t.getBaseAxis() }, formatTooltip: function(t, e, n, i) {
                function r(n) {
                    function r(t, n) { var r = c.getDimensionInfo(n); if (r && r.otherDims.tooltip !== !1) { var d = r.type,
                                f = "sub" + o.seriesIndex + "at" + h,
                                p = Uo({ color: y, type: "subItem", renderMode: i, markerId: f }),
                                g = "string" == typeof p ? p : p.content,
                                v = (a ? g + Go(r.displayName || "-") + ": " : "") + Go("ordinal" === d ? t + "" : "time" === d ? e ? "" : Yo("yyyy/MM/dd hh:mm:ss", t) : Fo(t));
                            v && s.push(v), l && (u[f] = y, ++h) } } var a = g(n, function(t, e, n) { var i = c.getDimensionInfo(n); return t |= i && i.tooltip !== !1 && null != i.displayName }, 0),
                        s = [];
                    d.length ? f(d, function(e) { r(Js(c, t, e), e) }) : f(n, r); var p = a ? l ? "\n" : "<br/>" : "",
                        v = p + s.join(p || ", "); return { renderMode: i, content: v, style: u } }

                function a(t) { return { renderMode: i, content: Go(Fo(t)), style: u } } var o = this;
                i = i || "html"; var s = "html" === i ? "<br/>" : "\n",
                    l = "richText" === i,
                    u = {},
                    h = 0,
                    c = this.getData(),
                    d = c.mapDimension("defaultedTooltip", !0),
                    p = d.length,
                    v = this.getRawValue(t),
                    m = _(v),
                    y = c.getItemVisual(t, "color");
                M(y) && y.colorStops && (y = (y.colorStops[0] || {}).color), y = y || "transparent"; var x = p > 1 || m && !p ? r(v) : a(p ? Js(c, t, d[0]) : m ? v[0] : v),
                    b = x.content,
                    w = o.seriesIndex + "at" + h,
                    S = Uo({ color: y, type: "item", renderMode: i, markerId: w });
                u[w] = y, ++h; var I = c.getName(t),
                    T = this.name;
                sr(this) || (T = ""), T = T ? Go(T) + (e ? ": " : s) : ""; var C = "string" == typeof S ? S : S.content,
                    A = e ? C + T + b : T + C + (I ? Go(I) + ": " + b : b); return { html: A, markers: u } }, isAnimationEnabled: function() { if (Sx.node) return !1; var t = this.getShallow("animation"); return t && this.getData().count() > this.getShallow("animationThreshold") && (t = !1), t }, restoreData: function() { this.dataTask.dirty() }, getColorFromPalette: function(t, e, n) { var i = this.ecModel,
                    r = cS.getColorFromPalette.call(this, t, e, n); return r || (r = i.getColorFromPalette(t, e, n)), r }, coordDimToDataDim: function(t) { return this.getRawData().mapDimension(t, !0) }, getProgressive: function() { return this.get("progressive") }, getProgressiveThreshold: function() { return this.get("progressiveThreshold") }, getAxisTooltipData: null, getTooltipPosition: null, pipeTask: null, preventIncremental: null, pipelineContext: null });
    c(jS, ZS), c(jS, cS);
    var qS = function() { this.group = new N_, this.uid = xo("viewComponent") };
    qS.prototype = { constructor: qS, init: function() {}, render: function() {}, dispose: function() {}, filterForExposedEvent: null };
    var KS = qS.prototype;
    KS.updateView = KS.updateLayout = KS.updateVisual = function() {}, xr(qS), Mr(qS, { registerWhenExtend: !0 });
    var $S = function() { var t = cr(); return function(e) { var n = t(e),
                    i = e.pipelineContext,
                    r = n.large,
                    a = n.progressiveRender,
                    o = n.large = i && i.large,
                    s = n.progressiveRender = i && i.progressiveRender; return !!(r ^ o || a ^ s) && "reset" } },
        QS = cr(),
        JS = $S();
    fl.prototype = { type: "chart", init: function() {}, render: function() {}, highlight: function(t, e, n, i) { gl(t.getData(), i, "emphasis") }, downplay: function(t, e, n, i) { gl(t.getData(), i, "normal") }, remove: function() { this.group.removeAll() }, dispose: function() {}, incrementalPrepareRender: null, incrementalRender: null, updateTransform: null, filterForExposedEvent: null };
    var tI = fl.prototype;
    tI.updateView = tI.updateLayout = tI.updateVisual = function(t, e, n, i) { this.render(t, e, n, i) }, xr(fl, ["dispose"]), Mr(fl, { registerWhenExtend: !0 }), fl.markUpdateMethod = function(t, e) { QS(t).updateMethod = e };
    var eI = { incrementalPrepareRender: { progress: function(t, e) { e.view.incrementalRender(t, e.model, e.ecModel, e.api, e.payload) } }, render: { forceFirstProgress: !0, progress: function(t, e) { e.view.render(e.model, e.ecModel, e.api, e.payload) } } },
        nI = "\x00__throttleOriginMethod",
        iI = "\x00__throttleRate",
        rI = "\x00__throttleType",
        aI = { createOnAllSeries: !0, performRawSeries: !0, reset: function(t, e) { var n = t.getData(),
                    i = (t.visualColorAccessPath || "itemStyle.color").split("."),
                    r = t.get(i),
                    a = !b(r) || r instanceof yM ? null : r;
                (!r || a) && (r = t.getColorFromPalette(t.name, null, e.getSeriesCount())), n.setVisual("color", r); var o = (t.visualBorderColorAccessPath || "itemStyle.borderColor").split("."),
                    s = t.get(o); if (n.setVisual("borderColor", s), !e.isSeriesFiltered(t)) { a && n.each(function(e) { n.setItemVisual(e, "color", a(t.getDataParams(e))) }); var l = function(t, e) { var n = t.getItemModel(e),
                            r = n.get(i, !0),
                            a = n.get(o, !0);
                        null != r && t.setItemVisual(e, "color", r), null != a && t.setItemVisual(e, "borderColor", a) }; return { dataEach: n.hasItemOption ? l : null } } } },
        oI = { legend: { selector: { all: "全选", inverse: "反选" } }, toolbox: { brush: { title: { rect: "矩形选择", polygon: "圈选", lineX: "横向选择", lineY: "纵向选择", keep: "保持选择", clear: "清除选择" } }, dataView: { title: "数据视图", lang: ["数据视图", "关闭", "刷新"] }, dataZoom: { title: { zoom: "区域缩放", back: "区域缩放还原" } }, magicType: { title: { line: "切换为折线图", bar: "切换为柱状图", stack: "切换为堆叠", tiled: "切换为平铺" } }, restore: { title: "还原" }, saveAsImage: { title: "保存为图片", lang: ["右键另存为图片"] } }, series: { typeNames: { pie: "饼图", bar: "柱状图", line: "折线图", scatter: "散点图", effectScatter: "涟漪散点图", radar: "雷达图", tree: "树图", treemap: "矩形树图", boxplot: "箱型图", candlestick: "K线图", k: "K线图", heatmap: "热力图", map: "地图", parallel: "平行坐标图", lines: "线图", graph: "关系图", sankey: "桑基图", funnel: "漏斗图", gauge: "仪表盘图", pictorialBar: "象形柱图", themeRiver: "主题河流图", sunburst: "旭日图" } }, aria: { general: { withTitle: "这是一个关于“{title}”的图表。", withoutTitle: "这是一个图表，" }, series: { single: { prefix: "", withName: "图表类型是{seriesType}，表示{seriesName}。", withoutName: "图表类型是{seriesType}。" }, multiple: { prefix: "它由{seriesCount}个图表系列组成。", withName: "第{seriesId}个系列是一个表示{seriesName}的{seriesType}，", withoutName: "第{seriesId}个系列是一个{seriesType}，", separator: { middle: "；", end: "。" } } }, data: { allData: "其数据是——", partialData: "其中，前{displayCnt}项是——", withName: "{name}的数据是{value}", withoutName: "{value}", separator: { middle: "，", end: "" } } } },
        sI = function(t, e) {
            function n(t, e) { if ("string" != typeof t) return t; var n = t; return f(e, function(t, e) { n = n.replace(new RegExp("\\{\\s*" + e + "\\s*\\}", "g"), t) }), n }

            function i(t) { var e = o.get(t); if (null == e) { for (var n = t.split("."), i = oI.aria, r = 0; r < n.length; ++r) i = i[n[r]]; return i } return e }

            function r() { var t = e.getModel("title").option; return t && t.length && (t = t[0]), t && t.text }

            function a(t) { return oI.series.typeNames[t] || "自定义图" } var o = e.getModel("aria"); if (o.get("show")) { if (o.get("description")) return void t.setAttribute("aria-label", o.get("description")); var s = 0;
                e.eachSeries(function() {++s }, this); var l, u = o.get("data.maxCount") || 10,
                    h = o.get("series.maxCount") || 10,
                    c = Math.min(s, h); if (!(1 > s)) { var d = r();
                    l = d ? n(i("general.withTitle"), { title: d }) : i("general.withoutTitle"); var p = [],
                        g = s > 1 ? "series.multiple.prefix" : "series.single.prefix";
                    l += n(i(g), { seriesCount: s }), e.eachSeries(function(t, e) { if (c > e) { var r, o = t.get("name"),
                                l = "series." + (s > 1 ? "multiple" : "single") + ".";
                            r = i(o ? l + "withName" : l + "withoutName"), r = n(r, { seriesId: t.seriesIndex, seriesName: t.get("name"), seriesType: a(t.subType) }); var h = t.getData();
                            window.data = h, r += h.count() > u ? n(i("data.partialData"), { displayCnt: u }) : i("data.allData"); for (var d = [], f = 0; f < h.count(); f++)
                                if (u > f) { var g = h.getName(f),
                                        v = Js(h, f);
                                    d.push(n(i(g ? "data.withName" : "data.withoutName"), { name: g, value: v })) }
                            r += d.join(i("data.separator.middle")) + i("data.separator.end"), p.push(r) } }), l += p.join(i("series.multiple.separator.middle")) + i("series.multiple.separator.end"), t.setAttribute("aria-label", l) } } },
        lI = Math.PI,
        uI = function(t, e) { e = e || {}, s(e, { text: "loading", color: "#c23531", textColor: "#000", maskColor: "rgba(255, 255, 255, 0.8)", zlevel: 0 }); var n = new cM({ style: { fill: e.maskColor }, zlevel: e.zlevel, z: 1e4 }),
                i = new vM({ shape: { startAngle: -lI / 2, endAngle: -lI / 2 + .1, r: 10 }, style: { stroke: e.color, lineCap: "round", lineWidth: 5 }, zlevel: e.zlevel, z: 10001 }),
                r = new cM({ style: { fill: "none", text: e.text, textPosition: "right", textDistance: 10, textFill: e.textColor }, zlevel: e.zlevel, z: 10001 });
            i.animateShape(!0).when(1e3, { endAngle: 3 * lI / 2 }).start("circularInOut"), i.animateShape(!0).when(1e3, { startAngle: 3 * lI / 2 }).delay(300).start("circularInOut"); var a = new N_; return a.add(i), a.add(r), a.add(n), a.resize = function() { var e = t.getWidth() / 2,
                    a = t.getHeight() / 2;
                i.setShape({ cx: e, cy: a }); var o = i.shape.r;
                r.setShape({ x: e - o, y: a - o, width: 2 * o, height: 2 * o }), n.setShape({ x: 0, y: 0, width: t.getWidth(), height: t.getHeight() }) }, a.resize(), a },
        hI = bl.prototype;
    hI.restoreData = function(t, e) { t.restoreData(e), this._stageTaskMap.each(function(t) { var e = t.overallTask;
            e && e.dirty() }) }, hI.getPerformArgs = function(t, e) { if (t.__pipeline) { var n = this._pipelineMap.get(t.__pipeline.id),
                i = n.context,
                r = !e && n.progressiveEnabled && (!i || i.progressiveRender) && t.__idxInPipeline > n.blockIndex,
                a = r ? n.step : null,
                o = i && i.modDataCount,
                s = null != o ? Math.ceil(o / a) : null; return { step: a, modBy: s, modDataCount: o } } }, hI.getPipeline = function(t) { return this._pipelineMap.get(t) }, hI.updateStreamModes = function(t, e) { var n = this._pipelineMap.get(t.uid),
            i = t.getData(),
            r = i.count(),
            a = n.progressiveEnabled && e.incrementalPrepareRender && r >= n.threshold,
            o = t.get("large") && r >= t.get("largeThreshold"),
            s = "mod" === t.get("progressiveChunkMode") ? r : null;
        t.pipelineContext = n.context = { progressiveRender: a, modDataCount: s, large: o } }, hI.restorePipelines = function(t) { var e = this,
            n = e._pipelineMap = N();
        t.eachSeries(function(t) { var i = t.getProgressive(),
                r = t.uid;
            n.set(r, { id: r, head: null, tail: null, threshold: t.getProgressiveThreshold(), progressiveEnabled: i && !(t.preventIncremental && t.preventIncremental()), blockIndex: -1, step: Math.round(i || 700), count: 0 }), Ol(e, t, t.dataTask) }) }, hI.prepareStageTasks = function() { var t = this._stageTaskMap,
            e = this.ecInstance.getModel(),
            n = this.api;
        f(this._allHandlers, function(i) { var r = t.get(i.uid) || t.set(i.uid, []);
            i.reset && Ml(this, i, r, e, n), i.overallReset && Sl(this, i, r, e, n) }, this) }, hI.prepareView = function(t, e, n, i) { var r = t.renderTask,
            a = r.context;
        a.model = e, a.ecModel = n, a.api = i, r.__block = !t.incrementalPrepareRender, Ol(this, e, r) }, hI.performDataProcessorTasks = function(t, e) { wl(this, this._dataProcessorHandlers, t, e, { block: !0 }) }, hI.performVisualTasks = function(t, e, n) { wl(this, this._visualHandlers, t, e, n) }, hI.performSeriesTasks = function(t) { var e;
        t.eachSeries(function(t) { e |= t.dataTask.perform() }), this.unfinished |= e }, hI.plan = function() { this._pipelineMap.each(function(t) { var e = t.tail;
            do { if (e.__block) { t.blockIndex = e.__idxInPipeline; break }
                e = e.getUpstream() } while (e) }) };
    var cI = hI.updatePayload = function(t, e) { "remain" !== e && (t.context.payload = e) },
        dI = Pl(0);
    bl.wrapStageHandler = function(t, e) { return b(t) && (t = { overallReset: t, seriesType: zl(t) }), t.uid = xo("stageHandler"), e && (t.visualType = e), t };
    var fI, pI = {},
        gI = {};
    El(pI, MS), El(gI, Ts), pI.eachSeriesByType = pI.eachRawSeriesByType = function(t) { fI = t }, pI.eachComponent = function(t) { "series" === t.mainType && t.subType && (fI = t.subType) };
    var vI = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"],
        mI = { color: vI, colorLayer: [
                ["#37A2DA", "#ffd85c", "#fd7b5f"],
                ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"],
                ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], vI
            ] },
        yI = "#eee",
        xI = function() { return { axisLine: { lineStyle: { color: yI } }, axisTick: { lineStyle: { color: yI } }, axisLabel: { textStyle: { color: yI } }, splitLine: { lineStyle: { type: "dashed", color: "#aaa" } }, splitArea: { areaStyle: { color: yI } } } },
        _I = ["#dd6b66", "#759aa0", "#e69d87", "#8dc1a9", "#ea7e53", "#eedd78", "#73a373", "#73b9bc", "#7289ab", "#91ca8c", "#f49f42"],
        bI = { color: _I, backgroundColor: "#333", tooltip: { axisPointer: { lineStyle: { color: yI }, crossStyle: { color: yI }, label: { color: "#000" } } }, legend: { textStyle: { color: yI } }, textStyle: { color: yI }, title: { textStyle: { color: yI } }, toolbox: { iconStyle: { normal: { borderColor: yI } } }, dataZoom: { textStyle: { color: yI } }, visualMap: { textStyle: { color: yI } }, timeline: { lineStyle: { color: yI }, itemStyle: { normal: { color: _I[1] } }, label: { normal: { textStyle: { color: yI } } }, controlStyle: { normal: { color: yI, borderColor: yI } } }, timeAxis: xI(), logAxis: xI(), valueAxis: xI(), categoryAxis: xI(), line: { symbol: "circle" }, graph: { color: _I }, gauge: { title: { textStyle: { color: yI } } }, candlestick: { itemStyle: { normal: { color: "#FD1050", color0: "#0CF49B", borderColor: "#FD1050", borderColor0: "#0CF49B" } } } };
    bI.categoryAxis.splitLine.show = !1, sS.extend({ type: "dataset", defaultOption: { seriesLayoutBy: yS, sourceHeader: null, dimensions: null, source: null }, optionUpdated: function() { os(this) } }), qS.extend({ type: "dataset" });
    var wI = ia.extend({ type: "ellipse", shape: { cx: 0, cy: 0, rx: 0, ry: 0 }, buildPath: function(t, e) { var n = .5522848,
                    i = e.cx,
                    r = e.cy,
                    a = e.rx,
                    o = e.ry,
                    s = a * n,
                    l = o * n;
                t.moveTo(i - a, r), t.bezierCurveTo(i - a, r - l, i - s, r - o, i, r - o), t.bezierCurveTo(i + s, r - o, i + a, r - l, i + a, r), t.bezierCurveTo(i + a, r + l, i + s, r + o, i, r + o), t.bezierCurveTo(i - s, r + o, i - a, r + l, i - a, r), t.closePath() } }),
        MI = /[\s,]+/;
    Bl.prototype.parse = function(t, e) { e = e || {}; var n = Rl(t); if (!n) throw new Error("Illegal svg"); var i = new N_;
        this._root = i; var r = n.getAttribute("viewBox") || "",
            a = parseFloat(n.getAttribute("width") || e.width),
            o = parseFloat(n.getAttribute("height") || e.height);
        isNaN(a) && (a = null), isNaN(o) && (o = null), Hl(n, i, null, !0); for (var s = n.firstChild; s;) this._parseNode(s, i), s = s.nextSibling; var l, u; if (r) { var h = z(r).split(MI);
            h.length >= 4 && (l = { x: parseFloat(h[0] || 0), y: parseFloat(h[1] || 0), width: parseFloat(h[2]), height: parseFloat(h[3]) }) } if (l && null != a && null != o && (u = Ul(l, a, o), !e.ignoreViewBox)) { var c = i;
            i = new N_, i.add(c), c.scale = u.scale.slice(), c.position = u.position.slice() } return e.ignoreRootClip || null == a || null == o || i.setClipPath(new cM({ shape: { x: 0, y: 0, width: a, height: o } })), { root: i, width: a, height: o, viewBoxRect: l, viewBoxTransform: u } }, Bl.prototype._parseNode = function(t, e) { var n = t.nodeName.toLowerCase(); "defs" === n ? this._isDefine = !0 : "text" === n && (this._isText = !0); var i; if (this._isDefine) { var r = II[n]; if (r) { var a = r.call(this, t),
                    o = t.getAttribute("id");
                o && (this._defs[o] = a) } } else { var r = SI[n];
            r && (i = r.call(this, t, e), e.add(i)) } for (var s = t.firstChild; s;) 1 === s.nodeType && this._parseNode(s, i), 3 === s.nodeType && this._isText && this._parseText(s, i), s = s.nextSibling; "defs" === n ? this._isDefine = !1 : "text" === n && (this._isText = !1) }, Bl.prototype._parseText = function(t, e) { if (1 === t.nodeType) { var n = t.getAttribute("dx") || 0,
                i = t.getAttribute("dy") || 0;
            this._textX += parseFloat(n), this._textY += parseFloat(i) } var r = new Jw({ style: { text: t.textContent, transformText: !0 }, position: [this._textX || 0, this._textY || 0] });
        Vl(e, r), Hl(t, r, this._defs); var a = r.style.fontSize;
        a && 9 > a && (r.style.fontSize = 9, r.scale = r.scale || [1, 1], r.scale[0] *= a / 9, r.scale[1] *= a / 9); var o = r.getBoundingRect(); return this._textX += o.width, e.add(r), r };
    var SI = { g: function(t, e) { var n = new N_; return Vl(e, n), Hl(t, n, this._defs), n }, rect: function(t, e) { var n = new cM; return Vl(e, n), Hl(t, n, this._defs), n.setShape({ x: parseFloat(t.getAttribute("x") || 0), y: parseFloat(t.getAttribute("y") || 0), width: parseFloat(t.getAttribute("width") || 0), height: parseFloat(t.getAttribute("height") || 0) }), n }, circle: function(t, e) { var n = new tM; return Vl(e, n), Hl(t, n, this._defs), n.setShape({ cx: parseFloat(t.getAttribute("cx") || 0), cy: parseFloat(t.getAttribute("cy") || 0), r: parseFloat(t.getAttribute("r") || 0) }), n }, line: function(t, e) { var n = new fM; return Vl(e, n), Hl(t, n, this._defs), n.setShape({ x1: parseFloat(t.getAttribute("x1") || 0), y1: parseFloat(t.getAttribute("y1") || 0), x2: parseFloat(t.getAttribute("x2") || 0), y2: parseFloat(t.getAttribute("y2") || 0) }), n }, ellipse: function(t, e) { var n = new wI; return Vl(e, n), Hl(t, n, this._defs), n.setShape({ cx: parseFloat(t.getAttribute("cx") || 0), cy: parseFloat(t.getAttribute("cy") || 0), rx: parseFloat(t.getAttribute("rx") || 0), ry: parseFloat(t.getAttribute("ry") || 0) }), n }, polygon: function(t, e) { var n = t.getAttribute("points");
                n && (n = Fl(n)); var i = new sM({ shape: { points: n || [] } }); return Vl(e, i), Hl(t, i, this._defs), i }, polyline: function(t, e) { var n = new ia;
                Vl(e, n), Hl(t, n, this._defs); var i = t.getAttribute("points");
                i && (i = Fl(i)); var r = new lM({ shape: { points: i || [] } }); return r }, image: function(t, e) { var n = new Di; return Vl(e, n), Hl(t, n, this._defs), n.setStyle({ image: t.getAttribute("xlink:href"), x: t.getAttribute("x"), y: t.getAttribute("y"), width: t.getAttribute("width"), height: t.getAttribute("height") }), n }, text: function(t, e) { var n = t.getAttribute("x") || 0,
                    i = t.getAttribute("y") || 0,
                    r = t.getAttribute("dx") || 0,
                    a = t.getAttribute("dy") || 0;
                this._textX = parseFloat(n) + parseFloat(r), this._textY = parseFloat(i) + parseFloat(a); var o = new N_; return Vl(e, o), Hl(t, o, this._defs), o }, tspan: function(t, e) { var n = t.getAttribute("x"),
                    i = t.getAttribute("y");
                null != n && (this._textX = parseFloat(n)), null != i && (this._textY = parseFloat(i)); var r = t.getAttribute("dx") || 0,
                    a = t.getAttribute("dy") || 0,
                    o = new N_; return Vl(e, o), Hl(t, o, this._defs), this._textX += r, this._textY += a, o }, path: function(t, e) { var n = t.getAttribute("d") || "",
                    i = sa(n); return Vl(e, i), Hl(t, i, this._defs), i } },
        II = { lineargradient: function(t) { var e = parseInt(t.getAttribute("x1") || 0, 10),
                    n = parseInt(t.getAttribute("y1") || 0, 10),
                    i = parseInt(t.getAttribute("x2") || 10, 10),
                    r = parseInt(t.getAttribute("y2") || 0, 10),
                    a = new xM(e, n, i, r); return Nl(t, a), a }, radialgradient: function() {} },
        TI = { fill: "fill", stroke: "stroke", "stroke-width": "lineWidth", opacity: "opacity", "fill-opacity": "fillOpacity", "stroke-opacity": "strokeOpacity", "stroke-dasharray": "lineDash", "stroke-dashoffset": "lineDashOffset", "stroke-linecap": "lineCap", "stroke-linejoin": "lineJoin", "stroke-miterlimit": "miterLimit", "font-family": "fontFamily", "font-size": "fontSize", "font-style": "fontStyle", "font-weight": "fontWeight", "text-align": "textAlign", "alignment-baseline": "textBaseline" },
        CI = /url\(\s*#(.*?)\)/,
        AI = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.e,]*)\)/g,
        DI = /([^\s:;]+)\s*:\s*([^:;]+)/g,
        kI = N(),
        PI = { registerMap: function(t, e, n) { var i; return _(e) ? i = e : e.svg ? i = [{ type: "svg", source: e.svg, specialAreas: e.specialAreas }] : (e.geoJson && !e.features && (n = e.specialAreas, e = e.geoJson), i = [{ type: "geoJSON", source: e, specialAreas: n }]), f(i, function(t) { var e = t.type; "geoJson" === e && (e = t.type = "geoJSON"); var n = LI[e];
                    n(t) }), kI.set(t, i) }, retrieveMap: function(t) { return kI.get(t) } },
        LI = { geoJSON: function(t) { var e = t.source;
                t.geoJSON = w(e) ? "undefined" != typeof JSON && JSON.parse ? JSON.parse(e) : new Function("return (" + e + ");")() : e }, svg: function(t) { t.svgXML = Rl(t.source) } },
        OI = O,
        zI = f,
        EI = b,
        RI = M,
        BI = sS.parseClassType,
        NI = "4.7.0",
        VI = { zrender: "4.3.0" },
        FI = 1,
        HI = 1e3,
        GI = 800,
        WI = 900,
        ZI = 5e3,
        UI = 1e3,
        XI = 1100,
        YI = 2e3,
        jI = 3e3,
        qI = 3500,
        KI = 4e3,
        $I = 5e3,
        QI = { PROCESSOR: { FILTER: HI, SERIES_FILTER: GI, STATISTIC: ZI }, VISUAL: { LAYOUT: UI, PROGRESSIVE_LAYOUT: XI, GLOBAL: YI, CHART: jI, POST_CHART_LAYOUT: qI, COMPONENT: KI, BRUSH: $I } },
        JI = "__flagInMainProcess",
        tT = "__optionUpdated",
        eT = /^[a-zA-Z0-9_]+$/;
    Yl.prototype.on = Xl("on", !0), Yl.prototype.off = Xl("off", !0), Yl.prototype.one = Xl("one", !0), c(Yl, Xx);
    var nT = jl.prototype;
    nT._onframe = function() { if (!this._disposed) { var t = this._scheduler; if (this[tT]) { var e = this[tT].silent;
                this[JI] = !0, Kl(this), iT.update.call(this), this[JI] = !1, this[tT] = !1, tu.call(this, e), eu.call(this, e) } else if (t.unfinished) { var n = FI,
                    i = this._model,
                    r = this._api;
                t.unfinished = !1;
                do { var a = +new Date;
                    t.performSeriesTasks(i), t.performDataProcessorTasks(i), Ql(this, i), t.performVisualTasks(i), su(this, this._model, r, "remain"), n -= +new Date - a } while (n > 0 && t.unfinished);
                t.unfinished || this._zr.flush() } } }, nT.getDom = function() { return this._dom }, nT.getZr = function() { return this._zr }, nT.setOption = function(t, e, n) { if (!this._disposed) { var i; if (RI(e) && (n = e.lazyUpdate, i = e.silent, e = e.notMerge), this[JI] = !0, !this._model || e) { var r = new As(this._api),
                    a = this._theme,
                    o = this._model = new MS;
                o.scheduler = this._scheduler, o.init(null, null, a, r) }
            this._model.setOption(t, lT), n ? (this[tT] = { silent: i }, this[JI] = !1) : (Kl(this), iT.update.call(this), this._zr.flush(), this[tT] = !1, this[JI] = !1, tu.call(this, i), eu.call(this, i)) } }, nT.setTheme = function() { console.error("ECharts#setTheme() is DEPRECATED in ECharts 3.0") }, nT.getModel = function() { return this._model }, nT.getOption = function() { return this._model && this._model.getOption() }, nT.getWidth = function() { return this._zr.getWidth() }, nT.getHeight = function() { return this._zr.getHeight() }, nT.getDevicePixelRatio = function() { return this._zr.painter.dpr || window.devicePixelRatio || 1 }, nT.getRenderedCanvas = function(t) { if (Sx.canvasSupported) { t = t || {}, t.pixelRatio = t.pixelRatio || 1, t.backgroundColor = t.backgroundColor || this._model.get("backgroundColor"); var e = this._zr; return e.painter.getRenderedCanvas(t) } }, nT.getSvgDataUrl = function() { if (Sx.svgSupported) { var t = this._zr,
                e = t.storage.getDisplayList(); return f(e, function(t) { t.stopAnimation(!0) }), t.painter.pathToDataUrl() } }, nT.getDataURL = function(t) { if (!this._disposed) { t = t || {}; var e = t.excludeComponents,
                n = this._model,
                i = [],
                r = this;
            zI(e, function(t) { n.eachComponent({ mainType: t }, function(t) { var e = r._componentsMap[t.__viewId];
                    e.group.ignore || (i.push(e), e.group.ignore = !0) }) }); var a = "svg" === this._zr.painter.getType() ? this.getSvgDataUrl() : this.getRenderedCanvas(t).toDataURL("image/" + (t && t.type || "png")); return zI(i, function(t) { t.group.ignore = !1 }), a } }, nT.getConnectedDataURL = function(t) { if (!this._disposed && Sx.canvasSupported) { var e = this.group,
                n = Math.min,
                r = Math.max,
                a = 1 / 0; if (pT[e]) { var o = a,
                    s = a,
                    l = -a,
                    u = -a,
                    h = [],
                    c = t && t.pixelRatio || 1;
                f(fT, function(a) { if (a.group === e) { var c = a.getRenderedCanvas(i(t)),
                            d = a.getDom().getBoundingClientRect();
                        o = n(d.left, o), s = n(d.top, s), l = r(d.right, l), u = r(d.bottom, u), h.push({ dom: c, left: d.left, top: d.top }) } }), o *= c, s *= c, l *= c, u *= c; var d = l - o,
                    p = u - s,
                    g = Ex();
                g.width = d, g.height = p; var v = Ki(g); return t.connectedBackgroundColor && v.add(new cM({ shape: { x: 0, y: 0, width: d, height: p }, style: { fill: t.connectedBackgroundColor } })), zI(h, function(t) { var e = new Di({ style: { x: t.left * c - o, y: t.top * c - s, image: t.dom } });
                    v.add(e) }), v.refreshImmediately(), g.toDataURL("image/" + (t && t.type || "png")) } return this.getDataURL(t) } }, nT.convertToPixel = x(ql, "convertToPixel"), nT.convertFromPixel = x(ql, "convertFromPixel"), nT.containPixel = function(t, e) { if (!this._disposed) { var n, i = this._model; return t = dr(i, t), f(t, function(t, i) { i.indexOf("Models") >= 0 && f(t, function(t) { var r = t.coordinateSystem; if (r && r.containPoint) n |= !!r.containPoint(e);
                    else if ("seriesModels" === i) { var a = this._chartsMap[t.__viewId];
                        a && a.containPoint && (n |= a.containPoint(e, t)) } }, this) }, this), !!n } }, nT.getVisual = function(t, e) { var n = this._model;
        t = dr(n, t, { defaultMainType: "series" }); var i = t.seriesModel,
            r = i.getData(),
            a = t.hasOwnProperty("dataIndexInside") ? t.dataIndexInside : t.hasOwnProperty("dataIndex") ? r.indexOfRawIndex(t.dataIndex) : null; return null != a ? r.getItemVisual(a, e) : r.getVisual(e) }, nT.getViewOfComponentModel = function(t) { return this._componentsMap[t.__viewId] }, nT.getViewOfSeriesModel = function(t) { return this._chartsMap[t.__viewId] };
    var iT = { prepareAndUpdate: function(t) { Kl(this), iT.update.call(this, t) }, update: function(t) { var e = this._model,
                n = this._api,
                i = this._zr,
                r = this._coordSysMgr,
                a = this._scheduler; if (e) { a.restoreData(e, t), a.performSeriesTasks(e), r.create(e, n), a.performDataProcessorTasks(e, t), Ql(this, e), r.update(e, n), ru(e), a.performVisualTasks(e, t), au(this, e, n, t); var o = e.get("backgroundColor") || "transparent"; if (Sx.canvasSupported) i.setBackgroundColor(o);
                else { var s = tn(o);
                    o = hn(s, "rgb"), 0 === s[3] && (o = "transparent") }
                lu(e, n) } }, updateTransform: function(t) { var e = this._model,
                n = this,
                i = this._api; if (e) { var r = [];
                e.eachComponent(function(a, o) { var s = n.getViewOfComponentModel(o); if (s && s.__alive)
                        if (s.updateTransform) { var l = s.updateTransform(o, e, i, t);
                            l && l.update && r.push(s) } else r.push(s) }); var a = N();
                e.eachSeries(function(r) { var o = n._chartsMap[r.__viewId]; if (o.updateTransform) { var s = o.updateTransform(r, e, i, t);
                        s && s.update && a.set(r.uid, 1) } else a.set(r.uid, 1) }), ru(e), this._scheduler.performVisualTasks(e, t, { setDirty: !0, dirtyMap: a }), su(n, e, i, t, a), lu(e, this._api) } }, updateView: function(t) { var e = this._model;
            e && (fl.markUpdateMethod(t, "updateView"), ru(e), this._scheduler.performVisualTasks(e, t, { setDirty: !0 }), au(this, this._model, this._api, t), lu(e, this._api)) }, updateVisual: function(t) { iT.update.call(this, t) }, updateLayout: function(t) { iT.update.call(this, t) } };
    nT.resize = function(t) { if (!this._disposed) { this._zr.resize(t); var e = this._model; if (this._loadingFX && this._loadingFX.resize(), e) { var n = e.resetOption("media"),
                    i = t && t.silent;
                this[JI] = !0, n && Kl(this), iT.update.call(this), this[JI] = !1, tu.call(this, i), eu.call(this, i) } } }, nT.showLoading = function(t, e) { if (!this._disposed && (RI(t) && (e = t, t = ""), t = t || "default", this.hideLoading(), dT[t])) { var n = dT[t](this._api, e),
                i = this._zr;
            this._loadingFX = n, i.add(n) } }, nT.hideLoading = function() { this._disposed || (this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null) }, nT.makeActionFromEvent = function(t) { var e = o({}, t); return e.type = oT[t.type], e }, nT.dispatchAction = function(t, e) { if (!this._disposed && (RI(e) || (e = { silent: !!e }), aT[t.type] && this._model)) { if (this[JI]) return void this._pendingActions.push(t);
            Jl.call(this, t, e.silent), e.flush ? this._zr.flush(!0) : e.flush !== !1 && Sx.browser.weChat && this._throttledZrFlush(), tu.call(this, e.silent), eu.call(this, e.silent) } }, nT.appendData = function(t) { if (!this._disposed) { var e = t.seriesIndex,
                n = this.getModel(),
                i = n.getSeriesByIndex(e);
            i.appendData(t), this._scheduler.unfinished = !0 } }, nT.on = Xl("on", !1), nT.off = Xl("off", !1), nT.one = Xl("one", !1);
    var rT = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
    nT._initEvents = function() {
        zI(rT, function(t) {
            var e = function(e) {
                var n, i = this.getModel(),
                    r = e.target,
                    a = "globalout" === t;
                if (a) n = {};
                else if (r && null != r.dataIndex) { var s = r.dataModel || i.getSeriesByIndex(r.seriesIndex);
                    n = s && s.getDataParams(r.dataIndex, r.dataType, r) || {} } else r && r.eventData && (n = o({}, r.eventData));
                if (n) { var l = n.componentType,
                        u = n.componentIndex;
                    ("markLine" === l || "markPoint" === l || "markArea" === l) && (l = "series", u = n.seriesIndex); var h = l && null != u && i.getComponent(l, u),
                        c = h && this["series" === h.mainType ? "_chartsMap" : "_componentsMap"][h.__viewId];
                    n.event = e, n.type = t, this._ecEventProcessor.eventInfo = { targetEl: r, packedEvent: n, model: h, view: c }, this.trigger(t, n) }
            };
            e.zrEventfulCallAtLast = !0, this._zr.on(t, e, this)
        }, this), zI(oT, function(t, e) { this._messageCenter.on(e, function(t) { this.trigger(e, t) }, this) }, this)
    }, nT.isDisposed = function() { return this._disposed }, nT.clear = function() { this._disposed || this.setOption({ series: [] }, !0) }, nT.dispose = function() { if (!this._disposed) { this._disposed = !0, pr(this.getDom(), mT, ""); var t = this._api,
                e = this._model;
            zI(this._componentsViews, function(n) { n.dispose(e, t) }), zI(this._chartsViews, function(n) { n.dispose(e, t) }), this._zr.dispose(), delete fT[this.id] } }, c(jl, Xx), fu.prototype = { constructor: fu, normalizeQuery: function(t) { var e = {},
                n = {},
                i = {}; if (w(t)) { var r = BI(t);
                e.mainType = r.main || null, e.subType = r.sub || null } else { var a = ["Index", "Name", "Id"],
                    o = { name: 1, dataIndex: 1, dataType: 1 };
                f(t, function(t, r) { for (var s = !1, l = 0; l < a.length; l++) { var u = a[l],
                            h = r.lastIndexOf(u); if (h > 0 && h === r.length - u.length) { var c = r.slice(0, h); "data" !== c && (e.mainType = c, e[u.toLowerCase()] = t, s = !0) } }
                    o.hasOwnProperty(r) && (n[r] = t, s = !0), s || (i[r] = t) }) } return { cptQuery: e, dataQuery: n, otherQuery: i } }, filter: function(t, e) {
            function n(t, e, n, i) { return null == t[n] || e[i || n] === t[n] } var i = this.eventInfo; if (!i) return !0; var r = i.targetEl,
                a = i.packedEvent,
                o = i.model,
                s = i.view; if (!o || !s) return !0; var l = e.cptQuery,
                u = e.dataQuery; return n(l, o, "mainType") && n(l, o, "subType") && n(l, o, "index", "componentIndex") && n(l, o, "name") && n(l, o, "id") && n(u, a, "name") && n(u, a, "dataIndex") && n(u, a, "dataType") && (!s.filterForExposedEvent || s.filterForExposedEvent(t, e.otherQuery, r, a)) }, afterTrigger: function() { this.eventInfo = null } };
    var aT = {},
        oT = {},
        sT = [],
        lT = [],
        uT = [],
        hT = [],
        cT = {},
        dT = {},
        fT = {},
        pT = {},
        gT = new Date - 0,
        vT = new Date - 0,
        mT = "_echarts_instance_",
        yT = mu;
    Du(YI, aI), wu(BS), Mu(WI, NS), Pu("default", uI), Iu({ type: "highlight", event: "highlight", update: "highlight" }, F), Iu({ type: "downplay", event: "downplay", update: "downplay" }, F), bu("light", mI), bu("dark", bI);
    var xT = {};
    Fu.prototype = { constructor: Fu, add: function(t) { return this._add = t, this }, update: function(t) { return this._update = t, this }, remove: function(t) { return this._remove = t, this }, execute: function() { var t, e = this._old,
                n = this._new,
                i = {},
                r = {},
                a = [],
                o = []; for (Hu(e, i, a, "_oldKeyGetter", this), Hu(n, r, o, "_newKeyGetter", this), t = 0; t < e.length; t++) { var s = a[t],
                    l = r[s]; if (null != l) { var u = l.length;
                    u ? (1 === u && (r[s] = null), l = l.shift()) : r[s] = null, this._update && this._update(l, t) } else this._remove && this._remove(t) } for (var t = 0; t < o.length; t++) { var s = o[t]; if (r.hasOwnProperty(s)) { var l = r[s]; if (null == l) continue; if (l.length)
                        for (var h = 0, u = l.length; u > h; h++) this._add && this._add(l[h]);
                    else this._add && this._add(l) } } } };
    var _T = N(["tooltip", "label", "itemName", "itemId", "seriesName"]),
        bT = M,
        wT = "undefined",
        MT = -1,
        ST = "e\x00\x00",
        IT = { "float": typeof Float64Array === wT ? Array : Float64Array, "int": typeof Int32Array === wT ? Array : Int32Array, ordinal: Array, number: Array, time: Array },
        TT = typeof Uint32Array === wT ? Array : Uint32Array,
        CT = typeof Int32Array === wT ? Array : Int32Array,
        AT = typeof Uint16Array === wT ? Array : Uint16Array,
        DT = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_rawData", "_chunkSize", "_chunkCount", "_dimValueGetter", "_count", "_rawCount", "_nameDimIdx", "_idDimIdx"],
        kT = ["_extent", "_approximateExtent", "_rawExtent"],
        PT = function(t, e) { t = t || ["x", "y"]; for (var n = {}, i = [], r = {}, a = 0; a < t.length; a++) { var o = t[a];
                w(o) ? o = new Xu({ name: o }) : o instanceof Xu || (o = new Xu(o)); var s = o.name;
                o.type = o.type || "float", o.coordDim || (o.coordDim = s, o.coordDimIndex = 0), o.otherDims = o.otherDims || {}, i.push(s), n[s] = o, o.index = a, o.createInvertedIndices && (r[s] = []) }
            this.dimensions = i, this._dimensionInfos = n, this.hostModel = e, this.dataType, this._indices = null, this._count = 0, this._rawCount = 0, this._storage = {}, this._nameList = [], this._idList = [], this._optionModels = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this.hasItemVisual = {}, this._itemLayouts = [], this._graphicEls = [], this._chunkSize = 1e5, this._chunkCount = 0, this._rawData, this._rawExtent = {}, this._extent = {}, this._approximateExtent = {}, this._dimensionsSummary = Gu(this), this._invertedIndicesMap = r, this._calculationInfo = {}, this.userOutput = this._dimensionsSummary.userOutput },
        LT = PT.prototype;
    LT.type = "list", LT.hasItemOption = !0, LT.getDimension = function(t) { return ("number" == typeof t || !isNaN(t) && !this._dimensionInfos.hasOwnProperty(t)) && (t = this.dimensions[t]), t }, LT.getDimensionInfo = function(t) { return this._dimensionInfos[this.getDimension(t)] }, LT.getDimensionsOnCoord = function() { return this._dimensionsSummary.dataDimsOnCoord.slice() }, LT.mapDimension = function(t, e) { var n = this._dimensionsSummary; if (null == e) return n.encodeFirstDimNotExtra[t]; var i = n.encode[t]; return e === !0 ? (i || []).slice() : i && i[e] }, LT.initData = function(t, e, n) { var i = as.isInstance(t) || d(t);
        i && (t = new Xs(t, this.dimensions.length)), this._rawData = t, this._storage = {}, this._indices = null, this._nameList = e || [], this._idList = [], this._nameRepeatCount = {}, n || (this.hasItemOption = !1), this.defaultDimValueGetter = GS[this._rawData.getSource().sourceFormat], this._dimValueGetter = n = n || this.defaultDimValueGetter, this._dimValueGetterArrayRows = GS.arrayRows, this._rawExtent = {}, this._initDataFromProvider(0, t.count()), t.pure && (this.hasItemOption = !1) }, LT.getProvider = function() { return this._rawData }, LT.appendData = function(t) { var e = this._rawData,
            n = this.count();
        e.appendData(t); var i = e.count();
        e.persistent || (i += n), this._initDataFromProvider(n, i) }, LT.appendValues = function(t, e) { for (var n = this._chunkSize, i = this._storage, r = this.dimensions, a = r.length, o = this._rawExtent, s = this.count(), l = s + Math.max(t.length, e ? e.length : 0), u = this._chunkCount, h = 0; a > h; h++) { var c = r[h];
            o[c] || (o[c] = ah()), i[c] || (i[c] = []), Ku(i, this._dimensionInfos[c], n, u, l), this._chunkCount = i[c].length } for (var d = new Array(a), f = s; l > f; f++) { for (var p = f - s, g = Math.floor(f / n), v = f % n, m = 0; a > m; m++) { var c = r[m],
                    y = this._dimValueGetterArrayRows(t[p] || d, c, p, m);
                i[c][g][v] = y; var x = o[c];
                y < x[0] && (x[0] = y), y > x[1] && (x[1] = y) }
            e && (this._nameList[f] = e[p]) }
        this._rawCount = this._count = l, this._extent = {}, $u(this) }, LT._initDataFromProvider = function(t, e) { if (!(t >= e)) { for (var n, i = this._chunkSize, r = this._rawData, a = this._storage, o = this.dimensions, s = o.length, l = this._dimensionInfos, u = this._nameList, h = this._idList, c = this._rawExtent, d = this._nameRepeatCount = {}, f = this._chunkCount, p = 0; s > p; p++) { var g = o[p];
                c[g] || (c[g] = ah()); var v = l[g];
                0 === v.otherDims.itemName && (n = this._nameDimIdx = p), 0 === v.otherDims.itemId && (this._idDimIdx = p), a[g] || (a[g] = []), Ku(a, v, i, f, e), this._chunkCount = a[g].length } for (var m = new Array(s), y = t; e > y; y++) { m = r.getItem(y, m); for (var x = Math.floor(y / i), _ = y % i, b = 0; s > b; b++) { var g = o[b],
                        w = a[g][x],
                        M = this._dimValueGetter(m, g, y, b);
                    w[_] = M; var S = c[g];
                    M < S[0] && (S[0] = M), M > S[1] && (S[1] = M) } if (!r.pure) { var I = u[y]; if (m && null == I)
                        if (null != m.name) u[y] = I = m.name;
                        else if (null != n) { var T = o[n],
                            C = a[T][x]; if (C) { I = C[_]; var A = l[T].ordinalMeta;
                            A && A.categories.length && (I = A.categories[I]) } } var D = null == m ? null : m.id;
                    null == D && null != I && (d[I] = d[I] || 0, D = I, d[I] > 0 && (D += "__ec__" + d[I]), d[I]++), null != D && (h[y] = D) } }!r.persistent && r.clean && r.clean(), this._rawCount = this._count = e, this._extent = {}, $u(this) } }, LT.count = function() { return this._count }, LT.getIndices = function() { var t, e = this._indices; if (e) { var n = e.constructor,
                i = this._count; if (n === Array) { t = new n(i); for (var r = 0; i > r; r++) t[r] = e[r] } else t = new n(e.buffer, 0, i) } else
            for (var n = Yu(this), t = new n(this.count()), r = 0; r < t.length; r++) t[r] = r; return t }, LT.get = function(t, e) { if (!(e >= 0 && e < this._count)) return 0 / 0; var n = this._storage; if (!n[t]) return 0 / 0;
        e = this.getRawIndex(e); var i = Math.floor(e / this._chunkSize),
            r = e % this._chunkSize,
            a = n[t][i],
            o = a[r]; return o }, LT.getByRawIndex = function(t, e) { if (!(e >= 0 && e < this._rawCount)) return 0 / 0; var n = this._storage[t]; if (!n) return 0 / 0; var i = Math.floor(e / this._chunkSize),
            r = e % this._chunkSize,
            a = n[i]; return a[r] }, LT._getFast = function(t, e) { var n = Math.floor(e / this._chunkSize),
            i = e % this._chunkSize,
            r = this._storage[t][n]; return r[i] }, LT.getValues = function(t, e) { var n = [];
        _(t) || (e = t, t = this.dimensions); for (var i = 0, r = t.length; r > i; i++) n.push(this.get(t[i], e)); return n }, LT.hasValue = function(t) { for (var e = this._dimensionsSummary.dataDimsOnCoord, n = 0, i = e.length; i > n; n++)
            if (isNaN(this.get(e[n], t))) return !1;
        return !0 }, LT.getDataExtent = function(t) { t = this.getDimension(t); var e = this._storage[t],
            n = ah(); if (!e) return n; var i, r = this.count(),
            a = !this._indices; if (a) return this._rawExtent[t].slice(); if (i = this._extent[t]) return i.slice();
        i = n; for (var o = i[0], s = i[1], l = 0; r > l; l++) { var u = this._getFast(t, this.getRawIndex(l));
            o > u && (o = u), u > s && (s = u) } return i = [o, s], this._extent[t] = i, i }, LT.getApproximateExtent = function(t) { return t = this.getDimension(t), this._approximateExtent[t] || this.getDataExtent(t) }, LT.setApproximateExtent = function(t, e) { e = this.getDimension(e), this._approximateExtent[e] = t.slice() }, LT.getCalculationInfo = function(t) { return this._calculationInfo[t] }, LT.setCalculationInfo = function(t, e) { bT(t) ? o(this._calculationInfo, t) : this._calculationInfo[t] = e }, LT.getSum = function(t) { var e = this._storage[t],
            n = 0; if (e)
            for (var i = 0, r = this.count(); r > i; i++) { var a = this.get(t, i);
                isNaN(a) || (n += a) }
        return n }, LT.getMedian = function(t) { var e = [];
        this.each(t, function(t) { isNaN(t) || e.push(t) }); var n = [].concat(e).sort(function(t, e) { return t - e }),
            i = this.count(); return 0 === i ? 0 : i % 2 === 1 ? n[(i - 1) / 2] : (n[i / 2] + n[i / 2 - 1]) / 2 }, LT.rawIndexOf = function(t, e) { var n = t && this._invertedIndicesMap[t],
            i = n[e]; return null == i || isNaN(i) ? MT : i }, LT.indexOfName = function(t) { for (var e = 0, n = this.count(); n > e; e++)
            if (this.getName(e) === t) return e;
        return -1 }, LT.indexOfRawIndex = function(t) { if (t >= this._rawCount || 0 > t) return -1; if (!this._indices) return t; var e = this._indices,
            n = e[t]; if (null != n && n < this._count && n === t) return t; for (var i = 0, r = this._count - 1; r >= i;) { var a = (i + r) / 2 | 0; if (e[a] < t) i = a + 1;
            else { if (!(e[a] > t)) return a;
                r = a - 1 } } return -1 }, LT.indicesOfNearest = function(t, e, n) { var i = this._storage,
            r = i[t],
            a = []; if (!r) return a;
        null == n && (n = 1 / 0); for (var o = 1 / 0, s = -1, l = 0, u = 0, h = this.count(); h > u; u++) { var c = e - this.get(t, u),
                d = Math.abs(c);
            n >= d && ((o > d || d === o && c >= 0 && 0 > s) && (o = d, s = c, l = 0), c === s && (a[l++] = u)) } return a.length = l, a }, LT.getRawIndex = Ju, LT.getRawDataItem = function(t) { if (this._rawData.persistent) return this._rawData.getItem(this.getRawIndex(t)); for (var e = [], n = 0; n < this.dimensions.length; n++) { var i = this.dimensions[n];
            e.push(this.get(i, t)) } return e }, LT.getName = function(t) { var e = this.getRawIndex(t); return this._nameList[e] || Qu(this, this._nameDimIdx, e) || "" }, LT.getId = function(t) { return eh(this, this.getRawIndex(t)) }, LT.each = function(t, e, n, i) { if (this._count) { "function" == typeof t && (i = n, n = e, e = t, t = []), n = n || i || this, t = p(nh(t), this.getDimension, this); for (var r = t.length, a = 0; a < this.count(); a++) switch (r) {
                case 0:
                    e.call(n, a); break;
                case 1:
                    e.call(n, this.get(t[0], a), a); break;
                case 2:
                    e.call(n, this.get(t[0], a), this.get(t[1], a), a); break;
                default:
                    for (var o = 0, s = []; r > o; o++) s[o] = this.get(t[o], a);
                    s[o] = a, e.apply(n, s) } } }, LT.filterSelf = function(t, e, n, i) { if (this._count) { "function" == typeof t && (i = n, n = e, e = t, t = []), n = n || i || this, t = p(nh(t), this.getDimension, this); for (var r = this.count(), a = Yu(this), o = new a(r), s = [], l = t.length, u = 0, h = t[0], c = 0; r > c; c++) { var d, f = this.getRawIndex(c); if (0 === l) d = e.call(n, c);
                else if (1 === l) { var g = this._getFast(h, f);
                    d = e.call(n, g, c) } else { for (var v = 0; l > v; v++) s[v] = this._getFast(h, f);
                    s[v] = c, d = e.apply(n, s) }
                d && (o[u++] = f) } return r > u && (this._indices = o), this._count = u, this._extent = {}, this.getRawIndex = this._indices ? th : Ju, this } }, LT.selectRange = function(t) { if (this._count) { var e = []; for (var n in t) t.hasOwnProperty(n) && e.push(n); var i = e.length; if (i) { var r = this.count(),
                    a = Yu(this),
                    o = new a(r),
                    s = 0,
                    l = e[0],
                    u = t[l][0],
                    h = t[l][1],
                    c = !1; if (!this._indices) { var d = 0; if (1 === i) { for (var f = this._storage[e[0]], p = 0; p < this._chunkCount; p++)
                            for (var g = f[p], v = Math.min(this._count - p * this._chunkSize, this._chunkSize), m = 0; v > m; m++) { var y = g[m];
                                (y >= u && h >= y || isNaN(y)) && (o[s++] = d), d++ }
                        c = !0 } else if (2 === i) { for (var f = this._storage[l], x = this._storage[e[1]], _ = t[e[1]][0], b = t[e[1]][1], p = 0; p < this._chunkCount; p++)
                            for (var g = f[p], w = x[p], v = Math.min(this._count - p * this._chunkSize, this._chunkSize), m = 0; v > m; m++) { var y = g[m],
                                    M = w[m];
                                (y >= u && h >= y || isNaN(y)) && (M >= _ && b >= M || isNaN(M)) && (o[s++] = d), d++ }
                        c = !0 } } if (!c)
                    if (1 === i)
                        for (var m = 0; r > m; m++) { var S = this.getRawIndex(m),
                                y = this._getFast(l, S);
                            (y >= u && h >= y || isNaN(y)) && (o[s++] = S) } else
                            for (var m = 0; r > m; m++) { for (var I = !0, S = this.getRawIndex(m), p = 0; i > p; p++) { var T = e[p],
                                        y = this._getFast(n, S);
                                    (y < t[T][0] || y > t[T][1]) && (I = !1) }
                                I && (o[s++] = this.getRawIndex(m)) }
                    return r > s && (this._indices = o), this._count = s, this._extent = {}, this.getRawIndex = this._indices ? th : Ju, this } } }, LT.mapArray = function(t, e, n, i) { "function" == typeof t && (i = n, n = e, e = t, t = []), n = n || i || this; var r = []; return this.each(t, function() { r.push(e && e.apply(this, arguments)) }, n), r }, LT.map = function(t, e, n, i) { n = n || i || this, t = p(nh(t), this.getDimension, this); var r = ih(this, t);
        r._indices = this._indices, r.getRawIndex = r._indices ? th : Ju; for (var a = r._storage, o = [], s = this._chunkSize, l = t.length, u = this.count(), h = [], c = r._rawExtent, d = 0; u > d; d++) { for (var f = 0; l > f; f++) h[f] = this.get(t[f], d);
            h[l] = d; var g = e && e.apply(n, h); if (null != g) { "object" != typeof g && (o[0] = g, g = o); for (var v = this.getRawIndex(d), m = Math.floor(v / s), y = v % s, x = 0; x < g.length; x++) { var _ = t[x],
                        b = g[x],
                        w = c[_],
                        M = a[_];
                    M && (M[m][y] = b), b < w[0] && (w[0] = b), b > w[1] && (w[1] = b) } } } return r }, LT.downSample = function(t, e, n, i) { for (var r = ih(this, [t]), a = r._storage, o = [], s = Math.floor(1 / e), l = a[t], u = this.count(), h = this._chunkSize, c = r._rawExtent[t], d = new(Yu(this))(u), f = 0, p = 0; u > p; p += s) { s > u - p && (s = u - p, o.length = s); for (var g = 0; s > g; g++) { var v = this.getRawIndex(p + g),
                    m = Math.floor(v / h),
                    y = v % h;
                o[g] = l[m][y] } var x = n(o),
                _ = this.getRawIndex(Math.min(p + i(o, x) || 0, u - 1)),
                b = Math.floor(_ / h),
                w = _ % h;
            l[b][w] = x, x < c[0] && (c[0] = x), x > c[1] && (c[1] = x), d[f++] = _ } return r._count = f, r._indices = d, r.getRawIndex = th, r }, LT.getItemModel = function(t) { var e = this.hostModel; return new vo(this.getRawDataItem(t), e, e && e.ecModel) }, LT.diff = function(t) { var e = this; return new Fu(t ? t.getIndices() : [], this.getIndices(), function(e) { return eh(t, e) }, function(t) { return eh(e, t) }) }, LT.getVisual = function(t) { var e = this._visual; return e && e[t] }, LT.setVisual = function(t, e) { if (bT(t))
            for (var n in t) t.hasOwnProperty(n) && this.setVisual(n, t[n]);
        else this._visual = this._visual || {}, this._visual[t] = e }, LT.setLayout = function(t, e) { if (bT(t))
            for (var n in t) t.hasOwnProperty(n) && this.setLayout(n, t[n]);
        else this._layout[t] = e }, LT.getLayout = function(t) { return this._layout[t] }, LT.getItemLayout = function(t) { return this._itemLayouts[t] }, LT.setItemLayout = function(t, e, n) { this._itemLayouts[t] = n ? o(this._itemLayouts[t] || {}, e) : e }, LT.clearItemLayouts = function() { this._itemLayouts.length = 0 }, LT.getItemVisual = function(t, e, n) { var i = this._itemVisuals[t],
            r = i && i[e]; return null != r || n ? r : this.getVisual(e) }, LT.setItemVisual = function(t, e, n) { var i = this._itemVisuals[t] || {},
            r = this.hasItemVisual; if (this._itemVisuals[t] = i, bT(e))
            for (var a in e) e.hasOwnProperty(a) && (i[a] = e[a], r[a] = !0);
        else i[e] = n, r[e] = !0 }, LT.clearAllVisual = function() { this._visual = {}, this._itemVisuals = [], this.hasItemVisual = {} };
    var OT = function(t) { t.seriesIndex = this.seriesIndex, t.dataIndex = this.dataIndex, t.dataType = this.dataType };
    LT.setItemGraphicEl = function(t, e) { var n = this.hostModel;
        e && (e.dataIndex = t, e.dataType = this.dataType, e.seriesIndex = n && n.seriesIndex, "group" === e.type && e.traverse(OT, e)), this._graphicEls[t] = e }, LT.getItemGraphicEl = function(t) { return this._graphicEls[t] }, LT.eachItemGraphicEl = function(t, e) { f(this._graphicEls, function(n, i) { n && t && t.call(e, n, i) }) }, LT.cloneShallow = function(t) { if (!t) { var e = p(this.dimensions, this.getDimensionInfo, this);
            t = new PT(e, this.hostModel) } if (t._storage = this._storage, qu(t, this), this._indices) { var n = this._indices.constructor;
            t._indices = new n(this._indices) } else t._indices = null; return t.getRawIndex = t._indices ? th : Ju, t }, LT.wrapMethod = function(t, e) { var n = this[t]; "function" == typeof n && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function() { var t = n.apply(this, arguments); return e.apply(this, [t].concat(P(arguments))) }) }, LT.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "map"], LT.CHANGABLE_METHODS = ["filterSelf", "selectRange"];
    var zT = function(t, e) { return e = e || {}, oh(e.coordDimensions || [], t, { dimsDef: e.dimensionsDefine || t.dimensionsDefine, encodeDef: e.encodeDefine || t.encodeDefine, dimCount: e.dimensionsCount, encodeDefaulter: e.encodeDefaulter, generateCoord: e.generateCoord, generateCoordCount: e.generateCoordCount }) },
        ET = { cartesian2d: function(t, e, n, i) { var r = t.getReferringComponents("xAxis")[0],
                    a = t.getReferringComponents("yAxis")[0];
                e.coordSysDims = ["x", "y"], n.set("x", r), n.set("y", a), ch(r) && (i.set("x", r), e.firstCategoryDimIndex = 0), ch(a) && (i.set("y", a), null == e.firstCategoryDimIndex & (e.firstCategoryDimIndex = 1)) }, singleAxis: function(t, e, n, i) { var r = t.getReferringComponents("singleAxis")[0];
                e.coordSysDims = ["single"], n.set("single", r), ch(r) && (i.set("single", r), e.firstCategoryDimIndex = 0) }, polar: function(t, e, n, i) { var r = t.getReferringComponents("polar")[0],
                    a = r.findAxisModel("radiusAxis"),
                    o = r.findAxisModel("angleAxis");
                e.coordSysDims = ["radius", "angle"], n.set("radius", a), n.set("angle", o), ch(a) && (i.set("radius", a), e.firstCategoryDimIndex = 0), ch(o) && (i.set("angle", o), null == e.firstCategoryDimIndex && (e.firstCategoryDimIndex = 1)) }, geo: function(t, e) { e.coordSysDims = ["lng", "lat"] }, parallel: function(t, e, n, i) { var r = t.ecModel,
                    a = r.getComponent("parallel", t.get("parallelIndex")),
                    o = e.coordSysDims = a.dimensions.slice();
                f(a.parallelAxisIndex, function(t, a) { var s = r.getComponent("parallelAxis", t),
                        l = o[a];
                    n.set(l, s), ch(s) && null == e.firstCategoryDimIndex && (i.set(l, s), e.firstCategoryDimIndex = a) }) } };
    yh.prototype.parse = function(t) { return t }, yh.prototype.getSetting = function(t) { return this._setting[t] }, yh.prototype.contain = function(t) { var e = this._extent; return t >= e[0] && t <= e[1] }, yh.prototype.normalize = function(t) { var e = this._extent; return e[1] === e[0] ? .5 : (t - e[0]) / (e[1] - e[0]) }, yh.prototype.scale = function(t) { var e = this._extent; return t * (e[1] - e[0]) + e[0] }, yh.prototype.unionExtent = function(t) { var e = this._extent;
        t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]) }, yh.prototype.unionExtentFromData = function(t, e) { this.unionExtent(t.getApproximateExtent(e)) }, yh.prototype.getExtent = function() { return this._extent.slice() }, yh.prototype.setExtent = function(t, e) { var n = this._extent;
        isNaN(t) || (n[0] = t), isNaN(e) || (n[1] = e) }, yh.prototype.isBlank = function() { return this._isBlank }, yh.prototype.setBlank = function(t) { this._isBlank = t }, yh.prototype.getLabel = null, xr(yh), Mr(yh, { registerWhenExtend: !0 }), xh.createByAxisModel = function(t) { var e = t.option,
            n = e.data,
            i = n && p(n, bh); return new xh({ categories: i, needCollect: !i, deduplication: e.dedplication !== !1 }) };
    var RT = xh.prototype;
    RT.getOrdinal = function(t) { return _h(this).get(t) }, RT.parseAndCollect = function(t) { var e, n = this._needCollect; if ("string" != typeof t && !n) return t; if (n && !this._deduplication) return e = this.categories.length, this.categories[e] = t, e; var i = _h(this); return e = i.get(t), null == e && (n ? (e = this.categories.length, this.categories[e] = t, i.set(t, e)) : e = 0 / 0), e };
    var BT = yh.prototype,
        NT = yh.extend({ type: "ordinal", init: function(t, e) {
                (!t || _(t)) && (t = new xh({ categories: t })), this._ordinalMeta = t, this._extent = e || [0, t.categories.length - 1] }, parse: function(t) { return "string" == typeof t ? this._ordinalMeta.getOrdinal(t) : Math.round(t) }, contain: function(t) { return t = this.parse(t), BT.contain.call(this, t) && null != this._ordinalMeta.categories[t] }, normalize: function(t) { return BT.normalize.call(this, this.parse(t)) }, scale: function(t) { return Math.round(BT.scale.call(this, t)) }, getTicks: function() { for (var t = [], e = this._extent, n = e[0]; n <= e[1];) t.push(n), n++; return t }, getLabel: function(t) { return this.isBlank() ? void 0 : this._ordinalMeta.categories[t] }, count: function() { return this._extent[1] - this._extent[0] + 1 }, unionExtentFromData: function(t, e) { this.unionExtent(t.getApproximateExtent(e)) }, getOrdinalMeta: function() { return this._ordinalMeta }, niceTicks: F, niceExtent: F });
    NT.create = function() { return new NT };
    var VT = Io,
        FT = Io,
        HT = yh.extend({ type: "interval", _interval: 0, _intervalPrecision: 2, setExtent: function(t, e) { var n = this._extent;
                isNaN(t) || (n[0] = parseFloat(t)), isNaN(e) || (n[1] = parseFloat(e)) }, unionExtent: function(t) { var e = this._extent;
                t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]), HT.prototype.setExtent.call(this, e[0], e[1]) }, getInterval: function() { return this._interval }, setInterval: function(t) { this._interval = t, this._niceExtent = this._extent.slice(), this._intervalPrecision = Mh(t) }, getTicks: function(t) { var e = this._interval,
                    n = this._extent,
                    i = this._niceExtent,
                    r = this._intervalPrecision,
                    a = []; if (!e) return a; var o = 1e4;
                n[0] < i[0] && a.push(t ? FT(i[0] - e, r) : n[0]); for (var s = i[0]; s <= i[1] && (a.push(s), s = FT(s + e, r), s !== a[a.length - 1]);)
                    if (a.length > o) return [];
                var l = a.length ? a[a.length - 1] : i[1]; return n[1] > l && a.push(t ? FT(l + e, r) : n[1]), a }, getMinorTicks: function(t) { for (var e = this.getTicks(!0), n = [], i = this.getExtent(), r = 1; r < e.length; r++) { for (var a = e[r], o = e[r - 1], s = 0, l = [], u = a - o, h = u / t; t - 1 > s;) { var c = Io(o + (s + 1) * h);
                        c > i[0] && c < i[1] && l.push(c), s++ }
                    n.push(l) } return n }, getLabel: function(t, e) { if (null == t) return ""; var n = e && e.precision; return null == n ? n = Ao(t) || 0 : "auto" === n && (n = this._intervalPrecision), t = FT(t, n, !0), Fo(t) }, niceTicks: function(t, e, n) { t = t || 5; var i = this._extent,
                    r = i[1] - i[0]; if (isFinite(r)) { 0 > r && (r = -r, i.reverse()); var a = wh(i, t, e, n);
                    this._intervalPrecision = a.intervalPrecision, this._interval = a.interval, this._niceExtent = a.niceTickExtent } }, niceExtent: function(t) { var e = this._extent; if (e[0] === e[1])
                    if (0 !== e[0]) { var n = e[0];
                        t.fixMax ? e[0] -= n / 2 : (e[1] += n / 2, e[0] -= n / 2) } else e[1] = 1;
                var i = e[1] - e[0];
                isFinite(i) || (e[0] = 0, e[1] = 1), this.niceTicks(t.splitNumber, t.minInterval, t.maxInterval); var r = this._interval;
                t.fixMin || (e[0] = FT(Math.floor(e[0] / r) * r)), t.fixMax || (e[1] = FT(Math.ceil(e[1] / r) * r)) } });
    HT.create = function() { return new HT };
    var GT = "__ec_stack_",
        WT = .5,
        ZT = "undefined" != typeof Float32Array ? Float32Array : Array,
        UT = { seriesType: "bar", plan: $S(), reset: function(t) {
                function e(t, e) { for (var n, d = t.count, f = new ZT(2 * d), p = new ZT(2 * d), g = new ZT(d), v = [], m = [], y = 0, x = 0; null != (n = t.next());) m[h] = e.get(s, n), m[1 - h] = e.get(l, n), v = i.dataToPoint(m, null, v), p[y] = u ? r.x + r.width : v[0], f[y++] = v[0], p[y] = u ? v[1] : r.y + r.height, f[y++] = v[1], g[x++] = n;
                    e.setLayout({ largePoints: f, largeDataIndices: g, largeBackgroundPoints: p, barWidth: c, valueAxisStart: Bh(a, o, !1), backgroundStart: u ? r.x : r.y, valueAxisHorizontal: u }) } if (Eh(t) && Rh(t)) { var n = t.getData(),
                        i = t.coordinateSystem,
                        r = i.grid.getRect(),
                        a = i.getBaseAxis(),
                        o = i.getOtherAxis(a),
                        s = n.mapDimension(o.dim),
                        l = n.mapDimension(a.dim),
                        u = o.isHorizontal(),
                        h = u ? 0 : 1,
                        c = Oh(Ph([t]), a, t).width; return c > WT || (c = WT), { progress: e } } } },
        XT = HT.prototype,
        YT = Math.ceil,
        jT = Math.floor,
        qT = 1e3,
        KT = 60 * qT,
        $T = 60 * KT,
        QT = 24 * $T,
        JT = function(t, e, n, i) { for (; i > n;) { var r = n + i >>> 1;
                t[r][1] < e ? n = r + 1 : i = r } return n },
        tC = HT.extend({ type: "time", getLabel: function(t) { var e = this._stepLvl,
                    n = new Date(t); return Yo(e[0], n, this.getSetting("useUTC")) }, niceExtent: function(t) { var e = this._extent; if (e[0] === e[1] && (e[0] -= QT, e[1] += QT), e[1] === -1 / 0 && 1 / 0 === e[0]) { var n = new Date;
                    e[1] = +new Date(n.getFullYear(), n.getMonth(), n.getDate()), e[0] = e[1] - QT }
                this.niceTicks(t.splitNumber, t.minInterval, t.maxInterval); var i = this._interval;
                t.fixMin || (e[0] = Io(jT(e[0] / i) * i)), t.fixMax || (e[1] = Io(YT(e[1] / i) * i)) }, niceTicks: function(t, e, n) { t = t || 10; var i = this._extent,
                    r = i[1] - i[0],
                    a = r / t;
                null != e && e > a && (a = e), null != n && a > n && (a = n); var o = eC.length,
                    s = JT(eC, a, 0, o),
                    l = eC[Math.min(s, o - 1)],
                    u = l[1]; if ("year" === l[0]) { var h = r / u,
                        c = Ro(h / t, !0);
                    u *= c } var d = this.getSetting("useUTC") ? 0 : 60 * new Date(+i[0] || +i[1]).getTimezoneOffset() * 1e3,
                    f = [Math.round(YT((i[0] - d) / u) * u + d), Math.round(jT((i[1] - d) / u) * u + d)];
                Ih(f, i), this._stepLvl = l, this._interval = u, this._niceExtent = f }, parse: function(t) { return +Oo(t) } });
    f(["contain", "normalize"], function(t) { tC.prototype[t] = function(e) { return XT[t].call(this, this.parse(e)) } });
    var eC = [
        ["hh:mm:ss", qT],
        ["hh:mm:ss", 5 * qT],
        ["hh:mm:ss", 10 * qT],
        ["hh:mm:ss", 15 * qT],
        ["hh:mm:ss", 30 * qT],
        ["hh:mm\nMM-dd", KT],
        ["hh:mm\nMM-dd", 5 * KT],
        ["hh:mm\nMM-dd", 10 * KT],
        ["hh:mm\nMM-dd", 15 * KT],
        ["hh:mm\nMM-dd", 30 * KT],
        ["hh:mm\nMM-dd", $T],
        ["hh:mm\nMM-dd", 2 * $T],
        ["hh:mm\nMM-dd", 6 * $T],
        ["hh:mm\nMM-dd", 12 * $T],
        ["MM-dd\nyyyy", QT],
        ["MM-dd\nyyyy", 2 * QT],
        ["MM-dd\nyyyy", 3 * QT],
        ["MM-dd\nyyyy", 4 * QT],
        ["MM-dd\nyyyy", 5 * QT],
        ["MM-dd\nyyyy", 6 * QT],
        ["week", 7 * QT],
        ["MM-dd\nyyyy", 10 * QT],
        ["week", 14 * QT],
        ["week", 21 * QT],
        ["month", 31 * QT],
        ["week", 42 * QT],
        ["month", 62 * QT],
        ["week", 70 * QT],
        ["quarter", 95 * QT],
        ["month", 31 * QT * 4],
        ["month", 31 * QT * 5],
        ["half-year", 380 * QT / 2],
        ["month", 31 * QT * 8],
        ["month", 31 * QT * 10],
        ["year", 380 * QT]
    ];
    tC.create = function(t) { return new tC({ useUTC: t.ecModel.get("useUTC") }) };
    var nC = yh.prototype,
        iC = HT.prototype,
        rC = Ao,
        aC = Io,
        oC = Math.floor,
        sC = Math.ceil,
        lC = Math.pow,
        uC = Math.log,
        hC = yh.extend({ type: "log", base: 10, $constructor: function() { yh.apply(this, arguments), this._originalScale = new HT }, getTicks: function(t) { var e = this._originalScale,
                    n = this._extent,
                    i = e.getExtent(); return p(iC.getTicks.call(this, t), function(t) { var r = Io(lC(this.base, t)); return r = t === n[0] && e.__fixMin ? Nh(r, i[0]) : r, r = t === n[1] && e.__fixMax ? Nh(r, i[1]) : r }, this) }, getMinorTicks: iC.getMinorTicks, getLabel: iC.getLabel, scale: function(t) { return t = nC.scale.call(this, t), lC(this.base, t) }, setExtent: function(t, e) { var n = this.base;
                t = uC(t) / uC(n), e = uC(e) / uC(n), iC.setExtent.call(this, t, e) }, getExtent: function() { var t = this.base,
                    e = nC.getExtent.call(this);
                e[0] = lC(t, e[0]), e[1] = lC(t, e[1]); var n = this._originalScale,
                    i = n.getExtent(); return n.__fixMin && (e[0] = Nh(e[0], i[0])), n.__fixMax && (e[1] = Nh(e[1], i[1])), e }, unionExtent: function(t) { this._originalScale.unionExtent(t); var e = this.base;
                t[0] = uC(t[0]) / uC(e), t[1] = uC(t[1]) / uC(e), nC.unionExtent.call(this, t) }, unionExtentFromData: function(t, e) { this.unionExtent(t.getApproximateExtent(e)) }, niceTicks: function(t) { t = t || 10; var e = this._extent,
                    n = e[1] - e[0]; if (!(1 / 0 === n || 0 >= n)) { var i = zo(n),
                        r = t / n * i; for (.5 >= r && (i *= 10); !isNaN(i) && Math.abs(i) < 1 && Math.abs(i) > 0;) i *= 10; var a = [Io(sC(e[0] / i) * i), Io(oC(e[1] / i) * i)];
                    this._interval = i, this._niceExtent = a } }, niceExtent: function(t) { iC.niceExtent.call(this, t); var e = this._originalScale;
                e.__fixMin = t.fixMin, e.__fixMax = t.fixMax } });
    f(["contain", "normalize"], function(t) { hC.prototype[t] = function(e) { return e = uC(e) / uC(this.base), nC[t].call(this, e) } }), hC.create = function() { return new hC };
    var cC = { getMin: function(t) { var e = this.option,
                    n = t || null == e.rangeStart ? e.min : e.rangeStart; return this.axis && null != n && "dataMin" !== n && "function" != typeof n && !C(n) && (n = this.axis.scale.parse(n)), n }, getMax: function(t) { var e = this.option,
                    n = t || null == e.rangeEnd ? e.max : e.rangeEnd; return this.axis && null != n && "dataMax" !== n && "function" != typeof n && !C(n) && (n = this.axis.scale.parse(n)), n }, getNeedCrossZero: function() { var t = this.option; return null != t.rangeStart || null != t.rangeEnd ? !1 : !t.scale }, getCoordSysModel: F, setRange: function(t, e) { this.option.rangeStart = t, this.option.rangeEnd = e }, resetRange: function() { this.option.rangeStart = this.option.rangeEnd = null } },
        dC = ma({ type: "triangle", shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath: function(t, e) { var n = e.cx,
                    i = e.cy,
                    r = e.width / 2,
                    a = e.height / 2;
                t.moveTo(n, i - a), t.lineTo(n + r, i + a), t.lineTo(n - r, i + a), t.closePath() } }),
        fC = ma({ type: "diamond", shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath: function(t, e) { var n = e.cx,
                    i = e.cy,
                    r = e.width / 2,
                    a = e.height / 2;
                t.moveTo(n, i - a), t.lineTo(n + r, i), t.lineTo(n, i + a), t.lineTo(n - r, i), t.closePath() } }),
        pC = ma({ type: "pin", shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath: function(t, e) { var n = e.x,
                    i = e.y,
                    r = e.width / 5 * 3,
                    a = Math.max(r, e.height),
                    o = r / 2,
                    s = o * o / (a - o),
                    l = i - a + o + s,
                    u = Math.asin(s / o),
                    h = Math.cos(u) * o,
                    c = Math.sin(u),
                    d = Math.cos(u),
                    f = .6 * o,
                    p = .7 * o;
                t.moveTo(n - h, l + s), t.arc(n, l, o, Math.PI - u, 2 * Math.PI + u), t.bezierCurveTo(n + h - c * f, l + s + d * f, n, i - p, n, i), t.bezierCurveTo(n, i - p, n - h + c * f, l + s + d * f, n - h, l + s), t.closePath() } }),
        gC = ma({ type: "arrow", shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath: function(t, e) { var n = e.height,
                    i = e.width,
                    r = e.x,
                    a = e.y,
                    o = i / 3 * 2;
                t.moveTo(r, a), t.lineTo(r + o, a + n), t.lineTo(r, a + n / 4 * 3), t.lineTo(r - o, a + n), t.lineTo(r, a), t.closePath() } }),
        vC = { line: fM, rect: cM, roundRect: cM, square: cM, circle: tM, diamond: fC, pin: pC, arrow: gC, triangle: dC },
        mC = { line: function(t, e, n, i, r) { r.x1 = t, r.y1 = e + i / 2, r.x2 = t + n, r.y2 = e + i / 2 }, rect: function(t, e, n, i, r) { r.x = t, r.y = e, r.width = n, r.height = i }, roundRect: function(t, e, n, i, r) { r.x = t, r.y = e, r.width = n, r.height = i, r.r = Math.min(n, i) / 4 }, square: function(t, e, n, i, r) { var a = Math.min(n, i);
                r.x = t, r.y = e, r.width = a, r.height = a }, circle: function(t, e, n, i, r) { r.cx = t + n / 2, r.cy = e + i / 2, r.r = Math.min(n, i) / 2 }, diamond: function(t, e, n, i, r) { r.cx = t + n / 2, r.cy = e + i / 2, r.width = n, r.height = i }, pin: function(t, e, n, i, r) { r.x = t + n / 2, r.y = e + i / 2, r.width = n, r.height = i }, arrow: function(t, e, n, i, r) { r.x = t + n / 2, r.y = e + i / 2, r.width = n, r.height = i }, triangle: function(t, e, n, i, r) { r.cx = t + n / 2, r.cy = e + i / 2, r.width = n, r.height = i } },
        yC = {};
    f(vC, function(t, e) { yC[e] = new t });
    var xC = ma({ type: "symbol", shape: { symbolType: "", x: 0, y: 0, width: 0, height: 0 }, calculateTextPosition: function(t, e, n) { var i = Qn(t, e, n),
                    r = this.shape; return r && "pin" === r.symbolType && "inside" === e.textPosition && (i.y = n.y + .4 * n.height), i }, buildPath: function(t, e, n) { var i = e.symbolType; if ("none" !== i) { var r = yC[i];
                    r || (i = "rect", r = yC[i]), mC[i](e.x, e.y, e.width, e.height, r.shape), r.buildPath(t, r.shape, n) } } }),
        _C = { isDimensionStacked: fh, enableDataStack: dh, getStackedDimension: ph },
        bC = (Object.freeze || Object)({ createList: Qh, getLayoutRect: Qo, dataStack: _C, createScale: Jh, mixinAxisModelCommonMethods: tc, completeDimensions: oh, createDimensions: zT, createSymbol: $h }),
        wC = 1e-8;
    ic.prototype = { constructor: ic, properties: null, getBoundingRect: function() { var t = this._rect; if (t) return t; for (var e = Number.MAX_VALUE, n = [e, e], i = [-e, -e], r = [], a = [], o = this.geometries, s = 0; s < o.length; s++)
                if ("polygon" === o[s].type) { var l = o[s].exterior;
                    Nr(l, r, a), oe(n, n, r), se(i, i, a) }
            return 0 === s && (n[0] = n[1] = i[0] = i[1] = 0), this._rect = new Cn(n[0], n[1], i[0] - n[0], i[1] - n[1]) }, contain: function(t) { var e = this.getBoundingRect(),
                n = this.geometries; if (!e.contain(t[0], t[1])) return !1;
            t: for (var i = 0, r = n.length; r > i; i++)
                if ("polygon" === n[i].type) { var a = n[i].exterior,
                        o = n[i].interiors; if (nc(a, t[0], t[1])) { for (var s = 0; s < (o ? o.length : 0); s++)
                            if (nc(o[s])) continue t;
                        return !0 } } return !1 }, transformTo: function(t, e, n, i) { var r = this.getBoundingRect(),
                a = r.width / r.height;
            n ? i || (i = n / a) : n = a * i; for (var o = new Cn(t, e, n, i), s = r.calculateTransform(o), l = this.geometries, u = 0; u < l.length; u++)
                if ("polygon" === l[u].type) { for (var h = l[u].exterior, c = l[u].interiors, d = 0; d < h.length; d++) ae(h[d], h[d], s); for (var f = 0; f < (c ? c.length : 0); f++)
                        for (var d = 0; d < c[f].length; d++) ae(c[f][d], c[f][d], s) }
            r = this._rect, r.copy(o), this.center = [r.x + r.width / 2, r.y + r.height / 2] }, cloneShallow: function(t) { null == t && (t = this.name); var e = new ic(t, this.geometries, this.center); return e._rect = this._rect, e.transformTo = null, e } };
    var MC = function(t) { return rc(t), p(v(t.features, function(t) { return t.geometry && t.properties && t.geometry.coordinates.length > 0 }), function(t) { var e = t.properties,
                    n = t.geometry,
                    i = n.coordinates,
                    r = []; "Polygon" === n.type && r.push({ type: "polygon", exterior: i[0], interiors: i.slice(1) }), "MultiPolygon" === n.type && f(i, function(t) { t[0] && r.push({ type: "polygon", exterior: t[0], interiors: t.slice(1) }) }); var a = new ic(e.name, r, e.cp); return a.properties = e, a }) },
        SC = cr(),
        IC = [0, 1],
        TC = function(t, e, n) { this.dim = t, this.scale = e, this._extent = n || [0, 0], this.inverse = !1, this.onBand = !1 };
    TC.prototype = {
        constructor: TC,
        contain: function(t) { var e = this._extent,
                n = Math.min(e[0], e[1]),
                i = Math.max(e[0], e[1]); return t >= n && i >= t },
        containData: function(t) { return this.scale.contain(t) },
        getExtent: function() { return this._extent.slice() },
        getPixelPrecision: function(t) { return Do(t || this.scale.getExtent(), this._extent) },
        setExtent: function(t, e) { var n = this._extent;
            n[0] = t, n[1] = e },
        dataToCoord: function(t, e) { var n = this._extent,
                i = this.scale; return t = i.normalize(t), this.onBand && "ordinal" === i.type && (n = n.slice(), _c(n, i.count())), Mo(t, IC, n, e) },
        coordToData: function(t, e) { var n = this._extent,
                i = this.scale;
            this.onBand && "ordinal" === i.type && (n = n.slice(), _c(n, i.count())); var r = Mo(t, n, IC, e); return this.scale.scale(r) },
        pointToData: function() {},
        getTicksCoords: function(t) { t = t || {}; var e = t.tickModel || this.getTickModel(),
                n = sc(this, e),
                i = n.ticks,
                r = p(i, function(t) { return { coord: this.dataToCoord(t), tickValue: t } }, this),
                a = e.get("alignWithLabel"); return bc(this, r, a, t.clamp), r },
        getMinorTicksCoords: function() {
            if ("ordinal" === this.scale.type) return [];
            var t = this.model.getModel("minorTick"),
                e = t.get("splitNumber");
            e > 0 && 100 > e || (e = 5);
            var n = this.scale.getMinorTicks(e),
                i = p(n, function(t) { return p(t, function(t) { return { coord: this.dataToCoord(t), tickValue: t } }, this) }, this);
            return i
        },
        getViewLabels: function() { return oc(this).labels },
        getLabelModel: function() { return this.model.getModel("axisLabel") },
        getTickModel: function() { return this.model.getModel("axisTick") },
        getBandWidth: function() { var t = this._extent,
                e = this.scale.getExtent(),
                n = e[1] - e[0] + (this.onBand ? 1 : 0);
            0 === n && (n = 1); var i = Math.abs(t[1] - t[0]); return Math.abs(i) / n },
        isHorizontal: null,
        getRotate: null,
        calculateCategoryInterval: function() { return vc(this) }
    };
    var CC = MC,
        AC = {};
    f(["map", "each", "filter", "indexOf", "inherits", "reduce", "filter", "bind", "curry", "isArray", "isString", "isObject", "isFunction", "extend", "defaults", "clone", "merge"], function(t) { AC[t] = Nx[t] });
    var DC = {};
    f(["extendShape", "extendPath", "makePath", "makeImage", "mergePath", "resizePath", "createIcon", "setHoverStyle", "setLabelStyle", "setTextStyle", "setText", "getFont", "updateProps", "initProps", "getTransform", "clipPointsByRect", "clipRectByRect", "registerShape", "getShapeClass", "Group", "Image", "Text", "Circle", "Sector", "Ring", "Polygon", "Polyline", "Rect", "Line", "BezierCurve", "Arc", "IncrementalDisplayable", "CompoundPath", "LinearGradient", "RadialGradient", "BoundingRect"], function(t) { DC[t] = RM[t] });
    var kC = function(t) { this._axes = {}, this._dimList = [], this.name = t || "" };
    kC.prototype = { constructor: kC, type: "cartesian", getAxis: function(t) { return this._axes[t] }, getAxes: function() { return p(this._dimList, wc, this) }, getAxesByScale: function(t) { return t = t.toLowerCase(), v(this.getAxes(), function(e) { return e.scale.type === t }) }, addAxis: function(t) { var e = t.dim;
            this._axes[e] = t, this._dimList.push(e) }, dataToCoord: function(t) { return this._dataCoordConvert(t, "dataToCoord") }, coordToData: function(t) { return this._dataCoordConvert(t, "coordToData") }, _dataCoordConvert: function(t, e) { for (var n = this._dimList, i = t instanceof Array ? [] : {}, r = 0; r < n.length; r++) { var a = n[r],
                    o = this._axes[a];
                i[a] = o[e](t[a]) } return i } }, Mc.prototype = { constructor: Mc, type: "cartesian2d", dimensions: ["x", "y"], getBaseAxis: function() { return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x") }, containPoint: function(t) { var e = this.getAxis("x"),
                n = this.getAxis("y"); return e.contain(e.toLocalCoord(t[0])) && n.contain(n.toLocalCoord(t[1])) }, containData: function(t) { return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1]) }, dataToPoint: function(t, e, n) { var i = this.getAxis("x"),
                r = this.getAxis("y"); return n = n || [], n[0] = i.toGlobalCoord(i.dataToCoord(t[0])), n[1] = r.toGlobalCoord(r.dataToCoord(t[1])), n }, clampData: function(t, e) { var n = this.getAxis("x").scale,
                i = this.getAxis("y").scale,
                r = n.getExtent(),
                a = i.getExtent(),
                o = n.parse(t[0]),
                s = i.parse(t[1]); return e = e || [], e[0] = Math.min(Math.max(Math.min(r[0], r[1]), o), Math.max(r[0], r[1])), e[1] = Math.min(Math.max(Math.min(a[0], a[1]), s), Math.max(a[0], a[1])), e }, pointToData: function(t, e) { var n = this.getAxis("x"),
                i = this.getAxis("y"); return e = e || [], e[0] = n.coordToData(n.toLocalCoord(t[0])), e[1] = i.coordToData(i.toLocalCoord(t[1])), e }, getOtherAxis: function(t) { return this.getAxis("x" === t.dim ? "y" : "x") }, getArea: function() { var t = this.getAxis("x").getGlobalExtent(),
                e = this.getAxis("y").getGlobalExtent(),
                n = Math.min(t[0], t[1]),
                i = Math.min(e[0], e[1]),
                r = Math.max(t[0], t[1]) - n,
                a = Math.max(e[0], e[1]) - i,
                o = new Cn(n, i, r, a); return o } }, h(Mc, kC);
    var PC = function(t, e, n, i, r) { TC.call(this, t, e, n), this.type = i || "value", this.position = r || "bottom" };
    PC.prototype = { constructor: PC, index: 0, getAxesOnZeroOf: null, model: null, isHorizontal: function() { var t = this.position; return "top" === t || "bottom" === t }, getGlobalExtent: function(t) { var e = this.getExtent(); return e[0] = this.toGlobalCoord(e[0]), e[1] = this.toGlobalCoord(e[1]), t && e[0] > e[1] && e.reverse(), e }, getOtherAxis: function() { this.grid.getOtherAxis() }, pointToData: function(t, e) { return this.coordToData(this.toLocalCoord(t["x" === this.dim ? 0 : 1]), e) }, toLocalCoord: null, toGlobalCoord: null }, h(PC, TC);
    var LC = { show: !0, zlevel: 0, z: 0, inverse: !1, name: "", nameLocation: "end", nameRotate: null, nameTruncate: { maxWidth: null, ellipsis: "...", placeholder: "." }, nameTextStyle: {}, nameGap: 15, silent: !1, triggerEvent: !1, tooltip: { show: !1 }, axisPointer: {}, axisLine: { show: !0, onZero: !0, onZeroAxisIndex: null, lineStyle: { color: "#333", width: 1, type: "solid" }, symbol: ["none", "none"], symbolSize: [10, 15] }, axisTick: { show: !0, inside: !1, length: 5, lineStyle: { width: 1 } }, axisLabel: { show: !0, inside: !1, rotate: 0, showMinLabel: null, showMaxLabel: null, margin: 8, fontSize: 12 }, splitLine: { show: !0, lineStyle: { color: ["#ccc"], width: 1, type: "solid" } }, splitArea: { show: !1, areaStyle: { color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"] } } },
        OC = {};
    OC.categoryAxis = r({ boundaryGap: !0, deduplication: null, splitLine: { show: !1 }, axisTick: { alignWithLabel: !1, interval: "auto" }, axisLabel: { interval: "auto" } }, LC), OC.valueAxis = r({ boundaryGap: [0, 0], splitNumber: 5, minorTick: { show: !1, splitNumber: 5, length: 3, lineStyle: {} }, minorSplitLine: { show: !1, lineStyle: { color: "#eee", width: 1 } } }, LC), OC.timeAxis = s({ scale: !0, min: "dataMin", max: "dataMax" }, OC.valueAxis), OC.logAxis = s({ scale: !0, logBase: 10 }, OC.valueAxis);
    var zC = ["value", "category", "time", "log"],
        EC = function(t, e, n, i) { f(zC, function(o) { e.extend({ type: t + "Axis." + o, mergeDefaultAndTheme: function(e, i) { var a = this.layoutMode,
                            s = a ? es(e) : {},
                            l = i.getTheme();
                        r(e, l.get(o + "Axis")), r(e, this.getDefaultOption()), e.type = n(t, e), a && ts(e, s, a) }, optionUpdated: function() { var t = this.option; "category" === t.type && (this.__ordinalMeta = xh.createByAxisModel(this)) }, getCategories: function(t) { var e = this.option; return "category" === e.type ? t ? e.data : this.__ordinalMeta.categories : void 0 }, getOrdinalMeta: function() { return this.__ordinalMeta }, defaultOption: a([{}, OC[o + "Axis"], i], !0) }) }), sS.registerSubTypeDefaulter(t + "Axis", x(n, t)) },
        RC = sS.extend({ type: "cartesian2dAxis", axis: null, init: function() { RC.superApply(this, "init", arguments), this.resetRange() }, mergeOption: function() { RC.superApply(this, "mergeOption", arguments), this.resetRange() }, restoreData: function() { RC.superApply(this, "restoreData", arguments), this.resetRange() }, getCoordSysModel: function() { return this.ecModel.queryComponents({ mainType: "grid", index: this.option.gridIndex, id: this.option.gridId })[0] } });
    r(RC.prototype, cC);
    var BC = { offset: 0 };
    EC("x", RC, Sc, BC), EC("y", RC, Sc, BC), sS.extend({ type: "grid", dependencies: ["xAxis", "yAxis"], layoutMode: "box", coordinateSystem: null, defaultOption: { show: !1, zlevel: 0, z: 0, left: "10%", top: 60, right: "10%", bottom: 60, containLabel: !1, backgroundColor: "rgba(0,0,0,0)", borderWidth: 1, borderColor: "#ccc" } });
    var NC = Tc.prototype;
    NC.type = "grid", NC.axisPointerEnabled = !0, NC.getRect = function() { return this._rect }, NC.update = function(t, e) { var n = this._axesMap;
        this._updateScale(t, this.model), f(n.x, function(t) { Hh(t.scale, t.model) }), f(n.y, function(t) { Hh(t.scale, t.model) }); var i = {};
        f(n.x, function(t) { Cc(n, "y", t, i) }), f(n.y, function(t) { Cc(n, "x", t, i) }), this.resize(this.model, e) }, NC.resize = function(t, e, n) {
        function i() { f(a, function(t) { var e = t.isHorizontal(),
                    n = e ? [0, r.width] : [0, r.height],
                    i = t.inverse ? 1 : 0;
                t.setExtent(n[i], n[1 - i]), Dc(t, e ? r.x : r.y) }) } var r = Qo(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() });
        this._rect = r; var a = this._axesList;
        i(), !n && t.get("containLabel") && (f(a, function(t) { if (!t.model.get("axisLabel.inside")) { var e = Xh(t); if (e) { var n = t.isHorizontal() ? "height" : "width",
                        i = t.model.get("axisLabel.margin");
                    r[n] -= e[n] + i, "top" === t.position ? r.y += e.height + i : "left" === t.position && (r.x += e.width + i) } } }), i()) }, NC.getAxis = function(t, e) { var n = this._axesMap[t]; if (null != n) { if (null == e)
                for (var i in n)
                    if (n.hasOwnProperty(i)) return n[i];
            return n[e] } }, NC.getAxes = function() { return this._axesList.slice() }, NC.getCartesian = function(t, e) { if (null != t && null != e) { var n = "x" + t + "y" + e; return this._coordsMap[n] }
        M(t) && (e = t.yAxisIndex, t = t.xAxisIndex); for (var i = 0, r = this._coordsList; i < r.length; i++)
            if (r[i].getAxis("x").index === t || r[i].getAxis("y").index === e) return r[i] }, NC.getCartesians = function() { return this._coordsList.slice() }, NC.convertToPixel = function(t, e, n) { var i = this._findConvertTarget(t, e); return i.cartesian ? i.cartesian.dataToPoint(n) : i.axis ? i.axis.toGlobalCoord(i.axis.dataToCoord(n)) : null }, NC.convertFromPixel = function(t, e, n) { var i = this._findConvertTarget(t, e); return i.cartesian ? i.cartesian.pointToData(n) : i.axis ? i.axis.coordToData(i.axis.toLocalCoord(n)) : null }, NC._findConvertTarget = function(t, e) { var n, i, r = e.seriesModel,
            a = e.xAxisModel || r && r.getReferringComponents("xAxis")[0],
            o = e.yAxisModel || r && r.getReferringComponents("yAxis")[0],
            s = e.gridModel,
            l = this._coordsList; if (r) n = r.coordinateSystem, u(l, n) < 0 && (n = null);
        else if (a && o) n = this.getCartesian(a.componentIndex, o.componentIndex);
        else if (a) i = this.getAxis("x", a.componentIndex);
        else if (o) i = this.getAxis("y", o.componentIndex);
        else if (s) { var h = s.coordinateSystem;
            h === this && (n = this._coordsList[0]) } return { cartesian: n, axis: i } }, NC.containPoint = function(t) { var e = this._coordsList[0]; return e ? e.containPoint(t) : void 0 }, NC._initCartesian = function(t, e) {
        function n(n) { return function(o, s) { if (Ic(o, t, e)) { var l = o.get("position"); "x" === n ? "top" !== l && "bottom" !== l && (l = i.bottom ? "top" : "bottom") : "left" !== l && "right" !== l && (l = i.left ? "right" : "left"), i[l] = !0; var u = new PC(n, Gh(o), [0, 0], o.get("type"), l),
                        h = "category" === u.type;
                    u.onBand = h && o.get("boundaryGap"), u.inverse = o.get("inverse"), o.axis = u, u.model = o, u.grid = this, u.index = s, this._axesList.push(u), r[n][s] = u, a[n]++ } } } var i = { left: !1, right: !1, top: !1, bottom: !1 },
            r = { x: {}, y: {} },
            a = { x: 0, y: 0 }; return e.eachComponent("xAxis", n("x"), this), e.eachComponent("yAxis", n("y"), this), a.x && a.y ? (this._axesMap = r, void f(r.x, function(e, n) { f(r.y, function(i, r) { var a = "x" + n + "y" + r,
                    o = new Mc(a);
                o.grid = this, o.model = t, this._coordsMap[a] = o, this._coordsList.push(o), o.addAxis(e), o.addAxis(i) }, this) }, this)) : (this._axesMap = {}, void(this._axesList = [])) }, NC._updateScale = function(t, e) {
        function n(t, e) { f(t.mapDimension(e.dim, !0), function(n) { e.scale.unionExtentFromData(t, ph(t, n)) }) }
        f(this._axesList, function(t) { t.scale.setExtent(1 / 0, -1 / 0) }), t.eachSeries(function(i) { if (Pc(i)) { var r = kc(i, t),
                    a = r[0],
                    o = r[1]; if (!Ic(a, e, t) || !Ic(o, e, t)) return; var s = this.getCartesian(a.componentIndex, o.componentIndex),
                    l = i.getData(),
                    u = s.getAxis("x"),
                    h = s.getAxis("y"); "list" === l.type && (n(l, u, i), n(l, h, i)) } }, this) }, NC.getTooltipAxes = function(t) { var e = [],
            n = []; return f(this.getCartesians(), function(i) { var r = null != t && "auto" !== t ? i.getAxis(t) : i.getBaseAxis(),
                a = i.getOtherAxis(r);
            u(e, r) < 0 && e.push(r), u(n, a) < 0 && n.push(a) }), { baseAxes: e, otherAxes: n } };
    var VC = ["xAxis", "yAxis"];
    Tc.create = function(t, e) { var n = []; return t.eachComponent("grid", function(i, r) { var a = new Tc(i, t, e);
            a.name = "grid_" + r, a.resize(i, e, !0), i.coordinateSystem = a, n.push(a) }), t.eachSeries(function(e) { if (Pc(e)) { var n = kc(e, t),
                    i = n[0],
                    r = n[1],
                    a = i.getCoordSysModel(),
                    o = a.coordinateSystem;
                e.coordinateSystem = o.getCartesian(i.componentIndex, r.componentIndex) } }), n }, Tc.dimensions = Tc.prototype.dimensions = Mc.prototype.dimensions, Cs.register("cartesian2d", Tc);
    var FC = jS.extend({ type: "series.__base_bar__", getInitialData: function() { return gh(this.getSource(), this, { useEncodeDefaulter: !0 }) }, getMarkerPosition: function(t) { var e = this.coordinateSystem; if (e) { var n = e.dataToPoint(e.clampData(t)),
                    i = this.getData(),
                    r = i.getLayout("offset"),
                    a = i.getLayout("size"),
                    o = e.getBaseAxis().isHorizontal() ? 0 : 1; return n[o] += r + a / 2, n } return [0 / 0, 0 / 0] }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "cartesian2d", legendHoverLink: !0, barMinHeight: 0, barMinAngle: 0, large: !1, largeThreshold: 400, progressive: 3e3, progressiveChunkMode: "mod", itemStyle: {}, emphasis: {} } });
    FC.extend({ type: "series.bar", dependencies: ["grid", "polar"], brushSelector: "rect", getProgressive: function() { return this.get("large") ? this.get("progressive") : !1 }, getProgressiveThreshold: function() { var t = this.get("progressiveThreshold"),
                e = this.get("largeThreshold"); return e > t && (t = e), t }, defaultOption: { clip: !0, roundCap: !1, showBackground: !1, backgroundStyle: { color: "rgba(180, 180, 180, 0.2)", borderColor: null, borderWidth: 0, borderType: "solid", borderRadius: 0, shadowBlur: 0, shadowColor: null, shadowOffsetX: 0, shadowOffsetY: 0, opacity: 1 } } });
    var HC = Xb([
            ["fill", "color"],
            ["stroke", "borderColor"],
            ["lineWidth", "borderWidth"],
            ["stroke", "barBorderColor"],
            ["lineWidth", "barBorderWidth"],
            ["opacity"],
            ["shadowBlur"],
            ["shadowOffsetX"],
            ["shadowOffsetY"],
            ["shadowColor"]
        ]),
        GC = { getBarItemStyle: function(t) { var e = HC(this, t); if (this.getBorderLineDash) { var n = this.getBorderLineDash();
                    n && (e.lineDash = n) } return e } },
        WC = ma({ type: "sausage", shape: { cx: 0, cy: 0, r0: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0 }, buildPath: function(t, e) { var n = e.cx,
                    i = e.cy,
                    r = Math.max(e.r0 || 0, 0),
                    a = Math.max(e.r, 0),
                    o = .5 * (a - r),
                    s = r + o,
                    l = e.startAngle,
                    u = e.endAngle,
                    h = e.clockwise,
                    c = Math.cos(l),
                    d = Math.sin(l),
                    f = Math.cos(u),
                    p = Math.sin(u),
                    g = h ? u - l < 2 * Math.PI : l - u < 2 * Math.PI;
                g && (t.moveTo(c * r + n, d * r + i), t.arc(c * s + n, d * s + i, o, -Math.PI + l, l, !h)), t.arc(n, i, a, l, u, !h), t.moveTo(f * a + n, p * a + i), t.arc(f * s + n, p * s + i, o, u - 2 * Math.PI, u - Math.PI, !h), 0 !== r && (t.arc(n, i, r, u, l, h), t.moveTo(c * r + n, p * r + i)), t.closePath() } }),
        ZC = ["itemStyle", "barBorderWidth"],
        UC = [0, 0];
    o(vo.prototype, GC), Eu({ type: "bar", render: function(t, e, n) { this._updateDrawMode(t); var i = t.get("coordinateSystem"); return ("cartesian2d" === i || "polar" === i) && (this._isLargeDraw ? this._renderLarge(t, e, n) : this._renderNormal(t, e, n)), this.group }, incrementalPrepareRender: function(t) { this._clear(), this._updateDrawMode(t) }, incrementalRender: function(t, e) { this._incrementalRenderLarge(t, e) }, _updateDrawMode: function(t) { var e = t.pipelineContext.large;
            (null == this._isLargeDraw || e ^ this._isLargeDraw) && (this._isLargeDraw = e, this._clear()) }, _renderNormal: function(t) { var e, n = this.group,
                i = t.getData(),
                r = this._data,
                a = t.coordinateSystem,
                o = a.getBaseAxis(); "cartesian2d" === a.type ? e = o.isHorizontal() : "polar" === a.type && (e = "angle" === o.dim); var s = t.isAnimationEnabled() ? t : null,
                l = t.get("clip", !0),
                u = Nc(a, i);
            n.removeClipPath(); var h = t.get("roundCap", !0),
                c = t.get("showBackground", !0),
                d = t.getModel("backgroundStyle"),
                f = [],
                p = this._backgroundEls || [];
            i.diff(r).add(function(r) { var o = i.getItemModel(r),
                    p = KC[a.type](i, r, o); if (c) { var g = qc(a, e, p);
                    g.useStyle(d.getBarItemStyle()), f[r] = g } if (i.hasValue(r)) { if (l) { var v = jC[a.type](u, p); if (v) return void n.remove(m) } var m = qC[a.type](r, p, e, s, !1, h);
                    i.setItemGraphicEl(r, m), n.add(m), Gc(m, i, r, o, p, t, e, "polar" === a.type) } }).update(function(o, g) { var v = i.getItemModel(o),
                    m = KC[a.type](i, o, v); if (c) { var y = p[g];
                    y.useStyle(d.getBarItemStyle()), f[o] = y; var x = jc(e, m, a);
                    no(y, { shape: x }, s, o) } var _ = r.getItemGraphicEl(g); if (!i.hasValue(o)) return void n.remove(_); if (l) { var b = jC[a.type](u, m); if (b) return void n.remove(_) }
                _ ? no(_, { shape: m }, s, o) : _ = qC[a.type](o, m, e, s, !0, h), i.setItemGraphicEl(o, _), n.add(_), Gc(_, i, o, v, m, t, e, "polar" === a.type) }).remove(function(t) { var e = r.getItemGraphicEl(t); "cartesian2d" === a.type ? e && Vc(t, s, e) : e && Fc(t, s, e) }).execute(); var g = this._backgroundGroup || (this._backgroundGroup = new N_);
            g.removeAll(); for (var v = 0; v < f.length; ++v) g.add(f[v]);
            n.add(g), this._backgroundEls = f, this._data = i }, _renderLarge: function(t) { this._clear(), Zc(t, this.group); var e = t.get("clip", !0) ? Bc(t.coordinateSystem, !1, t) : null;
            e ? this.group.setClipPath(e) : this.group.removeClipPath() }, _incrementalRenderLarge: function(t, e) { this._removeBackground(), Zc(e, this.group, !0) }, dispose: F, remove: function(t) { this._clear(t) }, _clear: function(t) { var e = this.group,
                n = this._data;
            t && t.get("animation") && n && !this._isLargeDraw ? (this._removeBackground(), this._backgroundEls = [], n.eachItemGraphicEl(function(e) { "sector" === e.type ? Fc(e.dataIndex, t, e) : Vc(e.dataIndex, t, e) })) : e.removeAll(), this._data = null }, _removeBackground: function() { this.group.remove(this._backgroundGroup), this._backgroundGroup = null } });
    var XC = Math.max,
        YC = Math.min,
        jC = { cartesian2d: function(t, e) { var n = e.width < 0 ? -1 : 1,
                    i = e.height < 0 ? -1 : 1;
                0 > n && (e.x += e.width, e.width = -e.width), 0 > i && (e.y += e.height, e.height = -e.height); var r = XC(e.x, t.x),
                    a = YC(e.x + e.width, t.x + t.width),
                    o = XC(e.y, t.y),
                    s = YC(e.y + e.height, t.y + t.height);
                e.x = r, e.y = o, e.width = a - r, e.height = s - o; var l = e.width < 0 || e.height < 0; return 0 > n && (e.x += e.width, e.width = -e.width), 0 > i && (e.y += e.height, e.height = -e.height), l }, polar: function() { return !1 } },
        qC = { cartesian2d: function(t, e, n, i, r) { var a = new cM({ shape: o({}, e), z2: 1 }); if (a.name = "item", i) { var s = a.shape,
                        l = n ? "height" : "width",
                        u = {};
                    s[l] = 0, u[l] = e[l], RM[r ? "updateProps" : "initProps"](a, { shape: u }, i, t) } return a }, polar: function(t, e, n, i, r, a) { var o = e.startAngle < e.endAngle,
                    l = !n && a ? WC : iM,
                    u = new l({ shape: s({ clockwise: o }, e), z2: 1 }); if (u.name = "item", i) { var h = u.shape,
                        c = n ? "r" : "endAngle",
                        d = {};
                    h[c] = n ? 0 : e.startAngle, d[c] = e[c], RM[r ? "updateProps" : "initProps"](u, { shape: d }, i, t) } return u } },
        KC = { cartesian2d: function(t, e, n) { var i = t.getItemLayout(e),
                    r = Wc(n, i),
                    a = i.width > 0 ? 1 : -1,
                    o = i.height > 0 ? 1 : -1; return { x: i.x + a * r / 2, y: i.y + o * r / 2, width: i.width - a * r, height: i.height - o * r } }, polar: function(t, e) { var n = t.getItemLayout(e); return { cx: n.cx, cy: n.cy, r0: n.r0, r: n.r, startAngle: n.startAngle, endAngle: n.endAngle } } },
        $C = ia.extend({ type: "largeBar", shape: { points: [] }, buildPath: function(t, e) { for (var n = e.points, i = this.__startPoint, r = this.__baseDimIdx, a = 0; a < n.length; a += 2) i[r] = n[a + r], t.moveTo(i[0], i[1]), t.lineTo(n[a], n[a + 1]) } }),
        QC = yl(function(t) { var e = this,
                n = Uc(e, t.offsetX, t.offsetY);
            e.dataIndex = n >= 0 ? n : null }, 30, !1),
        JC = Math.PI,
        tA = function(t, e) { this.opt = e, this.axisModel = t, s(e, { labelOffset: 0, nameDirection: 1, tickDirection: 1, labelDirection: 1, silent: !0 }), this.group = new N_; var n = new N_({ position: e.position.slice(), rotation: e.rotation });
            n.updateTransform(), this._transform = n.transform, this._dumbGroup = n };
    tA.prototype = { constructor: tA, hasBuilder: function(t) { return !!eA[t] }, add: function(t) { eA[t].call(this) }, getGroup: function() { return this.group } };
    var eA = { axisLine: function() { var t = this.opt,
                    e = this.axisModel; if (e.get("axisLine.show")) { var n = this.axisModel.axis.getExtent(),
                        i = this._transform,
                        r = [n[0], 0],
                        a = [n[1], 0];
                    i && (ae(r, r, i), ae(a, a, i)); var s = o({ lineCap: "round" }, e.getModel("axisLine.lineStyle").getLineStyle());
                    this.group.add(new fM({ anid: "line", subPixelOptimize: !0, shape: { x1: r[0], y1: r[1], x2: a[0], y2: a[1] }, style: s, strokeContainThreshold: t.strokeContainThreshold || 5, silent: !0, z2: 1 })); var l = e.get("axisLine.symbol"),
                        u = e.get("axisLine.symbolSize"),
                        h = e.get("axisLine.symbolOffset") || 0; if ("number" == typeof h && (h = [h, h]), null != l) { "string" == typeof l && (l = [l, l]), ("string" == typeof u || "number" == typeof u) && (u = [u, u]); var c = u[0],
                            d = u[1];
                        f([{ rotate: t.rotation + Math.PI / 2, offset: h[0], r: 0 }, { rotate: t.rotation - Math.PI / 2, offset: h[1], r: Math.sqrt((r[0] - a[0]) * (r[0] - a[0]) + (r[1] - a[1]) * (r[1] - a[1])) }], function(e, n) { if ("none" !== l[n] && null != l[n]) { var i = $h(l[n], -c / 2, -d / 2, c, d, s.stroke, !0),
                                    a = e.r + e.offset,
                                    o = [r[0] + a * Math.cos(t.rotation), r[1] - a * Math.sin(t.rotation)];
                                i.attr({ rotation: e.rotate, position: o, silent: !0, z2: 11 }), this.group.add(i) } }, this) } } }, axisTickLabel: function() { var t = this.axisModel,
                    e = this.opt,
                    n = nd(this, t, e),
                    i = rd(this, t, e);
                $c(t, i, n), id(this, t, e) }, axisName: function() { var t = this.opt,
                    e = this.axisModel,
                    n = A(t.axisName, e.get("name")); if (n) { var i, r = e.get("nameLocation"),
                        a = t.nameDirection,
                        s = e.getModel("nameTextStyle"),
                        l = e.get("nameGap") || 0,
                        u = this.axisModel.axis.getExtent(),
                        h = u[0] > u[1] ? -1 : 1,
                        c = ["start" === r ? u[0] - h * l : "end" === r ? u[1] + h * l : (u[0] + u[1]) / 2, td(r) ? t.labelOffset + a * l : 0],
                        d = e.get("nameRotate");
                    null != d && (d = d * JC / 180); var f;
                    td(r) ? i = iA(t.rotation, null != d ? d : t.rotation, a) : (i = Kc(t, r, d || 0, u), f = t.axisNameAvailableWidth, null != f && (f = Math.abs(f / Math.sin(i.rotation)), !isFinite(f) && (f = null))); var p = s.getFont(),
                        g = e.get("nameTruncate", !0) || {},
                        v = g.ellipsis,
                        m = A(t.nameTruncateMaxWidth, g.maxWidth, f),
                        y = null != v && null != m ? JM(n, m, p, v, { minChar: 2, placeholder: g.placeholder }) : n,
                        x = e.get("tooltip", !0),
                        _ = e.mainType,
                        b = { componentType: _, name: n, $vars: ["name"] };
                    b[_ + "Index"] = e.componentIndex; var w = new Jw({ anid: "name", __fullText: n, __truncatedText: y, position: c, rotation: i.rotation, silent: rA(e), z2: 1, tooltip: x && x.show ? o({ content: n, formatter: function() { return n }, formatterParams: b }, x) : null });
                    Xa(w.style, s, { text: y, textFont: p, textFill: s.getTextColor() || e.get("axisLine.lineStyle.color"), textAlign: s.get("align") || i.textAlign, textVerticalAlign: s.get("verticalAlign") || i.textVerticalAlign }), e.get("triggerEvent") && (w.eventData = nA(e), w.eventData.targetType = "axisName", w.eventData.name = n), this._dumbGroup.add(w), w.updateTransform(), this.group.add(w), w.decomposeTransform() } } },
        nA = tA.makeAxisEventDataBase = function(t) { var e = { componentType: t.mainType, componentIndex: t.componentIndex }; return e[t.mainType + "Index"] = t.componentIndex, e },
        iA = tA.innerTextLayout = function(t, e, n) { var i, r, a = Po(e - t); return Lo(a) ? (r = n > 0 ? "top" : "bottom", i = "center") : Lo(a - JC) ? (r = n > 0 ? "bottom" : "top", i = "center") : (r = "middle", i = a > 0 && JC > a ? n > 0 ? "right" : "left" : n > 0 ? "left" : "right"), { rotation: a, textAlign: i, textVerticalAlign: r } },
        rA = tA.isLabelSilent = function(t) { var e = t.get("tooltip"); return t.get("silent") || !(t.get("triggerEvent") || e && e.show) },
        aA = f,
        oA = x,
        sA = Ou({ type: "axis", _axisPointer: null, axisPointerClass: null, render: function(t, e, n, i) { this.axisPointerClass && cd(t), sA.superApply(this, "render", arguments), vd(this, t, e, n, i, !0) }, updateAxisPointer: function(t, e, n, i) { vd(this, t, e, n, i, !1) }, remove: function(t, e) { var n = this._axisPointer;
                n && n.remove(e), sA.superApply(this, "remove", arguments) }, dispose: function(t, e) { md(this, e), sA.superApply(this, "dispose", arguments) } }),
        lA = [];
    sA.registerAxisPointerClass = function(t, e) { lA[t] = e }, sA.getAxisPointerClass = function(t) { return t && lA[t] };
    var uA = ["axisLine", "axisTickLabel", "axisName"],
        hA = ["splitArea", "splitLine", "minorSplitLine"],
        cA = sA.extend({ type: "cartesianAxis", axisPointerClass: "CartesianAxisPointer", render: function(t, e, n, i) { this.group.removeAll(); var r = this._axisGroup; if (this._axisGroup = new N_, this.group.add(this._axisGroup), t.get("show")) { var a = t.getCoordSysModel(),
                        o = yd(a, t),
                        s = new tA(t, o);
                    f(uA, s.add, s), this._axisGroup.add(s.getGroup()), f(hA, function(e) { t.get(e + ".show") && this["_" + e](t, a) }, this), so(r, this._axisGroup, t), cA.superCall(this, "render", t, e, n, i) } }, remove: function() { _d(this) }, _splitLine: function(t, e) { var n = t.axis; if (!n.scale.isBlank()) { var i = t.getModel("splitLine"),
                        r = i.getModel("lineStyle"),
                        a = r.get("color");
                    a = _(a) ? a : [a]; for (var o = e.coordinateSystem.getRect(), l = n.isHorizontal(), u = 0, h = n.getTicksCoords({ tickModel: i }), c = [], d = [], f = r.getLineStyle(), p = 0; p < h.length; p++) { var g = n.toGlobalCoord(h[p].coord);
                        l ? (c[0] = g, c[1] = o.y, d[0] = g, d[1] = o.y + o.height) : (c[0] = o.x, c[1] = g, d[0] = o.x + o.width, d[1] = g); var v = u++ % a.length,
                            m = h[p].tickValue;
                        this._axisGroup.add(new fM({ anid: null != m ? "line_" + h[p].tickValue : null, subPixelOptimize: !0, shape: { x1: c[0], y1: c[1], x2: d[0], y2: d[1] }, style: s({ stroke: a[v] }, f), silent: !0 })) } } }, _minorSplitLine: function(t, e) { var n = t.axis,
                    i = t.getModel("minorSplitLine"),
                    r = i.getModel("lineStyle"),
                    a = e.coordinateSystem.getRect(),
                    o = n.isHorizontal(),
                    s = n.getMinorTicksCoords(); if (s.length)
                    for (var l = [], u = [], h = r.getLineStyle(), c = 0; c < s.length; c++)
                        for (var d = 0; d < s[c].length; d++) { var f = n.toGlobalCoord(s[c][d].coord);
                            o ? (l[0] = f, l[1] = a.y, u[0] = f, u[1] = a.y + a.height) : (l[0] = a.x, l[1] = f, u[0] = a.x + a.width, u[1] = f), this._axisGroup.add(new fM({ anid: "minor_line_" + s[c][d].tickValue, subPixelOptimize: !0, shape: { x1: l[0], y1: l[1], x2: u[0], y2: u[1] }, style: h, silent: !0 })) } }, _splitArea: function(t, e) { xd(this, this._axisGroup, t, e) } });
    cA.extend({ type: "xAxis" }), cA.extend({ type: "yAxis" }), Ou({ type: "grid", render: function(t) { this.group.removeAll(), t.get("show") && this.group.add(new cM({ shape: t.coordinateSystem.getRect(), style: s({ fill: t.get("backgroundColor") }, t.getItemStyle()), silent: !0, z2: -1 })) } }), wu(function(t) { t.xAxis && t.yAxis && !t.grid && (t.grid = {}) }), Au(QI.VISUAL.LAYOUT, x(zh, "bar")), Au(QI.VISUAL.PROGRESSIVE_LAYOUT, UT), Du({ seriesType: "bar", reset: function(t) { t.getData().setVisual("legendSymbol", "roundRect") } }), jS.extend({ type: "series.line", dependencies: ["grid", "polar"], getInitialData: function() { return gh(this.getSource(), this, { useEncodeDefaulter: !0 }) }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "cartesian2d", legendHoverLink: !0, hoverAnimation: !0, clip: !0, label: { position: "top" }, lineStyle: { width: 2, type: "solid" }, step: !1, smooth: !1, smoothMonotone: null, symbol: "emptyCircle", symbolSize: 4, symbolRotate: null, showSymbol: !0, showAllSymbol: "auto", connectNulls: !1, sampling: "none", animationEasing: "linear", progressive: 0, hoverLayerThreshold: 1 / 0 } });
    var dA = bd.prototype,
        fA = bd.getSymbolSize = function(t, e) { var n = t.getItemVisual(e, "symbolSize"); return n instanceof Array ? n.slice() : [+n, +n] };
    dA._createSymbol = function(t, e, n, i, r) { this.removeAll(); var a = e.getItemVisual(n, "color"),
            o = $h(t, -1, -1, 2, 2, a, r);
        o.attr({ z2: 100, culling: !0, scale: wd(i) }), o.drift = Md, this._symbolType = t, this.add(o) }, dA.stopSymbolAnimation = function(t) { this.childAt(0).stopAnimation(t) }, dA.getSymbolPath = function() { return this.childAt(0) }, dA.getScale = function() { return this.childAt(0).scale }, dA.highlight = function() { this.childAt(0).trigger("emphasis") }, dA.downplay = function() { this.childAt(0).trigger("normal") }, dA.setZ = function(t, e) { var n = this.childAt(0);
        n.zlevel = t, n.z = e }, dA.setDraggable = function(t) { var e = this.childAt(0);
        e.draggable = t, e.cursor = t ? "move" : e.cursor }, dA.updateData = function(t, e, n) { this.silent = !1; var i = t.getItemVisual(e, "symbol") || "circle",
            r = t.hostModel,
            a = fA(t, e),
            o = i !== this._symbolType; if (o) { var s = t.getItemVisual(e, "symbolKeepAspect");
            this._createSymbol(i, t, e, a, s) } else { var l = this.childAt(0);
            l.silent = !1, no(l, { scale: wd(a) }, r, e) } if (this._updateCommon(t, e, a, n), o) { var l = this.childAt(0),
                u = n && n.fadeIn,
                h = { scale: l.scale.slice() };
            u && (h.style = { opacity: l.style.opacity }), l.scale = [0, 0], u && (l.style.opacity = 0), io(l, h, r, e) }
        this._seriesModel = r };
    var pA = ["itemStyle"],
        gA = ["emphasis", "itemStyle"],
        vA = ["label"],
        mA = ["emphasis", "label"];
    dA._updateCommon = function(t, e, n, i) {
        function r(e) { return w ? t.getName(e) : Lc(t, e) } var a = this.childAt(0),
            s = t.hostModel,
            l = t.getItemVisual(e, "color"); "image" !== a.type ? a.useStyle({ strokeNoScale: !0 }) : a.setStyle({ opacity: null, shadowBlur: null, shadowOffsetX: null, shadowOffsetY: null, shadowColor: null }); var u = i && i.itemStyle,
            h = i && i.hoverItemStyle,
            c = i && i.symbolRotate,
            d = i && i.symbolOffset,
            f = i && i.labelModel,
            p = i && i.hoverLabelModel,
            g = i && i.hoverAnimation,
            v = i && i.cursorStyle; if (!i || t.hasItemOption) { var m = i && i.itemModel ? i.itemModel : t.getItemModel(e);
            u = m.getModel(pA).getItemStyle(["color"]), h = m.getModel(gA).getItemStyle(), c = m.getShallow("symbolRotate"), d = m.getShallow("symbolOffset"), f = m.getModel(vA), p = m.getModel(mA), g = m.getShallow("hoverAnimation"), v = m.getShallow("cursor") } else h = o({}, h); var y = a.style;
        a.attr("rotation", (c || 0) * Math.PI / 180 || 0), d && a.attr("position", [So(d[0], n[0]), So(d[1], n[1])]), v && a.attr("cursor", v), a.setColor(l, i && i.symbolInnerColor), a.setStyle(u); var x = t.getItemVisual(e, "opacity");
        null != x && (y.opacity = x); var _ = t.getItemVisual(e, "liftZ"),
            b = a.__z2Origin;
        null != _ ? null == b && (a.__z2Origin = a.z2, a.z2 += _) : null != b && (a.z2 = b, a.__z2Origin = null); var w = i && i.useNameLabel;
        Za(y, h, f, p, { labelFetcher: s, labelDataIndex: e, defaultText: r, isRectText: !0, autoColor: l }), a.__symbolOriginalScale = wd(n), a.hoverStyle = h, a.highDownOnUpdate = g && s.isAnimationEnabled() ? Sd : null, Fa(a) }, dA.fadeOut = function(t, e) { var n = this.childAt(0);
        this.silent = n.silent = !0, !(e && e.keepLabel) && (n.style.text = null), no(n, { style: { opacity: 0 }, scale: [0, 0] }, this._seriesModel, this.dataIndex, t) }, h(bd, N_);
    var yA = Id.prototype;
    yA.updateData = function(t, e) { e = Cd(e); var n = this.group,
            i = t.hostModel,
            r = this._data,
            a = this._symbolCtor,
            o = Ad(t);
        r || n.removeAll(), t.diff(r).add(function(i) { var r = t.getItemLayout(i); if (Td(t, r, i, e)) { var s = new a(t, i, o);
                s.attr("position", r), t.setItemGraphicEl(i, s), n.add(s) } }).update(function(s, l) { var u = r.getItemGraphicEl(l),
                h = t.getItemLayout(s); return Td(t, h, s, e) ? (u ? (u.updateData(t, s, o), no(u, { position: h }, i)) : (u = new a(t, s), u.attr("position", h)), n.add(u), void t.setItemGraphicEl(s, u)) : void n.remove(u) }).remove(function(t) { var e = r.getItemGraphicEl(t);
            e && e.fadeOut(function() { n.remove(e) }) }).execute(), this._data = t }, yA.isPersistent = function() { return !0 }, yA.updateLayout = function() { var t = this._data;
        t && t.eachItemGraphicEl(function(e, n) { var i = t.getItemLayout(n);
            e.attr("position", i) }) }, yA.incrementalPrepareUpdate = function(t) { this._seriesScope = Ad(t), this._data = null, this.group.removeAll() }, yA.incrementalUpdate = function(t, e, n) {
        function i(t) { t.isGroup || (t.incremental = t.useHoverLayer = !0) }
        n = Cd(n); for (var r = t.start; r < t.end; r++) { var a = e.getItemLayout(r); if (Td(e, a, r, n)) { var o = new this._symbolCtor(e, r, this._seriesScope);
                o.traverse(i), o.attr("position", a), this.group.add(o), e.setItemGraphicEl(r, o) } } }, yA.remove = function(t) { var e = this.group,
            n = this._data;
        n && t ? n.eachItemGraphicEl(function(t) { t.fadeOut(function() { e.remove(t) }) }) : e.removeAll() };
    var xA = function(t, e, n, i, r, a, o, s) { for (var l = Ld(t, e), u = [], h = [], c = [], d = [], f = [], p = [], g = [], v = Dd(r, e, o), m = Dd(a, t, s), y = 0; y < l.length; y++) { var x = l[y],
                    _ = !0; switch (x.cmd) {
                    case "=":
                        var b = t.getItemLayout(x.idx),
                            w = e.getItemLayout(x.idx1);
                        (isNaN(b[0]) || isNaN(b[1])) && (b = w.slice()), u.push(b), h.push(w), c.push(n[x.idx]), d.push(i[x.idx1]), g.push(e.getRawIndex(x.idx1)); break;
                    case "+":
                        var M = x.idx;
                        u.push(r.dataToPoint([e.get(v.dataDimsForPoint[0], M), e.get(v.dataDimsForPoint[1], M)])), h.push(e.getItemLayout(M).slice()), c.push(Pd(v, r, e, M)), d.push(i[M]), g.push(e.getRawIndex(M)); break;
                    case "-":
                        var M = x.idx,
                            S = t.getRawIndex(M);
                        S !== M ? (u.push(t.getItemLayout(M)), h.push(a.dataToPoint([t.get(m.dataDimsForPoint[0], M), t.get(m.dataDimsForPoint[1], M)])), c.push(n[M]), d.push(Pd(m, a, t, M)), g.push(S)) : _ = !1 }
                _ && (f.push(x), p.push(p.length)) }
            p.sort(function(t, e) { return g[t] - g[e] }); for (var I = [], T = [], C = [], A = [], D = [], y = 0; y < p.length; y++) { var M = p[y];
                I[y] = u[M], T[y] = h[M], C[y] = c[M], A[y] = d[M], D[y] = f[M] } return { current: I, next: T, stackedOnCurrent: C, stackedOnNext: A, status: D } },
        _A = oe,
        bA = se,
        wA = X,
        MA = G,
        SA = [],
        IA = [],
        TA = [],
        CA = ia.extend({ type: "ec-polyline", shape: { points: [], smooth: 0, smoothConstraint: !0, smoothMonotone: null, connectNulls: !1 }, style: { fill: null, stroke: "#000" }, brush: nM(ia.prototype.brush), buildPath: function(t, e) { var n = e.points,
                    i = 0,
                    r = n.length,
                    a = Bd(n, e.smoothConstraint); if (e.connectNulls) { for (; r > 0 && Od(n[r - 1]); r--); for (; r > i && Od(n[i]); i++); } for (; r > i;) i += zd(t, n, i, r, r, 1, a.min, a.max, e.smooth, e.smoothMonotone, e.connectNulls) + 1 } }),
        AA = ia.extend({ type: "ec-polygon", shape: { points: [], stackedOnPoints: [], smooth: 0, stackedOnSmooth: 0, smoothConstraint: !0, smoothMonotone: null, connectNulls: !1 }, brush: nM(ia.prototype.brush), buildPath: function(t, e) { var n = e.points,
                    i = e.stackedOnPoints,
                    r = 0,
                    a = n.length,
                    o = e.smoothMonotone,
                    s = Bd(n, e.smoothConstraint),
                    l = Bd(i, e.smoothConstraint); if (e.connectNulls) { for (; a > 0 && Od(n[a - 1]); a--); for (; a > r && Od(n[r]); r++); } for (; a > r;) { var u = zd(t, n, r, a, a, 1, s.min, s.max, e.smooth, o, e.connectNulls);
                    zd(t, i, r + u - 1, u, a, -1, l.min, l.max, e.stackedOnSmooth, o, e.connectNulls), r += u + 1, t.closePath() } } });
    fl.extend({
        type: "line",
        init: function() { var t = new N_,
                e = new Id;
            this.group.add(e.group), this._symbolDraw = e, this._lineGroup = t },
        render: function(t, e, n) {
            var i = t.coordinateSystem,
                r = this.group,
                a = t.getData(),
                o = t.getModel("lineStyle"),
                l = t.getModel("areaStyle"),
                u = a.mapArray(a.getItemLayout),
                h = "polar" === i.type,
                c = this._coordSys,
                d = this._symbolDraw,
                f = this._polyline,
                p = this._polygon,
                g = this._lineGroup,
                v = t.get("animation"),
                m = !l.isEmpty(),
                y = l.get("origin"),
                x = Dd(i, a, y),
                _ = Fd(i, a, x),
                b = t.get("showSymbol"),
                w = b && !h && Wd(t, a, i),
                M = this._data;
            M && M.eachItemGraphicEl(function(t, e) { t.__temp && (r.remove(t), M.setItemGraphicEl(e, null)) }), b || d.remove(), r.add(g);
            var S, I = !h && t.get("step");
            i && i.getArea && t.get("clip", !0) && (S = i.getArea(), null != S.width ? (S.x -= .1, S.y -= .1, S.width += .2, S.height += .2) : S.r0 && (S.r0 -= .5, S.r1 += .5)), this._clipShapeForSymbol = S, f && c.type === i.type && I === this._step ? (m && !p ? p = this._newPolygon(u, _, i, v) : p && !m && (g.remove(p), p = this._polygon = null), g.setClipPath(Ud(i, !1, t)), b && d.updateData(a, { isIgnore: w, clipShape: S }), a.eachItemGraphicEl(function(t) { t.stopAnimation(!0) }), Nd(this._stackedOnPoints, _) && Nd(this._points, u) || (v ? this._updateAnimation(a, _, i, n, I, y) : (I && (u = Hd(u, i, I), _ = Hd(_, i, I)), f.setShape({ points: u }), p && p.setShape({ points: u, stackedOnPoints: _ })))) : (b && d.updateData(a, { isIgnore: w, clipShape: S }), I && (u = Hd(u, i, I), _ = Hd(_, i, I)), f = this._newPolyline(u, i, v), m && (p = this._newPolygon(u, _, i, v)), g.setClipPath(Ud(i, !0, t)));
            var T = Gd(a, i) || a.getVisual("color");
            f.useStyle(s(o.getLineStyle(), { fill: "none", stroke: T, lineJoin: "bevel" }));
            var C = t.get("smooth");
            if (C = Vd(t.get("smooth")), f.setShape({ smooth: C, smoothMonotone: t.get("smoothMonotone"), connectNulls: t.get("connectNulls") }), p) { var A = a.getCalculationInfo("stackedOnSeries"),
                    D = 0;
                p.useStyle(s(l.getAreaStyle(), { fill: T, opacity: .7, lineJoin: "bevel" })), A && (D = Vd(A.get("smooth"))), p.setShape({ smooth: C, stackedOnSmooth: D, smoothMonotone: t.get("smoothMonotone"), connectNulls: t.get("connectNulls") }) }
            this._data = a, this._coordSys = i, this._stackedOnPoints = _, this._points = u, this._step = I, this._valueOrigin = y
        },
        dispose: function() {},
        highlight: function(t, e, n, i) { var r = t.getData(),
                a = hr(r, i); if (!(a instanceof Array) && null != a && a >= 0) { var o = r.getItemGraphicEl(a); if (!o) { var s = r.getItemLayout(a); if (!s) return; if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(s[0], s[1])) return;
                    o = new bd(r, a), o.position = s, o.setZ(t.get("zlevel"), t.get("z")), o.ignore = isNaN(s[0]) || isNaN(s[1]), o.__temp = !0, r.setItemGraphicEl(a, o), o.stopSymbolAnimation(!0), this.group.add(o) }
                o.highlight() } else fl.prototype.highlight.call(this, t, e, n, i) },
        downplay: function(t, e, n, i) { var r = t.getData(),
                a = hr(r, i); if (null != a && a >= 0) { var o = r.getItemGraphicEl(a);
                o && (o.__temp ? (r.setItemGraphicEl(a, null), this.group.remove(o)) : o.downplay()) } else fl.prototype.downplay.call(this, t, e, n, i) },
        _newPolyline: function(t) { var e = this._polyline; return e && this._lineGroup.remove(e), e = new CA({ shape: { points: t }, silent: !0, z2: 10 }), this._lineGroup.add(e), this._polyline = e, e },
        _newPolygon: function(t, e) { var n = this._polygon; return n && this._lineGroup.remove(n), n = new AA({ shape: { points: t, stackedOnPoints: e }, silent: !0 }), this._lineGroup.add(n), this._polygon = n, n },
        _updateAnimation: function(t, e, n, i, r, a) { var o = this._polyline,
                s = this._polygon,
                l = t.hostModel,
                u = xA(this._data, t, this._stackedOnPoints, e, this._coordSys, n, this._valueOrigin, a),
                h = u.current,
                c = u.stackedOnCurrent,
                d = u.next,
                f = u.stackedOnNext;
            r && (h = Hd(u.current, n, r), c = Hd(u.stackedOnCurrent, n, r), d = Hd(u.next, n, r), f = Hd(u.stackedOnNext, n, r)), o.shape.__points = u.current, o.shape.points = h, no(o, { shape: { points: d } }, l), s && (s.setShape({ points: h, stackedOnPoints: c }), no(s, { shape: { points: d, stackedOnPoints: f } }, l)); for (var p = [], g = u.status, v = 0; v < g.length; v++) { var m = g[v].cmd; if ("=" === m) { var y = t.getItemGraphicEl(g[v].idx1);
                    y && p.push({ el: y, ptIdx: v }) } }
            o.animators && o.animators.length && o.animators[0].during(function() { for (var t = 0; t < p.length; t++) { var e = p[t].el;
                    e.attr("position", o.shape.__points[p[t].ptIdx]) } }) },
        remove: function() { var t = this.group,
                e = this._data;
            this._lineGroup.removeAll(), this._symbolDraw.remove(!0), e && e.eachItemGraphicEl(function(n, i) { n.__temp && (t.remove(n), e.setItemGraphicEl(i, null)) }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null }
    });
    var DA = function(t, e, n) { return { seriesType: t, performRawSeries: !0, reset: function(t, i) {
                    function r(e, n) { if (c) { var i = t.getRawValue(n),
                                r = t.getDataParams(n);
                            u && e.setItemVisual(n, "symbol", o(i, r)), h && e.setItemVisual(n, "symbolSize", s(i, r)) } if (e.hasItemOption) { var a = e.getItemModel(n),
                                l = a.getShallow("symbol", !0),
                                d = a.getShallow("symbolSize", !0),
                                f = a.getShallow("symbolKeepAspect", !0);
                            null != l && e.setItemVisual(n, "symbol", l), null != d && e.setItemVisual(n, "symbolSize", d), null != f && e.setItemVisual(n, "symbolKeepAspect", f) } } var a = t.getData(),
                        o = t.get("symbol"),
                        s = t.get("symbolSize"),
                        l = t.get("symbolKeepAspect"),
                        u = b(o),
                        h = b(s),
                        c = u || h,
                        d = !u && o ? o : e,
                        f = h ? null : s; return a.setVisual({ legendSymbol: n || d, symbol: d, symbolSize: f, symbolKeepAspect: l }), i.isSeriesFiltered(t) ? void 0 : { dataEach: a.hasItemOption || c ? r : null } } } },
        kA = function(t) { return { seriesType: t, plan: $S(), reset: function(t) {
                    function e(t, e) { for (var n = t.end - t.start, r = a && new Float32Array(n * s), l = t.start, u = 0, h = [], c = []; l < t.end; l++) { var d; if (1 === s) { var f = e.get(o[0], l);
                                d = !isNaN(f) && i.dataToPoint(f, null, c) } else { var f = h[0] = e.get(o[0], l),
                                    p = h[1] = e.get(o[1], l);
                                d = !isNaN(f) && !isNaN(p) && i.dataToPoint(h, null, c) }
                            a ? (r[u++] = d ? d[0] : 0 / 0, r[u++] = d ? d[1] : 0 / 0) : e.setItemLayout(l, d && d.slice() || [0 / 0, 0 / 0]) }
                        a && e.setLayout("symbolPoints", r) } var n = t.getData(),
                        i = t.coordinateSystem,
                        r = t.pipelineContext,
                        a = r.large; if (i) { var o = p(i.dimensions, function(t) { return n.mapDimension(t) }).slice(0, 2),
                            s = o.length,
                            l = n.getCalculationInfo("stackResultDimension"); return fh(n, o[0]) && (o[0] = l), fh(n, o[1]) && (o[1] = l), s && { progress: e } } } } },
        PA = { average: function(t) { for (var e = 0, n = 0, i = 0; i < t.length; i++) isNaN(t[i]) || (e += t[i], n++); return 0 === n ? 0 / 0 : e / n }, sum: function(t) { for (var e = 0, n = 0; n < t.length; n++) e += t[n] || 0; return e }, max: function(t) { for (var e = -1 / 0, n = 0; n < t.length; n++) t[n] > e && (e = t[n]); return isFinite(e) ? e : 0 / 0 }, min: function(t) { for (var e = 1 / 0, n = 0; n < t.length; n++) t[n] < e && (e = t[n]); return isFinite(e) ? e : 0 / 0 }, nearest: function(t) { return t[0] } },
        LA = function(t) { return Math.round(t.length / 2) },
        OA = function(t) { return { seriesType: t, modifyOutputEnd: !0, reset: function(t) { var e = t.getData(),
                        n = t.get("sampling"),
                        i = t.coordinateSystem; if ("cartesian2d" === i.type && n) { var r = i.getBaseAxis(),
                            a = i.getOtherAxis(r),
                            o = r.getExtent(),
                            s = o[1] - o[0],
                            l = Math.round(e.count() / s); if (l > 1) { var u; "string" == typeof n ? u = PA[n] : "function" == typeof n && (u = n), u && t.setData(e.downSample(e.mapDimension(a.dim), 1 / l, u, LA)) } } } } };
    Du(DA("line", "circle", "line")), Au(kA("line")), Mu(QI.PROCESSOR.STATISTIC, OA("line"));
    var zA = function(t, e, n) { e = _(e) && { coordDimensions: e } || o({}, e); var i = t.getSource(),
                r = zT(i, e),
                a = new PT(r, t); return a.initData(i, n), a },
        EA = { updateSelectedMap: function(t) { this._targetList = _(t) ? t.slice() : [], this._selectTargetMap = g(t || [], function(t, e) { return t.set(e.name, e), t }, N()) }, select: function(t, e) { var n = null != e ? this._targetList[e] : this._selectTargetMap.get(t),
                    i = this.get("selectedMode"); "single" === i && this._selectTargetMap.each(function(t) { t.selected = !1 }), n && (n.selected = !0) }, unSelect: function(t, e) { var n = null != e ? this._targetList[e] : this._selectTargetMap.get(t);
                n && (n.selected = !1) }, toggleSelected: function(t, e) { var n = null != e ? this._targetList[e] : this._selectTargetMap.get(t); return null != n ? (this[n.selected ? "unSelect" : "select"](t, e), n.selected) : void 0 }, isSelected: function(t, e) { var n = null != e ? this._targetList[e] : this._selectTargetMap.get(t); return n && n.selected } },
        RA = zu({ type: "series.pie", init: function(t) { RA.superApply(this, "init", arguments), this.legendVisualProvider = new Xd(y(this.getData, this), y(this.getRawData, this)), this.updateSelectedMap(this._createSelectableList()), this._defaultLabelLine(t) }, mergeOption: function(t) { RA.superCall(this, "mergeOption", t), this.updateSelectedMap(this._createSelectableList()) }, getInitialData: function() { return zA(this, { coordDimensions: ["value"], encodeDefaulter: x(gs, this) }) }, _createSelectableList: function() { for (var t = this.getRawData(), e = t.mapDimension("value"), n = [], i = 0, r = t.count(); r > i; i++) n.push({ name: t.getName(i), value: t.get(e, i), selected: tl(t, i, "selected") }); return n }, getDataParams: function(t) { var e = this.getData(),
                    n = RA.superCall(this, "getDataParams", t),
                    i = []; return e.each(e.mapDimension("value"), function(t) { i.push(t) }), n.percent = ko(i, t, e.hostModel.get("percentPrecision")), n.$vars.push("percent"), n }, _defaultLabelLine: function(t) { nr(t, "labelLine", ["show"]); var e = t.labelLine,
                    n = t.emphasis.labelLine;
                e.show = e.show && t.label.show, n.show = n.show && t.emphasis.label.show }, defaultOption: { zlevel: 0, z: 2, legendHoverLink: !0, hoverAnimation: !0, center: ["50%", "50%"], radius: [0, "75%"], clockwise: !0, startAngle: 90, minAngle: 0, minShowLabelAngle: 0, selectedOffset: 10, hoverOffset: 10, avoidLabelOverlap: !0, percentPrecision: 2, stillShowZeroSum: !0, left: 0, top: 0, right: 0, bottom: 0, width: null, height: null, label: { rotate: !1, show: !0, position: "outer", alignTo: "none", margin: "25%", bleedMargin: 10, distanceToLabelLine: 5 }, labelLine: { show: !0, length: 15, length2: 15, smooth: !1, lineStyle: { width: 1, type: "solid" } }, itemStyle: { borderWidth: 1 }, animationType: "expansion", animationTypeUpdate: "transition", animationEasing: "cubicOut" } });
    c(RA, EA);
    var BA = qd.prototype;
    BA.updateData = function(t, e, n) { var i = this.childAt(0),
            r = this.childAt(1),
            a = this.childAt(2),
            l = t.hostModel,
            u = t.getItemModel(e),
            h = t.getItemLayout(e),
            c = o({}, h);
        c.label = null; var d = l.getShallow("animationTypeUpdate"); if (n) { i.setShape(c); var f = l.getShallow("animationType"); "scale" === f ? (i.shape.r = h.r0, io(i, { shape: { r: h.r } }, l, e)) : (i.shape.endAngle = h.startAngle, no(i, { shape: { endAngle: h.endAngle } }, l, e)) } else "expansion" === d ? i.setShape(c) : no(i, { shape: c }, l, e); var p = t.getItemVisual(e, "color");
        i.useStyle(s({ lineJoin: "bevel", fill: p }, u.getModel("itemStyle").getItemStyle())), i.hoverStyle = u.getModel("emphasis.itemStyle").getItemStyle(); var g = u.getShallow("cursor");
        g && i.attr("cursor", g), jd(this, t.getItemLayout(e), l.isSelected(t.getName(e)), l.get("selectedOffset"), l.get("animation")); var v = !n && "transition" === d;
        this._updateLabel(t, e, v), this.highDownOnUpdate = u.get("hoverAnimation") && l.isAnimationEnabled() ? function(t, e) { "emphasis" === e ? (r.ignore = r.hoverIgnore, a.ignore = a.hoverIgnore, i.stopAnimation(!0), i.animateTo({ shape: { r: h.r + l.get("hoverOffset") } }, 300, "elasticOut")) : (r.ignore = r.normalIgnore, a.ignore = a.normalIgnore, i.stopAnimation(!0), i.animateTo({ shape: { r: h.r } }, 300, "elasticOut")) } : null, Fa(this) }, BA._updateLabel = function(t, e, n) { var i = this.childAt(1),
            r = this.childAt(2),
            a = t.hostModel,
            o = t.getItemModel(e),
            s = t.getItemLayout(e),
            l = s.label,
            u = t.getItemVisual(e, "color"); if (!l || isNaN(l.x) || isNaN(l.y)) return void(r.ignore = r.normalIgnore = r.hoverIgnore = i.ignore = i.normalIgnore = i.hoverIgnore = !0); var h = { points: l.linePoints || [
                    [l.x, l.y],
                    [l.x, l.y],
                    [l.x, l.y]
                ] },
            c = { x: l.x, y: l.y };
        n ? (no(i, { shape: h }, a, e), no(r, { style: c }, a, e)) : (i.attr({ shape: h }), r.attr({ style: c })), r.attr({ rotation: l.rotation, origin: [l.x, l.y], z2: 10 }); var d = o.getModel("label"),
            f = o.getModel("emphasis.label"),
            p = o.getModel("labelLine"),
            g = o.getModel("emphasis.labelLine"),
            u = t.getItemVisual(e, "color");
        Za(r.style, r.hoverStyle = {}, d, f, { labelFetcher: t.hostModel, labelDataIndex: e, defaultText: l.text, autoColor: u, useInsideStyle: !!l.inside }, { textAlign: l.textAlign, textVerticalAlign: l.verticalAlign, opacity: t.getItemVisual(e, "opacity") }), r.ignore = r.normalIgnore = !d.get("show"), r.hoverIgnore = !f.get("show"), i.ignore = i.normalIgnore = !p.get("show"), i.hoverIgnore = !g.get("show"), i.setStyle({ stroke: u, opacity: t.getItemVisual(e, "opacity") }), i.setStyle(p.getModel("lineStyle").getLineStyle()), i.hoverStyle = g.getModel("lineStyle").getLineStyle(); var v = p.get("smooth");
        v && v === !0 && (v = .4), i.setShape({ smooth: v }) }, h(qd, N_);
    var NA = (fl.extend({ type: "pie", init: function() { var t = new N_;
                this._sectorGroup = t }, render: function(t, e, n, i) { if (!i || i.from !== this.uid) { var r = t.getData(),
                        a = this._data,
                        o = this.group,
                        s = e.get("animation"),
                        l = !a,
                        u = t.get("animationType"),
                        h = t.get("animationTypeUpdate"),
                        c = x(Yd, this.uid, t, s, n),
                        d = t.get("selectedMode"); if (r.diff(a).add(function(t) { var e = new qd(r, t);
                            l && "scale" !== u && e.eachChild(function(t) { t.stopAnimation(!0) }), d && e.on("click", c), r.setItemGraphicEl(t, e), o.add(e) }).update(function(t, e) { var n = a.getItemGraphicEl(e);
                            l || "transition" === h || n.eachChild(function(t) { t.stopAnimation(!0) }), n.updateData(r, t), n.off("click"), d && n.on("click", c), o.add(n), r.setItemGraphicEl(t, n) }).remove(function(t) { var e = a.getItemGraphicEl(t);
                            o.remove(e) }).execute(), s && r.count() > 0 && (l ? "scale" !== u : "transition" !== h)) { for (var f = r.getItemLayout(0), p = 1; isNaN(f.startAngle) && p < r.count(); ++p) f = r.getItemLayout(p); var g = Math.max(n.getWidth(), n.getHeight()) / 2,
                            v = y(o.removeClipPath, o);
                        o.setClipPath(this._createClipPath(f.cx, f.cy, g, f.startAngle, f.clockwise, v, t, l)) } else o.removeClipPath();
                    this._data = r } }, dispose: function() {}, _createClipPath: function(t, e, n, i, r, a, o, s) { var l = new iM({ shape: { cx: t, cy: e, r0: 0, r: n, startAngle: i, endAngle: i, clockwise: r } }),
                    u = s ? io : no; return u(l, { shape: { endAngle: i + (r ? 1 : -1) * Math.PI * 2 } }, o, a), l }, containPoint: function(t, e) { var n = e.getData(),
                    i = n.getItemLayout(0); if (i) { var r = t[0] - i.cx,
                        a = t[1] - i.cy,
                        o = Math.sqrt(r * r + a * a); return o <= i.r && o >= i.r0 } } }), function(t, e) { f(e, function(e) { e.update = "updateView", Iu(e, function(n, i) { var r = {}; return i.eachComponent({ mainType: "series", subType: t, query: n }, function(t) { t[e.method] && t[e.method](n.name, n.dataIndex); var i = t.getData();
                        i.each(function(e) { var n = i.getName(e);
                            r[n] = t.isSelected(n) || !1 }) }), { name: n.name, selected: r, seriesId: n.seriesId } }) }) }),
        VA = function(t) { return { getTargetSeries: function(e) { var n = {},
                        i = N(); return e.eachSeriesByType(t, function(t) { t.__paletteScope = n, i.set(t.uid, t) }), i }, reset: function(t) { var e = t.getRawData(),
                        n = {},
                        i = t.getData();
                    i.each(function(t) { var e = i.getRawIndex(t);
                        n[e] = t }), e.each(function(r) { var a, o = n[r],
                            s = null != o && i.getItemVisual(o, "color", !0),
                            l = null != o && i.getItemVisual(o, "borderColor", !0); if (s && l || (a = e.getItemModel(r)), !s) { var u = a.get("itemStyle.color") || t.getColorFromPalette(e.getName(r) || r + "", t.__paletteScope, e.count());
                            null != o && i.setItemVisual(o, "color", u) } if (!l) { var h = a.get("itemStyle.borderColor");
                            null != o && i.setItemVisual(o, "borderColor", h) } }) } } },
        FA = Math.PI / 180,
        HA = function(t, e, n, i, r, a) { var o, s, l = t.getData(),
                u = [],
                h = !1,
                c = (t.get("minShowLabelAngle") || 0) * FA;
            l.each(function(i) { var a = l.getItemLayout(i),
                    d = l.getItemModel(i),
                    f = d.getModel("label"),
                    p = f.get("position") || d.get("emphasis.label.position"),
                    g = f.get("distanceToLabelLine"),
                    v = f.get("alignTo"),
                    m = So(f.get("margin"), n),
                    y = f.get("bleedMargin"),
                    x = f.getFont(),
                    _ = d.getModel("labelLine"),
                    b = _.get("length");
                b = So(b, n); var w = _.get("length2"); if (w = So(w, n), !(a.angle < c)) { var M, S, I, T, C = (a.startAngle + a.endAngle) / 2,
                        A = Math.cos(C),
                        D = Math.sin(C);
                    o = a.cx, s = a.cy; var k = t.getFormattedLabel(i, "normal") || l.getName(i),
                        P = Yn(k, x, T, "top"),
                        L = "inside" === p || "inner" === p; if ("center" === p) M = a.cx, S = a.cy, T = "center";
                    else { var O = (L ? (a.r + a.r0) / 2 * A : a.r * A) + o,
                            z = (L ? (a.r + a.r0) / 2 * D : a.r * D) + s; if (M = O + 3 * A, S = z + 3 * D, !L) { var E = O + A * (b + e - a.r),
                                R = z + D * (b + e - a.r),
                                B = E + (0 > A ? -1 : 1) * w,
                                N = R;
                            M = "edge" === v ? 0 > A ? r + m : r + n - m : B + (0 > A ? -g : g), S = N, I = [
                                [O, z],
                                [E, R],
                                [B, N]
                            ] }
                        T = L ? "center" : "edge" === v ? A > 0 ? "right" : "left" : A > 0 ? "left" : "right" } var V, F = f.get("rotate");
                    V = "number" == typeof F ? F * (Math.PI / 180) : F ? 0 > A ? -C + Math.PI : -C : 0, h = !!V, a.label = { x: M, y: S, position: p, height: P.height, len: b, len2: w, linePoints: I, textAlign: T, verticalAlign: "middle", rotation: V, inside: L, labelDistance: g, labelAlignTo: v, labelMargin: m, bleedMargin: y, textRect: P, text: k, font: x }, L || u.push(a.label) } }), !h && t.get("avoidLabelOverlap") && $d(u, o, s, e, n, i, r, a) },
        GA = 2 * Math.PI,
        WA = Math.PI / 180,
        ZA = function(t, e, n) { e.eachSeriesByType(t, function(t) { var e = t.getData(),
                    i = e.mapDimension("value"),
                    r = Jd(t, n),
                    a = t.get("center"),
                    o = t.get("radius");
                _(o) || (o = [0, o]), _(a) || (a = [a, a]); var s = So(r.width, n.getWidth()),
                    l = So(r.height, n.getHeight()),
                    u = Math.min(s, l),
                    h = So(a[0], s) + r.x,
                    c = So(a[1], l) + r.y,
                    d = So(o[0], u / 2),
                    f = So(o[1], u / 2),
                    p = -t.get("startAngle") * WA,
                    g = t.get("minAngle") * WA,
                    v = 0;
                e.each(i, function(t) {!isNaN(t) && v++ }); var m = e.getSum(i),
                    y = Math.PI / (m || v) * 2,
                    x = t.get("clockwise"),
                    b = t.get("roseType"),
                    w = t.get("stillShowZeroSum"),
                    M = e.getDataExtent(i);
                M[0] = 0; var S = GA,
                    I = 0,
                    T = p,
                    C = x ? 1 : -1; if (e.each(i, function(t, n) { var i; if (isNaN(t)) return void e.setItemLayout(n, { angle: 0 / 0, startAngle: 0 / 0, endAngle: 0 / 0, clockwise: x, cx: h, cy: c, r0: d, r: b ? 0 / 0 : f, viewRect: r });
                        i = "area" !== b ? 0 === m && w ? y : t * y : GA / v, g > i ? (i = g, S -= g) : I += t; var a = T + C * i;
                        e.setItemLayout(n, { angle: i, startAngle: T, endAngle: a, clockwise: x, cx: h, cy: c, r0: d, r: b ? Mo(t, M, [d, f]) : f, viewRect: r }), T = a }), GA > S && v)
                    if (.001 >= S) { var A = GA / v;
                        e.each(i, function(t, n) { if (!isNaN(t)) { var i = e.getItemLayout(n);
                                i.angle = A, i.startAngle = p + C * n * A, i.endAngle = p + C * (n + 1) * A } }) } else y = S / I, T = p, e.each(i, function(t, n) { if (!isNaN(t)) { var i = e.getItemLayout(n),
                                r = i.angle === g ? g : t * y;
                            i.startAngle = T, i.endAngle = T + C * r, T += C * r } });
                HA(t, f, r.width, r.height, r.x, r.y) }) },
        UA = function(t) { return { seriesType: t, reset: function(t, e) { var n = e.findComponents({ mainType: "legend" }); if (n && n.length) { var i = t.getData();
                        i.filterSelf(function(t) { for (var e = i.getName(t), r = 0; r < n.length; r++)
                                if (!n[r].isSelected(e)) return !1;
                            return !0 }) } } } };
    NA("pie", [{ type: "pieToggleSelect", event: "pieselectchanged", method: "toggleSelected" }, { type: "pieSelect", event: "pieselected", method: "select" }, { type: "pieUnSelect", event: "pieunselected", method: "unSelect" }]), Du(VA("pie")), Au(x(ZA, "pie")), Mu(UA("pie"));
    var XA = function(t) { this._directed = t || !1, this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this.data, this.edgeData },
        YA = XA.prototype;
    YA.type = "graph", YA.isDirected = function() { return this._directed }, YA.addNode = function(t, e) { t = null == t ? "" + e : "" + t; var n = this._nodesMap; if (!n[tf(t)]) { var i = new ef(t, e); return i.hostGraph = this, this.nodes.push(i), n[tf(t)] = i, i } }, YA.getNodeByIndex = function(t) { var e = this.data.getRawIndex(t); return this.nodes[e] }, YA.getNodeById = function(t) { return this._nodesMap[tf(t)] }, YA.addEdge = function(t, e, n) { var i = this._nodesMap,
            r = this._edgesMap; if ("number" == typeof t && (t = this.nodes[t]), "number" == typeof e && (e = this.nodes[e]), ef.isInstance(t) || (t = i[tf(t)]), ef.isInstance(e) || (e = i[tf(e)]), t && e) { var a = t.id + "-" + e.id; if (!r[a]) { var o = new nf(t, e, n); return o.hostGraph = this, this._directed && (t.outEdges.push(o), e.inEdges.push(o)), t.edges.push(o), t !== e && e.edges.push(o), this.edges.push(o), r[a] = o, o } } }, YA.getEdgeByIndex = function(t) { var e = this.edgeData.getRawIndex(t); return this.edges[e] }, YA.getEdge = function(t, e) { ef.isInstance(t) && (t = t.id), ef.isInstance(e) && (e = e.id); var n = this._edgesMap; return this._directed ? n[t + "-" + e] : n[t + "-" + e] || n[e + "-" + t] }, YA.eachNode = function(t, e) { for (var n = this.nodes, i = n.length, r = 0; i > r; r++) n[r].dataIndex >= 0 && t.call(e, n[r], r) }, YA.eachEdge = function(t, e) { for (var n = this.edges, i = n.length, r = 0; i > r; r++) n[r].dataIndex >= 0 && n[r].node1.dataIndex >= 0 && n[r].node2.dataIndex >= 0 && t.call(e, n[r], r) }, YA.breadthFirstTraverse = function(t, e, n, i) { if (ef.isInstance(e) || (e = this._nodesMap[tf(e)]), e) { for (var r = "out" === n ? "outEdges" : "in" === n ? "inEdges" : "edges", a = 0; a < this.nodes.length; a++) this.nodes[a].__visited = !1; if (!t.call(i, e, null))
                for (var o = [e]; o.length;)
                    for (var s = o.shift(), l = s[r], a = 0; a < l.length; a++) { var u = l[a],
                            h = u.node1 === s ? u.node2 : u.node1; if (!h.__visited) { if (t.call(i, h, s)) return;
                            o.push(h), h.__visited = !0 } } } }, YA.update = function() { for (var t = this.data, e = this.edgeData, n = this.nodes, i = this.edges, r = 0, a = n.length; a > r; r++) n[r].dataIndex = -1; for (var r = 0, a = t.count(); a > r; r++) n[t.getRawIndex(r)].dataIndex = r;
        e.filterSelf(function(t) { var n = i[e.getRawIndex(t)]; return n.node1.dataIndex >= 0 && n.node2.dataIndex >= 0 }); for (var r = 0, a = i.length; a > r; r++) i[r].dataIndex = -1; for (var r = 0, a = e.count(); a > r; r++) i[e.getRawIndex(r)].dataIndex = r }, YA.clone = function() { for (var t = new XA(this._directed), e = this.nodes, n = this.edges, i = 0; i < e.length; i++) t.addNode(e[i].id, e[i].dataIndex); for (var i = 0; i < n.length; i++) { var r = n[i];
            t.addEdge(r.node1.id, r.node2.id, r.dataIndex) } return t }, ef.prototype = { constructor: ef, degree: function() { return this.edges.length }, inDegree: function() { return this.inEdges.length }, outDegree: function() { return this.outEdges.length }, getModel: function(t) { if (!(this.dataIndex < 0)) { var e = this.hostGraph,
                    n = e.data.getItemModel(this.dataIndex); return n.getModel(t) } } }, nf.prototype.getModel = function(t) { if (!(this.dataIndex < 0)) { var e = this.hostGraph,
                n = e.edgeData.getItemModel(this.dataIndex); return n.getModel(t) } };
    var jA = function(t, e) { return { getValue: function(n) { var i = this[t][e]; return i.get(i.getDimension(n || "value"), this.dataIndex) }, setVisual: function(n, i) { this.dataIndex >= 0 && this[t][e].setItemVisual(this.dataIndex, n, i) }, getVisual: function(n, i) { return this[t][e].getItemVisual(this.dataIndex, n, i) }, setLayout: function(n, i) { this.dataIndex >= 0 && this[t][e].setItemLayout(this.dataIndex, n, i) }, getLayout: function() { return this[t][e].getItemLayout(this.dataIndex) }, getGraphicEl: function() { return this[t][e].getItemGraphicEl(this.dataIndex) }, getRawIndex: function() { return this[t][e].getRawIndex(this.dataIndex) } } };
    c(ef, jA("hostGraph", "data")), c(nf, jA("hostGraph", "edgeData")), XA.Node = ef, XA.Edge = nf, _r(ef), _r(nf);
    var qA = f,
        KA = "\x00__link_datas",
        $A = "\x00__link_mainData",
        QA = function(t, e, n, i, r) { for (var a = new XA(i), o = 0; o < t.length; o++) a.addNode(A(t[o].id, t[o].name, o), o); for (var s = [], l = [], h = 0, o = 0; o < e.length; o++) { var c = e[o],
                    d = c.source,
                    f = c.target;
                a.addEdge(d, f, h) && (l.push(c), s.push(A(c.id, d + " > " + f)), h++) } var p, g = n.get("coordinateSystem"); if ("cartesian2d" === g || "polar" === g) p = gh(t, n);
            else { var v = Cs.get(g),
                    m = v && "view" !== v.type ? v.dimensions || [] : [];
                u(m, "value") < 0 && m.concat(["value"]); var y = zT(t, { coordDimensions: m });
                p = new PT(y, n), p.initData(t) } var x = new PT(["value"], n); return x.initData(l, s), r && r(p, x), rf({ mainData: p, struct: a, structAttr: "graph", datas: { node: p, edge: x }, datasAttr: { node: "data", edge: "edgeData" } }), a.update(), a },
        JA = zu({ type: "series.graph", init: function(t) {
                function e() { return n._categoriesData }
                JA.superApply(this, "init", arguments); var n = this;
                this.legendVisualProvider = new Xd(e, e), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData() }, mergeOption: function(t) { JA.superApply(this, "mergeOption", arguments), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData() }, mergeDefaultAndTheme: function(t) { JA.superApply(this, "mergeDefaultAndTheme", arguments), nr(t, ["edgeLabel"], ["show"]) }, getInitialData: function(t, e) {
                function n(t, n) {
                    function i(t) { return t = this.parsePath(t), t && "label" === t[0] ? o : t && "emphasis" === t[0] && "label" === t[1] ? l : this.parentModel }
                    t.wrapMethod("getItemModel", function(t) { var e = a._categoriesModels,
                            n = t.getShallow("category"),
                            i = e[n]; return i && (i.parentModel = t.parentModel, t.parentModel = i), t }); var r = a.getModel("edgeLabel"),
                        o = new vo({ label: r.option }, r.parentModel, e),
                        s = a.getModel("emphasis.edgeLabel"),
                        l = new vo({ emphasis: { label: s.option } }, s.parentModel, e);
                    n.wrapMethod("getItemModel", function(t) { return t.customizeGetParent(i), t }) } var i = t.edges || t.links || [],
                    r = t.data || t.nodes || [],
                    a = this; return r && i ? QA(r, i, this, !0, n).data : void 0 }, getGraph: function() { return this.getData().graph }, getEdgeData: function() { return this.getGraph().edgeData }, getCategoriesData: function() { return this._categoriesData }, formatTooltip: function(t, e, n) { if ("edge" === n) { var i = this.getData(),
                        r = this.getDataParams(t, n),
                        a = i.graph.getEdgeByIndex(t),
                        o = i.getName(a.node1.dataIndex),
                        s = i.getName(a.node2.dataIndex),
                        l = []; return null != o && l.push(o), null != s && l.push(s), l = Go(l.join(" > ")), r.value && (l += " : " + Go(r.value)), l } return JA.superApply(this, "formatTooltip", arguments) }, _updateCategoriesData: function() { var t = p(this.option.categories || [], function(t) { return null != t.value ? t : o({ value: 0 }, t) }),
                    e = new PT(["value"], this);
                e.initData(t), this._categoriesData = e, this._categoriesModels = e.mapArray(function(t) { return e.getItemModel(t, !0) }) }, setZoom: function(t) { this.option.zoom = t }, setCenter: function(t) { this.option.center = t }, isAnimationEnabled: function() { return JA.superCall(this, "isAnimationEnabled") && !("force" === this.get("layout") && this.get("force.layoutAnimation")) }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "view", legendHoverLink: !0, hoverAnimation: !0, layout: null, focusNodeAdjacency: !1, circular: { rotateLabel: !1 }, force: { initLayout: null, repulsion: [0, 50], gravity: .1, friction: .6, edgeLength: 30, layoutAnimation: !0 }, left: "center", top: "center", symbol: "circle", symbolSize: 10, edgeSymbol: ["none", "none"], edgeSymbolSize: 10, edgeLabel: { position: "middle", distance: 5 }, draggable: !1, roam: !1, center: null, zoom: 1, nodeScaleRatio: .6, label: { show: !1, formatter: "{b}" }, itemStyle: {}, lineStyle: { color: "#aaa", width: 1, curveness: 0, opacity: .5 }, emphasis: { label: { show: !0 } } } }),
        tD = fM.prototype,
        eD = gM.prototype,
        nD = ma({ type: "ec-line", style: { stroke: "#000", fill: null }, shape: { x1: 0, y1: 0, x2: 0, y2: 0, percent: 1, cpx1: null, cpy1: null }, buildPath: function(t, e) { this[df(e) ? "_buildPathLine" : "_buildPathCurve"](t, e) }, _buildPathLine: tD.buildPath, _buildPathCurve: eD.buildPath, pointAt: function(t) { return this[df(this.shape) ? "_pointAtLine" : "_pointAtCurve"](t) }, _pointAtLine: tD.pointAt, _pointAtCurve: eD.pointAt, tangentAt: function(t) { var e = this.shape,
                    n = df(e) ? [e.x2 - e.x1, e.y2 - e.y1] : this._tangentAtCurve(t); return te(n, n) }, _tangentAtCurve: eD.tangentAt }),
        iD = ["fromSymbol", "toSymbol"],
        rD = yf.prototype;
    rD.beforeUpdate = mf, rD._createLine = function(t, e, n) { var i = t.hostModel,
            r = t.getItemLayout(e),
            a = gf(r);
        a.shape.percent = 0, io(a, { shape: { percent: 1 } }, i, e), this.add(a); var o = new Jw({ name: "label", lineLabelOriginalOpacity: 1 });
        this.add(o), f(iD, function(n) { var i = pf(n, t, e);
            this.add(i), this[ff(n)] = t.getItemVisual(e, n) }, this), this._updateCommonStl(t, e, n) }, rD.updateData = function(t, e, n) { var i = t.hostModel,
            r = this.childOfName("line"),
            a = t.getItemLayout(e),
            o = { shape: {} };
        vf(o.shape, a), no(r, o, i, e), f(iD, function(n) { var i = t.getItemVisual(e, n),
                r = ff(n); if (this[r] !== i) { this.remove(this.childOfName(n)); var a = pf(n, t, e);
                this.add(a) }
            this[r] = i }, this), this._updateCommonStl(t, e, n) }, rD._updateCommonStl = function(t, e, n) { var i = t.hostModel,
            r = this.childOfName("line"),
            a = n && n.lineStyle,
            o = n && n.hoverLineStyle,
            l = n && n.labelModel,
            u = n && n.hoverLabelModel; if (!n || t.hasItemOption) { var h = t.getItemModel(e);
            a = h.getModel("lineStyle").getLineStyle(), o = h.getModel("emphasis.lineStyle").getLineStyle(), l = h.getModel("label"), u = h.getModel("emphasis.label") } var c = t.getItemVisual(e, "color"),
            d = k(t.getItemVisual(e, "opacity"), a.opacity, 1);
        r.useStyle(s({ strokeNoScale: !0, fill: "none", stroke: c, opacity: d }, a)), r.hoverStyle = o, f(iD, function(t) { var e = this.childOfName(t);
            e && (e.setColor(c), e.setStyle({ opacity: d })) }, this); var p, g, v = l.getShallow("show"),
            m = u.getShallow("show"),
            y = this.childOfName("label"); if ((v || m) && (p = c || "#000", g = i.getFormattedLabel(e, "normal", t.dataType), null == g)) { var x = i.getRawValue(e);
            g = null == x ? t.getName(e) : isFinite(x) ? Io(x) : x } var b = v ? g : null,
            w = m ? D(i.getFormattedLabel(e, "emphasis", t.dataType), g) : null,
            M = y.style; if (null != b || null != w) { Xa(y.style, l, { text: b }, { autoColor: p }), y.__textAlign = M.textAlign, y.__verticalAlign = M.textVerticalAlign, y.__position = l.get("position") || "middle"; var S = l.get("distance");
            _(S) || (S = [S, S]), y.__labelDistance = S }
        y.hoverStyle = null != w ? { text: w, textFill: u.getTextColor(!0), fontStyle: u.getShallow("fontStyle"), fontWeight: u.getShallow("fontWeight"), fontSize: u.getShallow("fontSize"), fontFamily: u.getShallow("fontFamily") } : { text: null }, y.ignore = !v && !m, Fa(this) }, rD.highlight = function() { this.trigger("emphasis") }, rD.downplay = function() { this.trigger("normal") }, rD.updateLayout = function(t, e) { this.setLinePoints(t.getItemLayout(e)) }, rD.setLinePoints = function(t) { var e = this.childOfName("line");
        vf(e.shape, t), e.dirty() }, h(yf, N_);
    var aD = xf.prototype;
    aD.isPersistent = function() { return !0 }, aD.updateData = function(t) { var e = this,
            n = e.group,
            i = e._lineData;
        e._lineData = t, i || n.removeAll(); var r = wf(t);
        t.diff(i).add(function(n) { _f(e, t, n, r) }).update(function(n, a) { bf(e, i, t, a, n, r) }).remove(function(t) { n.remove(i.getItemGraphicEl(t)) }).execute() }, aD.updateLayout = function() { var t = this._lineData;
        t && t.eachItemGraphicEl(function(e, n) { e.updateLayout(t, n) }, this) }, aD.incrementalPrepareUpdate = function(t) { this._seriesScope = wf(t), this._lineData = null, this.group.removeAll() }, aD.incrementalUpdate = function(t, e) {
        function n(t) { t.isGroup || (t.incremental = t.useHoverLayer = !0) } for (var i = t.start; i < t.end; i++) { var r = e.getItemLayout(i); if (Sf(r)) { var a = new this._ctor(e, i, this._seriesScope);
                a.traverse(n), this.group.add(a), e.setItemGraphicEl(i, a) } } }, aD.remove = function() { this._clearIncremental(), this._incremental = null, this.group.removeAll() }, aD._clearIncremental = function() { var t = this._incremental;
        t && t.clearDisplaybles() };
    var oD = "\x00_ec_interaction_mutex";
    Iu({ type: "takeGlobalCursor", event: "globalCursorTaken", update: "update" }, function() {}), c(Df, Xx);
    var sD = { axisPointer: 1, tooltip: 1, brush: 1 },
        lD = [],
        uD = [],
        hD = [],
        cD = Lr,
        dD = Wx,
        fD = Math.abs,
        pD = function(t, e) { var n = [],
                i = Rr,
                r = [
                    [],
                    [],
                    []
                ],
                a = [
                    [],
                    []
                ],
                o = [];
            e /= 2, t.eachEdge(function(t) { var s = t.getLayout(),
                    l = t.getVisual("fromSymbol"),
                    u = t.getVisual("toSymbol");
                s.__original || (s.__original = [W(s[0]), W(s[1])], s[2] && s.__original.push(W(s[2]))); var h = s.__original; if (null != s[2]) { if (G(r[0], h[0]), G(r[1], h[2]), G(r[2], h[1]), l && "none" !== l) { var c = Gf(t.node1),
                            d = Wf(r, h[0], c * e);
                        i(r[0][0], r[1][0], r[2][0], d, n), r[0][0] = n[3], r[1][0] = n[4], i(r[0][1], r[1][1], r[2][1], d, n), r[0][1] = n[3], r[1][1] = n[4] } if (u && "none" !== u) { var c = Gf(t.node2),
                            d = Wf(r, h[1], c * e);
                        i(r[0][0], r[1][0], r[2][0], d, n), r[1][0] = n[1], r[2][0] = n[2], i(r[0][1], r[1][1], r[2][1], d, n), r[1][1] = n[1], r[2][1] = n[2] }
                    G(s[0], r[0]), G(s[1], r[2]), G(s[2], r[1]) } else { if (G(a[0], h[0]), G(a[1], h[1]), Y(o, a[1], a[0]), te(o, o), l && "none" !== l) { var c = Gf(t.node1);
                        X(a[0], a[0], o, c * e) } if (u && "none" !== u) { var c = Gf(t.node2);
                        X(a[1], a[1], o, -c * e) }
                    G(s[0], a[0]), G(s[1], a[1]) } }) },
        gD = "__focusNodeAdjacency",
        vD = "__unfocusNodeAdjacency",
        mD = ["itemStyle", "opacity"],
        yD = ["lineStyle", "opacity"];
    Eu({ type: "graph", init: function(t, e) { var n = new Id,
                i = new xf,
                r = this.group;
            this._controller = new Df(e.getZr()), this._controllerHost = { target: r }, r.add(n.group), r.add(i.group), this._symbolDraw = n, this._lineDraw = i, this._firstRender = !0 }, render: function(t, e, n) { var i = this,
                r = t.coordinateSystem;
            this._model = t; var a = this._symbolDraw,
                o = this._lineDraw,
                s = this.group; if ("view" === r.type) { var l = { position: r.position, scale: r.scale };
                this._firstRender ? s.attr(l) : no(s, l, t) }
            pD(t.getGraph(), Hf(t)); var u = t.getData();
            a.updateData(u); var h = t.getEdgeData();
            o.updateData(h), this._updateNodeAndLinkScale(), this._updateController(t, e, n), clearTimeout(this._layoutTimeout); var c = t.forceLayout,
                d = t.get("force.layoutAnimation");
            c && this._startForceLayoutIteration(c, d), u.eachItemGraphicEl(function(e, r) { var a = u.getItemModel(r);
                e.off("drag").off("dragend"); var o = a.get("draggable");
                o && e.on("drag", function() { c && (c.warmUp(), !this._layouting && this._startForceLayoutIteration(c, d), c.setFixed(r), u.setItemLayout(r, e.position)) }, this).on("dragend", function() { c && c.setUnfixed(r) }, this), e.setDraggable(o && c), e[gD] && e.off("mouseover", e[gD]), e[vD] && e.off("mouseout", e[vD]), a.get("focusNodeAdjacency") && (e.on("mouseover", e[gD] = function() { i._clearTimer(), n.dispatchAction({ type: "focusNodeAdjacency", seriesId: t.id, dataIndex: e.dataIndex }) }), e.on("mouseout", e[vD] = function() { i._dispatchUnfocus(n) })) }, this), u.graph.eachEdge(function(e) { var r = e.getGraphicEl();
                r[gD] && r.off("mouseover", r[gD]), r[vD] && r.off("mouseout", r[vD]), e.getModel().get("focusNodeAdjacency") && (r.on("mouseover", r[gD] = function() { i._clearTimer(), n.dispatchAction({ type: "focusNodeAdjacency", seriesId: t.id, edgeDataIndex: e.dataIndex }) }), r.on("mouseout", r[vD] = function() { i._dispatchUnfocus(n) })) }); var f = "circular" === t.get("layout") && t.get("circular.rotateLabel"),
                p = u.getLayout("cx"),
                g = u.getLayout("cy");
            u.eachItemGraphicEl(function(t, e) { var n = u.getItemModel(e),
                    i = n.get("label.rotate") || 0,
                    r = t.getSymbolPath(); if (f) { var a = u.getItemLayout(e),
                        o = Math.atan2(a[1] - g, a[0] - p);
                    0 > o && (o = 2 * Math.PI + o); var s = a[0] < p;
                    s && (o -= Math.PI); var l = s ? "left" : "right";
                    Ua(r, { textRotation: -o, textPosition: l, textOrigin: "center" }, { textPosition: l }) } else Ua(r, { textRotation: i *= Math.PI / 180 }) }), this._firstRender = !1 }, dispose: function() { this._controller && this._controller.dispose(), this._controllerHost = {}, this._clearTimer() }, _dispatchUnfocus: function(t) { var e = this;
            this._clearTimer(), this._unfocusDelayTimer = setTimeout(function() { e._unfocusDelayTimer = null, t.dispatchAction({ type: "unfocusNodeAdjacency", seriesId: e._model.id }) }, 500) }, _clearTimer: function() { this._unfocusDelayTimer && (clearTimeout(this._unfocusDelayTimer), this._unfocusDelayTimer = null) }, focusNodeAdjacency: function(t, e, n, i) { var r = t.getData(),
                a = r.graph,
                o = i.dataIndex,
                s = i.edgeDataIndex,
                l = a.getNodeByIndex(o),
                u = a.getEdgeByIndex(s);
            (l || u) && (a.eachNode(function(t) { Uf(t, mD, .1) }), a.eachEdge(function(t) { Uf(t, yD, .1) }), l && (Xf(l, mD), f(l.edges, function(t) { t.dataIndex < 0 || (Xf(t, yD), Xf(t.node1, mD), Xf(t.node2, mD)) })), u && (Xf(u, yD), Xf(u.node1, mD), Xf(u.node2, mD))) }, unfocusNodeAdjacency: function(t) { var e = t.getData().graph;
            e.eachNode(function(t) { Uf(t, mD) }), e.eachEdge(function(t) { Uf(t, yD) }) }, _startForceLayoutIteration: function(t, e) { var n = this;! function i() { t.step(function(t) { n.updateLayout(n._model), (n._layouting = !t) && (e ? n._layoutTimeout = setTimeout(i, 16) : i()) }) }() }, _updateController: function(t, e, n) { var i = this._controller,
                r = this._controllerHost,
                a = this.group; return i.setPointerChecker(function(e, i, r) { var o = a.getBoundingRect(); return o.applyTransform(a.transform), o.contain(i, r) && !Ff(e, n, t) }), "view" !== t.coordinateSystem.type ? void i.disable() : (i.enable(t.get("roam")), r.zoomLimit = t.get("scaleLimit"), r.zoom = t.coordinateSystem.getZoom(), void i.off("pan").off("zoom").on("pan", function(e) { Nf(r, e.dx, e.dy), n.dispatchAction({ seriesId: t.id, type: "graphRoam", dx: e.dx, dy: e.dy }) }).on("zoom", function(e) { Vf(r, e.scale, e.originX, e.originY), n.dispatchAction({ seriesId: t.id, type: "graphRoam", zoom: e.scale, originX: e.originX, originY: e.originY }), this._updateNodeAndLinkScale(), pD(t.getGraph(), Hf(t)), this._lineDraw.updateLayout() }, this)) }, _updateNodeAndLinkScale: function() { var t = this._model,
                e = t.getData(),
                n = Hf(t),
                i = [n, n];
            e.eachItemGraphicEl(function(t) { t.attr("scale", i) }) }, updateLayout: function(t) { pD(t.getGraph(), Hf(t)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout() }, remove: function() { this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove() } }), Iu({ type: "focusNodeAdjacency", event: "focusNodeAdjacency", update: "series:focusNodeAdjacency" }, function() {}), Iu({ type: "unfocusNodeAdjacency", event: "unfocusNodeAdjacency", update: "series:unfocusNodeAdjacency" }, function() {});
    var xD = { type: "graphRoam", event: "graphRoam", update: "none" };
    Iu(xD, function(t, e) {
        e.eachComponent({ mainType: "series", query: t }, function(e) {
            var n = e.coordinateSystem,
                i = Yf(n, t);
            e.setCenter && e.setCenter(i.center), e.setZoom && e.setZoom(i.zoom)
        })
    });
    var _D = function(t) { var e = t.findComponents({ mainType: "legend" });
            e && e.length && t.eachSeriesByType("graph", function(t) { var n = t.getCategoriesData(),
                    i = t.getGraph(),
                    r = i.data,
                    a = n.mapArray(n.getName);
                r.filterSelf(function(t) { var n = r.getItemModel(t),
                        i = n.getShallow("category"); if (null != i) { "number" == typeof i && (i = a[i]); for (var o = 0; o < e.length; o++)
                            if (!e[o].isSelected(i)) return !1 } return !0 }) }, this) },
        bD = function(t) { var e = {};
            t.eachSeriesByType("graph", function(t) { var n = t.getCategoriesData(),
                    i = t.getData(),
                    r = {};
                n.each(function(i) { var a = n.getName(i);
                    r["ec-" + a] = i; var o = n.getItemModel(i),
                        s = o.get("itemStyle.color") || t.getColorFromPalette(a, e);
                    n.setItemVisual(i, "color", s); for (var l = ["opacity", "symbol", "symbolSize", "symbolKeepAspect"], u = 0; u < l.length; u++) { var h = o.getShallow(l[u], !0);
                        null != h && n.setItemVisual(i, l[u], h) } }), n.count() && i.each(function(t) { var e = i.getItemModel(t),
                        a = e.getShallow("category"); if (null != a) { "string" == typeof a && (a = r["ec-" + a]); for (var o = ["color", "opacity", "symbol", "symbolSize", "symbolKeepAspect"], s = 0; s < o.length; s++) null == i.getItemVisual(t, o[s], !0) && i.setItemVisual(t, o[s], n.getItemVisual(a, o[s])) } }) }) },
        wD = function(t) { t.eachSeriesByType("graph", function(t) { var e = t.getGraph(),
                    n = t.getEdgeData(),
                    i = jf(t.get("edgeSymbol")),
                    r = jf(t.get("edgeSymbolSize")),
                    a = "lineStyle.color".split("."),
                    o = "lineStyle.opacity".split(".");
                n.setVisual("fromSymbol", i && i[0]), n.setVisual("toSymbol", i && i[1]), n.setVisual("fromSymbolSize", r && r[0]), n.setVisual("toSymbolSize", r && r[1]), n.setVisual("color", t.get(a)), n.setVisual("opacity", t.get(o)), n.each(function(t) { var i = n.getItemModel(t),
                        r = e.getEdgeByIndex(t),
                        s = jf(i.getShallow("symbol", !0)),
                        l = jf(i.getShallow("symbolSize", !0)),
                        u = i.get(a),
                        h = i.get(o); switch (u) {
                        case "source":
                            u = r.node1.getVisual("color"); break;
                        case "target":
                            u = r.node2.getVisual("color") }
                    s[0] && r.setVisual("fromSymbol", s[0]), s[1] && r.setVisual("toSymbol", s[1]), l[0] && r.setVisual("fromSymbolSize", l[0]), l[1] && r.setVisual("toSymbolSize", l[1]), r.setVisual("color", u), r.setVisual("opacity", h) }) }) },
        MD = function(t) { t.eachSeriesByType("graph", function(t) { var e = t.get("layout"),
                    n = t.coordinateSystem; if (n && "view" !== n.type) { var i = t.getData(),
                        r = [];
                    f(n.dimensions, function(t) { r = r.concat(i.mapDimension(t, !0)) }); for (var a = 0; a < i.count(); a++) { for (var o = [], s = !1, l = 0; l < r.length; l++) { var u = i.get(r[l], a);
                            isNaN(u) || (s = !0), o.push(u) }
                        s ? i.setItemLayout(a, n.dataToPoint(o)) : i.setItemLayout(a, [0 / 0, 0 / 0]) }
                    Kf(i.graph) } else e && "none" !== e || qf(t) }) },
        SD = Math.PI,
        ID = [],
        TD = { value: function(t, e, n, i, r, a, o, s) { var l = 0,
                    u = i.getSum("value"),
                    h = 2 * Math.PI / (u || s);
                n.eachNode(function(t) { var e = t.getValue("value"),
                        n = h * (u ? e : 1) / 2;
                    l += n, t.setLayout([r * Math.cos(l) + a, r * Math.sin(l) + o]), l += n }) }, symbolSize: function(t, e, n, i, r, a, o, s) { var l = 0;
                ID.length = s; var u = Hf(t);
                n.eachNode(function(t) { var e = Gf(t);
                    isNaN(e) && (e = 2), 0 > e && (e = 0), e *= u; var n = Math.asin(e / 2 / r);
                    isNaN(n) && (n = SD / 2), ID[t.dataIndex] = n, l += 2 * n }); var h = (2 * SD - l) / s / 2,
                    c = 0;
                n.eachNode(function(t) { var e = h + ID[t.dataIndex];
                    c += e, t.setLayout([r * Math.cos(c) + a, r * Math.sin(c) + o]), c += e }) } },
        CD = function(t) { t.eachSeriesByType("graph", function(t) { "circular" === t.get("layout") && $f(t, "symbolSize") }) },
        AD = X,
        DD = function(t) { t.eachSeriesByType("graph", function(t) { var e = t.coordinateSystem; if (!e || "view" === e.type)
                    if ("force" === t.get("layout")) { var n = t.preservedPoints || {},
                            i = t.getGraph(),
                            r = i.data,
                            a = i.edgeData,
                            o = t.getModel("force"),
                            s = o.get("initLayout");
                        t.preservedPoints ? r.each(function(t) { var e = r.getId(t);
                            r.setItemLayout(t, n[e] || [0 / 0, 0 / 0]) }) : s && "none" !== s ? "circular" === s && $f(t, "value") : qf(t); var l = r.getDataExtent("value"),
                            u = a.getDataExtent("value"),
                            h = o.get("repulsion"),
                            c = o.get("edgeLength");
                        _(h) || (h = [h, h]), _(c) || (c = [c, c]), c = [c[1], c[0]]; var d = r.mapArray("value", function(t, e) { var n = r.getItemLayout(e),
                                    i = Mo(t, l, h); return isNaN(i) && (i = (h[0] + h[1]) / 2), { w: i, rep: i, fixed: r.getItemModel(e).get("fixed"), p: !n || isNaN(n[0]) || isNaN(n[1]) ? null : n } }),
                            f = a.mapArray("value", function(t, e) { var n = i.getEdgeByIndex(e),
                                    r = Mo(t, u, c);
                                isNaN(r) && (r = (c[0] + c[1]) / 2); var a = n.getModel(); return { n1: d[n.node1.dataIndex], n2: d[n.node2.dataIndex], d: r, curveness: a.get("lineStyle.curveness") || 0, ignoreForceLayout: a.get("ignoreForceLayout") } }),
                            e = t.coordinateSystem,
                            p = e.getBoundingRect(),
                            g = Qf(d, f, { rect: p, gravity: o.get("gravity"), friction: o.get("friction") }),
                            v = g.step;
                        g.step = function(t) { for (var e = 0, a = d.length; a > e; e++) d[e].fixed && G(d[e].p, i.getNodeByIndex(e).getLayout());
                            v(function(e, a, o) { for (var s = 0, l = e.length; l > s; s++) e[s].fixed || i.getNodeByIndex(s).setLayout(e[s].p), n[r.getId(s)] = e[s].p; for (var s = 0, l = a.length; l > s; s++) { var u = a[s],
                                        h = i.getEdgeByIndex(s),
                                        c = u.n1.p,
                                        d = u.n2.p,
                                        f = h.getLayout();
                                    f = f ? f.slice() : [], f[0] = f[0] || [], f[1] = f[1] || [], G(f[0], c), G(f[1], d), +u.curveness && (f[2] = [(c[0] + d[0]) / 2 - (c[1] - d[1]) * u.curveness, (c[1] + d[1]) / 2 - (d[0] - c[0]) * u.curveness]), h.setLayout(f) }
                                t && t(o) }) }, t.forceLayout = g, t.preservedPoints = n, g.step() } else t.forceLayout = null }) },
        kD = ae;
    c(Jf, u_), tp.prototype = { constructor: tp, type: "view", dimensions: ["x", "y"], setBoundingRect: function(t, e, n, i) { return this._rect = new Cn(t, e, n, i), this._rect }, getBoundingRect: function() { return this._rect }, setViewRect: function(t, e, n, i) { this.transformTo(t, e, n, i), this._viewRect = new Cn(t, e, n, i) }, transformTo: function(t, e, n, i) { var r = this.getBoundingRect(),
                a = this._rawTransformable;
            a.transform = r.calculateTransform(new Cn(t, e, n, i)), a.decomposeTransform(), this._updateTransform() }, setCenter: function(t) { t && (this._center = t, this._updateCenterAndZoom()) }, setZoom: function(t) { t = t || 1; var e = this.zoomLimit;
            e && (null != e.max && (t = Math.min(e.max, t)), null != e.min && (t = Math.max(e.min, t))), this._zoom = t, this._updateCenterAndZoom() }, getDefaultCenter: function() { var t = this.getBoundingRect(),
                e = t.x + t.width / 2,
                n = t.y + t.height / 2; return [e, n] }, getCenter: function() { return this._center || this.getDefaultCenter() }, getZoom: function() { return this._zoom || 1 }, getRoamTransform: function() { return this._roamTransformable.getLocalTransform() }, _updateCenterAndZoom: function() { var t = this._rawTransformable.getLocalTransform(),
                e = this._roamTransformable,
                n = this.getDefaultCenter(),
                i = this.getCenter(),
                r = this.getZoom();
            i = ae([], i, t), n = ae([], n, t), e.origin = i, e.position = [n[0] - i[0], n[1] - i[1]], e.scale = [r, r], this._updateTransform() }, _updateTransform: function() { var t = this._roamTransformable,
                e = this._rawTransformable;
            e.parent = t, t.updateTransform(), e.updateTransform(), Ee(this.transform || (this.transform = []), e.transform || Oe()), this._rawTransform = e.getLocalTransform(), this.invTransform = this.invTransform || [], Fe(this.invTransform, this.transform), this.decomposeTransform() }, getTransformInfo: function() { var t = this._roamTransformable.transform,
                e = this._rawTransformable; return { roamTransform: t ? P(t) : Oe(), rawScale: P(e.scale), rawPosition: P(e.position) } }, getViewRect: function() { return this._viewRect }, getViewRectAfterRoam: function() { var t = this.getBoundingRect().clone(); return t.applyTransform(this.transform), t }, dataToPoint: function(t, e, n) { var i = e ? this._rawTransform : this.transform; return n = n || [], i ? kD(n, t, i) : G(n, t) }, pointToData: function(t) { var e = this.invTransform; return e ? kD([], t, e) : [t[0], t[1]] }, convertToPixel: x(ep, "dataToPoint"), convertFromPixel: x(ep, "pointToData"), containPoint: function(t) { return this.getViewRectAfterRoam().contain(t[0], t[1]) } }, c(tp, u_);
    var PD = function(t, e) { var n = []; return t.eachSeriesByType("graph", function(t) { var i = t.get("coordinateSystem"); if (!i || "view" === i) { var r = t.getData(),
                    a = r.mapArray(function(t) { var e = r.getItemModel(t); return [+e.get("x"), +e.get("y")] }),
                    o = [],
                    s = [];
                Nr(a, o, s), s[0] - o[0] === 0 && (s[0] += 1, o[0] -= 1), s[1] - o[1] === 0 && (s[1] += 1, o[1] -= 1); var l = (s[0] - o[0]) / (s[1] - o[1]),
                    u = np(t, e, l);
                isNaN(l) && (o = [u.x, u.y], s = [u.x + u.width, u.y + u.height]); var h = s[0] - o[0],
                    c = s[1] - o[1],
                    d = u.width,
                    f = u.height,
                    p = t.coordinateSystem = new tp;
                p.zoomLimit = t.get("scaleLimit"), p.setBoundingRect(o[0], o[1], h, c), p.setViewRect(u.x, u.y, d, f), p.setCenter(t.get("center")), p.setZoom(t.get("zoom")), n.push(p) } }), n };
    Mu(_D), Du(DA("graph", "circle", null)), Du(bD), Du(wD), Au(MD), Au(QI.VISUAL.POST_CHART_LAYOUT, CD), Au(DD), Tu("graphView", { create: PD });
    var LD = function(t) { var e = t.grid.getRect(); return { coordSys: { type: "cartesian2d", x: e.x, y: e.y, width: e.width, height: e.height }, api: { coord: function(e) { return t.dataToPoint(e) }, size: y(ip, t) } } },
        OD = function(t) { var e = t.getBoundingRect(); return { coordSys: { type: "geo", x: e.x, y: e.y, width: e.width, height: e.height, zoom: t.getZoom() }, api: { coord: function(e) { return t.dataToPoint(e) }, size: y(rp, t) } } },
        zD = function(t) { var e = t.getRect(); return { coordSys: { type: "singleAxis", x: e.x, y: e.y, width: e.width, height: e.height }, api: { coord: function(e) { return t.dataToPoint(e) }, size: y(ap, t) } } },
        ED = function(t) { var e = t.getRadiusAxis(),
                n = t.getAngleAxis(),
                i = e.getExtent(); return i[0] > i[1] && i.reverse(), { coordSys: { type: "polar", cx: t.cx, cy: t.cy, r: i[1], r0: i[0] }, api: { coord: y(function(i) { var r = e.dataToRadius(i[0]),
                            a = n.dataToAngle(i[1]),
                            o = t.coordToPoint([r, a]); return o.push(r, a * Math.PI / 180), o }), size: y(op, t) } } },
        RD = function(t) { var e = t.getRect(),
                n = t.getRangeInfo(); return { coordSys: { type: "calendar", x: e.x, y: e.y, width: e.width, height: e.height, cellWidth: t.getCellWidth(), cellHeight: t.getCellHeight(), rangeInfo: { start: n.start, end: n.end, weeks: n.weeks, dayCount: n.allDay } }, api: { coord: function(e, n) { return t.dataToPoint(e, n) } } } },
        BD = TM,
        ND = ["itemStyle"],
        VD = ["emphasis", "itemStyle"],
        FD = ["label"],
        HD = ["emphasis", "label"],
        GD = "e\x00\x00",
        WD = { cartesian2d: LD, geo: OD, singleAxis: zD, polar: ED, calendar: RD };
    jS.extend({ type: "series.custom", dependencies: ["grid", "polar", "geo", "singleAxis", "calendar"], defaultOption: { coordinateSystem: "cartesian2d", zlevel: 0, z: 2, legendHoverLink: !0, useTransform: !0, clip: !1 }, getInitialData: function() { return gh(this.getSource(), this) }, getDataParams: function(t, e, n) { var i = jS.prototype.getDataParams.apply(this, arguments); return n && (i.info = n.info), i } }), fl.extend({ type: "custom", _data: null, render: function(t, e, n, i) { var r = this._data,
                a = t.getData(),
                o = this.group,
                s = hp(t, a, e, n);
            a.diff(r).add(function(e) { dp(null, e, s(e, i), t, o, a) }).update(function(e, n) { var l = r.getItemGraphicEl(n);
                dp(l, e, s(e, i), t, o, a) }).remove(function(t) { var e = r.getItemGraphicEl(t);
                e && o.remove(e) }).execute(); var l = t.get("clip", !0) ? Bc(t.coordinateSystem, !1, t) : null;
            l ? o.setClipPath(l) : o.removeClipPath(), this._data = a }, incrementalPrepareRender: function() { this.group.removeAll(), this._data = null }, incrementalRender: function(t, e, n, i, r) {
            function a(t) { t.isGroup || (t.incremental = !0, t.useHoverLayer = !0) } for (var o = e.getData(), s = hp(e, o, n, i), l = t.start; l < t.end; l++) { var u = dp(null, l, s(l, r), e, this.group, o);
                u.traverse(a) } }, dispose: F, filterForExposedEvent: function(t, e, n) { var i = e.element; if (null == i || n.name === i) return !0; for (;
                (n = n.parent) && n !== this.group;)
                if (n.name === i) return !0;
            return !1 } }), Lu({ type: "title", layoutMode: { type: "box", ignoreSize: !0 }, defaultOption: { zlevel: 0, z: 6, show: !0, text: "", target: "blank", subtext: "", subtarget: "blank", left: 0, top: 0, backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderWidth: 0, padding: 5, itemGap: 10, textStyle: { fontSize: 18, fontWeight: "bolder", color: "#333" }, subtextStyle: { color: "#aaa" } } }), Ou({ type: "title", render: function(t, e, n) { if (this.group.removeAll(), t.get("show")) { var i = this.group,
                    r = t.getModel("textStyle"),
                    a = t.getModel("subtextStyle"),
                    o = t.get("textAlign"),
                    s = D(t.get("textBaseline"), t.get("textVerticalAlign")),
                    l = new Jw({ style: Xa({}, r, { text: t.get("text"), textFill: r.getTextColor() }, { disableBox: !0 }), z2: 10 }),
                    u = l.getBoundingRect(),
                    h = t.get("subtext"),
                    c = new Jw({ style: Xa({}, a, { text: h, textFill: a.getTextColor(), y: u.height + t.get("itemGap"), textVerticalAlign: "top" }, { disableBox: !0 }), z2: 10 }),
                    d = t.get("link"),
                    f = t.get("sublink"),
                    p = t.get("triggerEvent", !0);
                l.silent = !d && !p, c.silent = !f && !p, d && l.on("click", function() { window.open(d, "_" + t.get("target")) }), f && c.on("click", function() { window.open(f, "_" + t.get("subtarget")) }), l.eventData = c.eventData = p ? { componentType: "title", componentIndex: t.componentIndex } : null, i.add(l), h && i.add(c); var g = i.getBoundingRect(),
                    v = t.getBoxLayoutParams();
                v.width = g.width, v.height = g.height; var m = Qo(v, { width: n.getWidth(), height: n.getHeight() }, t.get("padding"));
                o || (o = t.get("left") || t.get("right"), "middle" === o && (o = "center"), "right" === o ? m.x += m.width : "center" === o && (m.x += m.width / 2)), s || (s = t.get("top") || t.get("bottom"), "center" === s && (s = "middle"), "bottom" === s ? m.y += m.height : "middle" === s && (m.y += m.height / 2), s = s || "top"), i.attr("position", [m.x, m.y]); var y = { textAlign: o, textVerticalAlign: s };
                l.setStyle(y), c.setStyle(y), g = i.getBoundingRect(); var x = m.margin,
                    _ = t.getItemStyle(["color", "opacity"]);
                _.fill = t.get("backgroundColor"); var b = new cM({ shape: { x: g.x - x[3], y: g.y - x[0], width: g.width + x[1] + x[3], height: g.height + x[0] + x[2], r: t.get("borderRadius") }, style: _, subPixelOptimize: !0, silent: !0 });
                i.add(b) } } });
    var ZD = oI.legend.selector,
        UD = { all: { type: "all", title: i(ZD.all) }, inverse: { type: "inverse", title: i(ZD.inverse) } },
        XD = Lu({ type: "legend.plain", dependencies: ["series"], layoutMode: { type: "box", ignoreSize: !0 }, init: function(t, e, n) { this.mergeDefaultAndTheme(t, n), t.selected = t.selected || {}, this._updateSelector(t) }, mergeOption: function(t) { XD.superCall(this, "mergeOption", t), this._updateSelector(t) }, _updateSelector: function(t) { var e = t.selector;
                e === !0 && (e = t.selector = ["all", "inverse"]), _(e) && f(e, function(t, n) { w(t) && (t = { type: t }), e[n] = r(t, UD[t.type]) }) }, optionUpdated: function() { this._updateData(this.ecModel); var t = this._data; if (t[0] && "single" === this.get("selectedMode")) { for (var e = !1, n = 0; n < t.length; n++) { var i = t[n].get("name"); if (this.isSelected(i)) { this.select(i), e = !0; break } }!e && this.select(t[0].get("name")) } }, _updateData: function(t) { var e = [],
                    n = [];
                t.eachRawSeries(function(i) { var r = i.name;
                    n.push(r); var a; if (i.legendVisualProvider) { var o = i.legendVisualProvider,
                            s = o.getAllNames();
                        t.isSeriesFiltered(i) || (n = n.concat(s)), s.length ? e = e.concat(s) : a = !0 } else a = !0;
                    a && sr(i) && e.push(i.name) }), this._availableNames = n; var i = this.get("data") || e,
                    r = p(i, function(t) { return ("string" == typeof t || "number" == typeof t) && (t = { name: t }), new vo(t, this, this.ecModel) }, this);
                this._data = r }, getData: function() { return this._data }, select: function(t) { var e = this.option.selected,
                    n = this.get("selectedMode"); if ("single" === n) { var i = this._data;
                    f(i, function(t) { e[t.get("name")] = !1 }) }
                e[t] = !0 }, unSelect: function(t) { "single" !== this.get("selectedMode") && (this.option.selected[t] = !1) }, toggleSelected: function(t) { var e = this.option.selected;
                e.hasOwnProperty(t) || (e[t] = !0), this[e[t] ? "unSelect" : "select"](t) }, allSelect: function() { var t = this._data,
                    e = this.option.selected;
                f(t, function(t) { e[t.get("name", !0)] = !0 }) }, inverseSelect: function() { var t = this._data,
                    e = this.option.selected;
                f(t, function(t) { var n = t.get("name", !0);
                    e.hasOwnProperty(n) || (e[n] = !0), e[n] = !e[n] }) }, isSelected: function(t) { var e = this.option.selected; return !(e.hasOwnProperty(t) && !e[t]) && u(this._availableNames, t) >= 0 }, getOrient: function() { return "vertical" === this.get("orient") ? { index: 1, name: "vertical" } : { index: 0, name: "horizontal" } }, defaultOption: { zlevel: 0, z: 4, show: !0, orient: "horizontal", left: "center", top: 0, align: "auto", backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderRadius: 0, borderWidth: 0, padding: 5, itemGap: 10, itemWidth: 25, itemHeight: 14, inactiveColor: "#ccc", inactiveBorderColor: "#ccc", itemStyle: { borderWidth: 0 }, textStyle: { color: "#333" }, selectedMode: !0, selector: !1, selectorLabel: { show: !0, borderRadius: 10, padding: [3, 5, 3, 5], fontSize: 12, fontFamily: " sans-serif", color: "#666", borderWidth: 1, borderColor: "#666" }, emphasis: { selectorLabel: { show: !0, color: "#eee", backgroundColor: "#666" } }, selectorPosition: "auto", selectorItemGap: 7, selectorButtonGap: 10, tooltip: { show: !1 } } });
    Iu("legendToggleSelect", "legendselectchanged", x(Sp, "toggleSelected")), Iu("legendAllSelect", "legendselectall", x(Sp, "allSelect")), Iu("legendInverseSelect", "legendinverseselect", x(Sp, "inverseSelect")), Iu("legendSelect", "legendselected", x(Sp, "select")), Iu("legendUnSelect", "legendunselected", x(Sp, "unSelect"));
    var YD = x,
        jD = f,
        qD = N_,
        KD = Ou({ type: "legend.plain", newlineDisabled: !1, init: function() { this.group.add(this._contentGroup = new qD), this._backgroundEl, this.group.add(this._selectorGroup = new qD), this._isFirstRender = !0 }, getContentGroup: function() { return this._contentGroup }, getSelectorGroup: function() { return this._selectorGroup }, render: function(t, e, n) { var i = this._isFirstRender; if (this._isFirstRender = !1, this.resetInner(), t.get("show", !0)) { var r = t.get("align"),
                        a = t.get("orient");
                    r && "auto" !== r || (r = "right" === t.get("left") && "vertical" === a ? "right" : "left"); var o = t.get("selector", !0),
                        l = t.get("selectorPosition", !0);!o || l && "auto" !== l || (l = "horizontal" === a ? "end" : "start"), this.renderInner(r, t, e, n, o, a, l); var u = t.getBoxLayoutParams(),
                        h = { width: n.getWidth(), height: n.getHeight() },
                        c = t.get("padding"),
                        d = Qo(u, h, c),
                        f = this.layoutInner(t, r, d, i, o, l),
                        p = Qo(s({ width: f.width, height: f.height }, u), h, c);
                    this.group.attr("position", [p.x - f.x, p.y - f.y]), this.group.add(this._backgroundEl = Tp(f, t)) } }, resetInner: function() { this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll() }, renderInner: function(t, e, n, i, r, a, o) { var s = this.getContentGroup(),
                    l = N(),
                    u = e.get("selectedMode"),
                    h = [];
                n.eachRawSeries(function(t) {!t.get("legendHoverLink") && h.push(t.id) }), jD(e.getData(), function(r, a) { var o = r.get("name"); if (!this.newlineDisabled && ("" === o || "\n" === o)) return void s.add(new qD({ newline: !0 })); var c = n.getSeriesByName(o)[0]; if (!l.get(o))
                        if (c) { var d = c.getData(),
                                f = d.getVisual("color"),
                                p = d.getVisual("borderColor"); "function" == typeof f && (f = f(c.getDataParams(0))), "function" == typeof p && (p = p(c.getDataParams(0))); var g = d.getVisual("legendSymbol") || "roundRect",
                                v = d.getVisual("symbol"),
                                m = this._createItem(o, a, r, e, g, v, t, f, p, u);
                            m.on("click", YD(Ap, o, null, i, h)).on("mouseover", YD(Dp, c.name, null, i, h)).on("mouseout", YD(kp, c.name, null, i, h)), l.set(o, !0) } else n.eachRawSeries(function(n) { if (!l.get(o) && n.legendVisualProvider) { var s = n.legendVisualProvider; if (!s.containName(o)) return; var c = s.indexOfName(o),
                                    d = s.getItemVisual(c, "color"),
                                    f = s.getItemVisual(c, "borderColor"),
                                    p = "roundRect",
                                    g = this._createItem(o, a, r, e, p, null, t, d, f, u);
                                g.on("click", YD(Ap, null, o, i, h)).on("mouseover", YD(Dp, null, o, i, h)).on("mouseout", YD(kp, null, o, i, h)), l.set(o, !0) } }, this) }, this), r && this._createSelector(r, e, i, a, o) }, _createSelector: function(t, e, n) {
                function i(t) { var i = t.type,
                        a = new Jw({ style: { x: 0, y: 0, align: "center", verticalAlign: "middle" }, onclick: function() { n.dispatchAction({ type: "all" === i ? "legendAllSelect" : "legendInverseSelect" }) } });
                    r.add(a); var o = e.getModel("selectorLabel"),
                        s = e.getModel("emphasis.selectorLabel");
                    Za(a.style, a.hoverStyle = {}, o, s, { defaultText: t.title, isRectText: !1 }), Fa(a) } var r = this.getSelectorGroup();
                jD(t, function(t) { i(t) }) }, _createItem: function(t, e, n, i, r, a, s, l, u, h) { var c = i.get("itemWidth"),
                    d = i.get("itemHeight"),
                    f = i.get("inactiveColor"),
                    p = i.get("inactiveBorderColor"),
                    g = i.get("symbolKeepAspect"),
                    v = i.getModel("itemStyle"),
                    m = i.isSelected(t),
                    y = new qD,
                    x = n.getModel("textStyle"),
                    _ = n.get("icon"),
                    b = n.getModel("tooltip"),
                    w = b.parentModel;
                r = _ || r; var M = $h(r, 0, 0, c, d, m ? l : f, null == g ? !0 : g); if (y.add(Cp(M, r, v, u, p, m)), !_ && a && (a !== r || "none" === a)) { var S = .8 * d; "none" === a && (a = "circle"); var I = $h(a, (c - S) / 2, (d - S) / 2, S, S, m ? l : f, null == g ? !0 : g);
                    y.add(Cp(I, a, v, u, p, m)) } var T = "left" === s ? c + 5 : -5,
                    C = s,
                    A = i.get("formatter"),
                    D = t; "string" == typeof A && A ? D = A.replace("{name}", null != t ? t : "") : "function" == typeof A && (D = A(t)), y.add(new Jw({ style: Xa({}, x, { text: D, x: T, y: d / 2, textFill: m ? x.getTextColor() : f, textAlign: C, textVerticalAlign: "middle" }) })); var k = new cM({ shape: y.getBoundingRect(), invisible: !0, tooltip: b.get("show") ? o({ content: t, formatter: w.get("formatter", !0) || function() { return t }, formatterParams: { componentType: "legend", legendIndex: i.componentIndex, name: t, $vars: ["name"] } }, b.option) : null }); return y.add(k), y.eachChild(function(t) { t.silent = !0 }), k.silent = !h, this.getContentGroup().add(y), Fa(y), y.__legendDataIndex = e, y }, layoutInner: function(t, e, n, i, r, a) { var o = this.getContentGroup(),
                    s = this.getSelectorGroup();
                rS(t.get("orient"), o, t.get("itemGap"), n.width, n.height); var l = o.getBoundingRect(),
                    u = [-l.x, -l.y]; if (r) { rS("horizontal", s, t.get("selectorItemGap", !0)); var h = s.getBoundingRect(),
                        c = [-h.x, -h.y],
                        d = t.get("selectorButtonGap", !0),
                        f = t.getOrient().index,
                        p = 0 === f ? "width" : "height",
                        g = 0 === f ? "height" : "width",
                        v = 0 === f ? "y" : "x"; "end" === a ? c[f] += l[p] + d : u[f] += h[p] + d, c[1 - f] += l[g] / 2 - h[g] / 2, s.attr("position", c), o.attr("position", u); var m = { x: 0, y: 0 }; return m[p] = l[p] + d + h[p], m[g] = Math.max(l[g], h[g]), m[v] = Math.min(0, h[v] + c[1 - f]), m } return o.attr("position", u), this.group.getBoundingRect() }, remove: function() { this.getContentGroup().removeAll(), this._isFirstRender = !0 } }),
        $D = function(t) { var e = t.findComponents({ mainType: "legend" });
            e && e.length && t.filterSeries(function(t) { for (var n = 0; n < e.length; n++)
                    if (!e[n].isSelected(t.name)) return !1;
                return !0 }) };
    Mu(QI.PROCESSOR.SERIES_FILTER, $D), sS.registerSubTypeDefaulter("legend", function() { return "plain" });
    var QD = XD.extend({ type: "legend.scroll", setScrollDataIndex: function(t) { this.option.scrollDataIndex = t }, defaultOption: { scrollDataIndex: 0, pageButtonItemGap: 5, pageButtonGap: null, pageButtonPosition: "end", pageFormatter: "{current}/{total}", pageIcons: { horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"], vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"] }, pageIconColor: "#2f4554", pageIconInactiveColor: "#aaa", pageIconSize: 15, pageTextStyle: { color: "#333" }, animationDurationUpdate: 800 }, init: function(t, e, n, i) { var r = es(t);
                QD.superCall(this, "init", t, e, n, i), Pp(this, t, r) }, mergeOption: function(t, e) { QD.superCall(this, "mergeOption", t, e), Pp(this, this.option, t) } }),
        JD = N_,
        tk = ["width", "height"],
        ek = ["x", "y"],
        nk = KD.extend({ type: "legend.scroll", newlineDisabled: !0, init: function() { nk.superCall(this, "init"), this._currentIndex = 0, this.group.add(this._containerGroup = new JD), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new JD), this._showController }, resetInner: function() { nk.superCall(this, "resetInner"), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null }, renderInner: function(t, e, n, i, r, a, o) {
                function s(t, n) { var r = t + "DataIndex",
                        a = ho(e.get("pageIcons", !0)[e.getOrient().name][n], { onclick: y(l._pageGo, l, r, e, i) }, { x: -h[0] / 2, y: -h[1] / 2, width: h[0], height: h[1] });
                    a.name = t, u.add(a) } var l = this;
                nk.superCall(this, "renderInner", t, e, n, i, r, a, o); var u = this._controllerGroup,
                    h = e.get("pageIconSize", !0);
                _(h) || (h = [h, h]), s("pagePrev", 0); var c = e.getModel("pageTextStyle");
                u.add(new Jw({ name: "pageText", style: { textFill: c.getTextColor(), font: c.getFont(), textVerticalAlign: "middle", textAlign: "center" }, silent: !0 })), s("pageNext", 1) }, layoutInner: function(t, e, n, r, a, o) { var s = this.getSelectorGroup(),
                    l = t.getOrient().index,
                    u = tk[l],
                    h = ek[l],
                    c = tk[1 - l],
                    d = ek[1 - l];
                a && rS("horizontal", s, t.get("selectorItemGap", !0)); var f = t.get("selectorButtonGap", !0),
                    p = s.getBoundingRect(),
                    g = [-p.x, -p.y],
                    v = i(n);
                a && (v[u] = n[u] - p[u] - f); var m = this._layoutContentAndController(t, r, v, l, u, c, d); if (a) { if ("end" === o) g[l] += m[u] + f;
                    else { var y = p[u] + f;
                        g[l] -= y, m[h] -= y }
                    m[u] += p[u] + f, g[1 - l] += m[d] + m[c] / 2 - p[c] / 2, m[c] = Math.max(m[c], p[c]), m[d] = Math.min(m[d], p[d] + g[1 - l]), s.attr("position", g) } return m }, _layoutContentAndController: function(t, e, n, i, r, a, o) { var s = this.getContentGroup(),
                    l = this._containerGroup,
                    u = this._controllerGroup;
                rS(t.get("orient"), s, t.get("itemGap"), i ? n.width : null, i ? null : n.height), rS("horizontal", u, t.get("pageButtonItemGap", !0)); var h = s.getBoundingRect(),
                    c = u.getBoundingRect(),
                    d = this._showController = h[r] > n[r],
                    f = [-h.x, -h.y];
                e || (f[i] = s.position[i]); var p = [0, 0],
                    g = [-c.x, -c.y],
                    v = D(t.get("pageButtonGap", !0), t.get("itemGap", !0)); if (d) { var m = t.get("pageButtonPosition", !0); "end" === m ? g[i] += n[r] - c[r] : p[i] += c[r] + v }
                g[1 - i] += h[a] / 2 - c[a] / 2, s.attr("position", f), l.attr("position", p), u.attr("position", g); var y = { x: 0, y: 0 }; if (y[r] = d ? n[r] : h[r], y[a] = Math.max(h[a], c[a]), y[o] = Math.min(0, c[o] + g[1 - i]), l.__rectSize = n[r], d) { var x = { x: 0, y: 0 };
                    x[r] = Math.max(n[r] - c[r] - v, 0), x[a] = y[a], l.setClipPath(new cM({ shape: x })), l.__rectSize = x[r] } else u.eachChild(function(t) { t.attr({ invisible: !0, silent: !0 }) }); var _ = this._getPageInfo(t); return null != _.pageIndex && no(s, { position: _.contentPosition }, d ? t : !1), this._updatePageInfoView(t, _), y }, _pageGo: function(t, e, n) { var i = this._getPageInfo(e)[t];
                null != i && n.dispatchAction({ type: "legendScroll", scrollDataIndex: i, legendId: e.id }) }, _updatePageInfoView: function(t, e) { var n = this._controllerGroup;
                f(["pagePrev", "pageNext"], function(i) { var r = null != e[i + "DataIndex"],
                        a = n.childOfName(i);
                    a && (a.setStyle("fill", r ? t.get("pageIconColor", !0) : t.get("pageIconInactiveColor", !0)), a.cursor = r ? "pointer" : "default") }); var i = n.childOfName("pageText"),
                    r = t.get("pageFormatter"),
                    a = e.pageIndex,
                    o = null != a ? a + 1 : 0,
                    s = e.pageCount;
                i && r && i.setStyle("text", w(r) ? r.replace("{current}", o).replace("{total}", s) : r({ current: o, total: s })) }, _getPageInfo: function(t) {
                function e(t) { if (t) { var e = t.getBoundingRect(),
                            n = e[l] + t.position[o]; return { s: n, e: n + e[s], i: t.__legendDataIndex } } }

                function n(t, e) { return t.e >= e && t.s <= e + a } var i = t.get("scrollDataIndex", !0),
                    r = this.getContentGroup(),
                    a = this._containerGroup.__rectSize,
                    o = t.getOrient().index,
                    s = tk[o],
                    l = ek[o],
                    u = this._findTargetItemIndex(i),
                    h = r.children(),
                    c = h[u],
                    d = h.length,
                    f = d ? 1 : 0,
                    p = { contentPosition: r.position.slice(), pageCount: f, pageIndex: f - 1, pagePrevDataIndex: null, pageNextDataIndex: null }; if (!c) return p; var g = e(c);
                p.contentPosition[o] = -g.s; for (var v = u + 1, m = g, y = g, x = null; d >= v; ++v) x = e(h[v]), (!x && y.e > m.s + a || x && !n(x, m.s)) && (m = y.i > m.i ? y : x, m && (null == p.pageNextDataIndex && (p.pageNextDataIndex = m.i), ++p.pageCount)), y = x; for (var v = u - 1, m = g, y = g, x = null; v >= -1; --v) x = e(h[v]), x && n(y, x.s) || !(m.i < y.i) || (y = m, null == p.pagePrevDataIndex && (p.pagePrevDataIndex = m.i), ++p.pageCount, ++p.pageIndex), m = x; return p }, _findTargetItemIndex: function(t) { if (!this._showController) return 0; var e, n, i = this.getContentGroup(); return i.eachChild(function(i, r) { var a = i.__legendDataIndex;
                    null == n && null != a && (n = r), a === t && (e = r) }), null != e ? e : n } });
    Iu("legendScroll", "legendscroll", function(t, e) { var n = t.scrollDataIndex;
        null != n && e.eachComponent({ mainType: "legend", subType: "scroll", query: t }, function(t) { t.setScrollDataIndex(n) }) });
    var ik = function(t, e) { var n, i = [],
                r = t.seriesIndex; if (null == r || !(n = e.getSeriesByIndex(r))) return { point: [] }; var a = n.getData(),
                o = hr(a, t); if (null == o || 0 > o || _(o)) return { point: [] }; var s = a.getItemGraphicEl(o),
                l = n.coordinateSystem; if (n.getTooltipPosition) i = n.getTooltipPosition(o) || [];
            else if (l && l.dataToPoint) i = l.dataToPoint(a.getValues(p(l.dimensions, function(t) { return a.mapDimension(t) }), o, !0)) || [];
            else if (s) { var u = s.getBoundingRect().clone();
                u.applyTransform(s.transform), i = [u.x + u.width / 2, u.y + u.height / 2] } return { point: i, el: s } },
        rk = f,
        ak = x,
        ok = cr(),
        sk = function(t, e, n) { var i = t.currTrigger,
                r = [t.x, t.y],
                a = t,
                o = t.dispatchAction || y(n.dispatchAction, n),
                s = e.getComponent("axisPointer").coordSysAxesInfo; if (s) { Hp(r) && (r = ik({ seriesIndex: a.seriesIndex, dataIndex: a.dataIndex }, e).point); var l = Hp(r),
                    u = a.axesInfo,
                    h = s.axesInfo,
                    c = "leave" === i || Hp(r),
                    d = {},
                    f = {},
                    p = { list: [], map: {} },
                    g = { showPointer: ak(zp, f), showTooltip: ak(Ep, p) };
                rk(s.coordSysMap, function(t, e) { var n = l || t.containPoint(r);
                    rk(s.coordSysAxesInfo[e], function(t) { var e = t.axis,
                            i = Vp(u, t); if (!c && n && (!u || i)) { var a = i && i.value;
                            null != a || l || (a = e.pointToData(r)), null != a && Lp(t, a, g, !1, d) } }) }); var v = {}; return rk(h, function(t, e) { var n = t.linkGroup;
                    n && !f[e] && rk(n.axesInfo, function(e, i) { var r = f[i]; if (e !== t && r) { var a = r.value;
                            n.mapper && (a = t.axis.scale.parse(n.mapper(a, Fp(e), Fp(t)))), v[t.key] = a } }) }), rk(v, function(t, e) { Lp(h[e], t, g, !0, d) }), Rp(f, h, d), Bp(p, r, t, o), Np(h, o, n), d } },
        lk = (Lu({ type: "axisPointer", coordSysAxesInfo: null, defaultOption: { show: "auto", triggerOn: null, zlevel: 0, z: 50, type: "line", snap: !1, triggerTooltip: !0, value: null, status: null, link: [], animation: null, animationDurationUpdate: 200, lineStyle: { color: "#aaa", width: 1, type: "solid" }, shadowStyle: { color: "rgba(150,150,150,0.3)" }, label: { show: !0, formatter: null, precision: "auto", margin: 3, color: "#fff", padding: [5, 7, 5, 7], backgroundColor: "auto", borderColor: null, borderWidth: 0, shadowBlur: 3, shadowColor: "#aaa" }, handle: { show: !1, icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z", size: 45, margin: 50, color: "#333", shadowBlur: 3, shadowColor: "#aaa", shadowOffsetX: 0, shadowOffsetY: 2, throttle: 40 } } }), cr()),
        uk = f,
        hk = Ou({ type: "axisPointer", render: function(t, e, n) { var i = e.getComponent("tooltip"),
                    r = t.get("triggerOn") || i && i.get("triggerOn") || "mousemove|click";
                Gp("axisPointer", n, function(t, e, n) { "none" !== r && ("leave" === t || r.indexOf(t) >= 0) && n({ type: "updateAxisPointer", currTrigger: t, x: e && e.offsetX, y: e && e.offsetY }) }) }, remove: function(t, e) { jp(e.getZr(), "axisPointer"), hk.superApply(this._model, "remove", arguments) }, dispose: function(t, e) { jp("axisPointer", e), hk.superApply(this._model, "dispose", arguments) } }),
        ck = cr(),
        dk = i,
        fk = y;
    qp.prototype = {
        _group: null,
        _lastGraphicKey: null,
        _handle: null,
        _dragging: !1,
        _lastValue: null,
        _lastStatus: null,
        _payloadInfo: null,
        animationThreshold: 15,
        render: function(t, e, n, i) { var r = e.get("value"),
                a = e.get("status"); if (this._axisModel = t, this._axisPointerModel = e, this._api = n, i || this._lastValue !== r || this._lastStatus !== a) { this._lastValue = r, this._lastStatus = a; var o = this._group,
                    s = this._handle; if (!a || "hide" === a) return o && o.hide(), void(s && s.hide());
                o && o.show(), s && s.show(); var l = {};
                this.makeElOption(l, r, t, e, n); var u = l.graphicKey;
                u !== this._lastGraphicKey && this.clear(n), this._lastGraphicKey = u; var h = this._moveAnimation = this.determineAnimation(t, e); if (o) { var c = x(Kp, e, h);
                    this.updatePointerEl(o, l, c, e), this.updateLabelEl(o, l, c, e) } else o = this._group = new N_, this.createPointerEl(o, l, t, e), this.createLabelEl(o, l, t, e), n.getZr().add(o);
                tg(o, e, !0), this._renderHandle(r) } },
        remove: function(t) { this.clear(t) },
        dispose: function(t) { this.clear(t) },
        determineAnimation: function(t, e) { var n = e.get("animation"),
                i = t.axis,
                r = "category" === i.type,
                a = e.get("snap"); if (!a && !r) return !1; if ("auto" === n || null == n) { var o = this.animationThreshold; if (r && i.getBandWidth() > o) return !0; if (a) { var s = dd(t).seriesDataCount,
                        l = i.getExtent(); return Math.abs(l[0] - l[1]) / s > o } return !1 } return n === !0 },
        makeElOption: function() {},
        createPointerEl: function(t, e) { var n = e.pointer; if (n) { var i = ck(t).pointerEl = new RM[n.type](dk(e.pointer));
                t.add(i) } },
        createLabelEl: function(t, e, n, i) { if (e.label) { var r = ck(t).labelEl = new cM(dk(e.label));
                t.add(r), Qp(r, i) } },
        updatePointerEl: function(t, e, n) { var i = ck(t).pointerEl;
            i && e.pointer && (i.setStyle(e.pointer.style), n(i, { shape: e.pointer.shape })) },
        updateLabelEl: function(t, e, n, i) { var r = ck(t).labelEl;
            r && (r.setStyle(e.label.style), n(r, { shape: e.label.shape, position: e.label.position }), Qp(r, i)) },
        _renderHandle: function(t) { if (!this._dragging && this.updateHandleTransform) { var e = this._axisPointerModel,
                    n = this._api.getZr(),
                    i = this._handle,
                    r = e.getModel("handle"),
                    a = e.get("status"); if (!r.get("show") || !a || "hide" === a) return i && n.remove(i), void(this._handle = null); var o;
                this._handle || (o = !0, i = this._handle = ho(r.get("icon"), { cursor: "move", draggable: !0, onmousemove: function(t) { Jx(t.event) }, onmousedown: fk(this._onHandleDragMove, this, 0, 0), drift: fk(this._onHandleDragMove, this), ondragend: fk(this._onHandleDragEnd, this) }), n.add(i)), tg(i, e, !1); var s = ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
                i.setStyle(r.getItemStyle(null, s)); var l = r.get("size");
                _(l) || (l = [l, l]), i.attr("scale", [l[0] / 2, l[1] / 2]), xl(this, "_doDispatchAxisPointer", r.get("throttle") || 0, "fixRate"), this._moveHandleToValue(t, o) } },
        _moveHandleToValue: function(t, e) { Kp(this._axisPointerModel, !e && this._moveAnimation, this._handle, Jp(this.getHandleTransform(t, this._axisModel, this._axisPointerModel))) },
        _onHandleDragMove: function(t, e) { var n = this._handle; if (n) { this._dragging = !0; var i = this.updateHandleTransform(Jp(n), [t, e], this._axisModel, this._axisPointerModel);
                this._payloadInfo = i, n.stopAnimation(), n.attr(Jp(i)), ck(n).lastProp = null, this._doDispatchAxisPointer() } },
        _doDispatchAxisPointer: function() { var t = this._handle; if (t) { var e = this._payloadInfo,
                    n = this._axisModel;
                this._api.dispatchAction({ type: "updateAxisPointer", x: e.cursorPoint[0], y: e.cursorPoint[1], tooltipOption: e.tooltipOption, axesInfo: [{ axisDim: n.axis.dim, axisIndex: n.componentIndex }] }) } },
        _onHandleDragEnd: function() { this._dragging = !1; var t = this._handle; if (t) { var e = this._axisPointerModel.get("value");
                this._moveHandleToValue(e), this._api.dispatchAction({ type: "hideTip" }) } },
        getHandleTransform: null,
        updateHandleTransform: null,
        clear: function(t) { this._lastValue = null, this._lastStatus = null; var e = t.getZr(),
                n = this._group,
                i = this._handle;
            e && n && (this._lastGraphicKey = null, n && e.remove(n), i && e.remove(i), this._group = null, this._handle = null, this._payloadInfo = null) },
        doClear: function() {},
        buildLabel: function(t, e, n) {
            return n = n || 0, { x: t[n], y: t[1 - n], width: e[n], height: e[1 - n] }
        }
    }, qp.prototype.constructor = qp, xr(qp);
    var pk = qp.extend({ makeElOption: function(t, e, n, i, r) { var a = n.axis,
                    o = a.grid,
                    s = i.get("type"),
                    l = ug(o, a).getOtherAxis(a).getGlobalExtent(),
                    u = a.toGlobalCoord(a.dataToCoord(e, !0)); if (s && "none" !== s) { var h = eg(i),
                        c = gk[s](a, u, l);
                    c.style = h, t.graphicKey = c.type, t.pointer = c } var d = yd(o.model, n);
                og(e, t, d, n, i, r) }, getHandleTransform: function(t, e, n) { var i = yd(e.axis.grid.model, e, { labelInside: !1 }); return i.labelMargin = n.get("handle.margin"), { position: ag(e.axis, t, i), rotation: i.rotation + (i.labelDirection < 0 ? Math.PI : 0) } }, updateHandleTransform: function(t, e, n) { var i = n.axis,
                    r = i.grid,
                    a = i.getGlobalExtent(!0),
                    o = ug(r, i).getOtherAxis(i).getGlobalExtent(),
                    s = "x" === i.dim ? 0 : 1,
                    l = t.position;
                l[s] += e[s], l[s] = Math.min(a[1], l[s]), l[s] = Math.max(a[0], l[s]); var u = (o[1] + o[0]) / 2,
                    h = [u, u];
                h[s] = l[s]; var c = [{ verticalAlign: "middle" }, { align: "center" }]; return { position: l, rotation: t.rotation, cursorPoint: h, tooltipOption: c[s] } } }),
        gk = { line: function(t, e, n) { var i = sg([e, n[0]], [e, n[1]], hg(t)); return { type: "Line", subPixelOptimize: !0, shape: i } }, shadow: function(t, e, n) { var i = Math.max(1, t.getBandWidth()),
                    r = n[1] - n[0]; return { type: "Rect", shape: lg([e - i / 2, n[0]], [i, r], hg(t)) } } };
    sA.registerAxisPointerClass("CartesianAxisPointer", pk), wu(function(t) { if (t) {
            (!t.axisPointer || 0 === t.axisPointer.length) && (t.axisPointer = {}); var e = t.axisPointer.link;
            e && !_(e) && (t.axisPointer.link = [e]) } }), Mu(QI.PROCESSOR.STATISTIC, function(t, e) { t.getComponent("axisPointer").coordSysAxesInfo = ad(t, e) }), Iu({ type: "updateAxisPointer", event: "updateAxisPointer", update: ":updateAxisPointer" }, sk), Lu({ type: "tooltip", dependencies: ["axisPointer"], defaultOption: { zlevel: 0, z: 60, show: !0, showContent: !0, trigger: "item", triggerOn: "mousemove|click", alwaysShowContent: !1, displayMode: "single", renderMode: "auto", confine: !1, showDelay: 0, hideDelay: 100, transitionDuration: .4, enterable: !1, backgroundColor: "rgba(50,50,50,0.7)", borderColor: "#333", borderRadius: 4, borderWidth: 0, padding: 5, extraCssText: "", axisPointer: { type: "line", axis: "auto", animation: "auto", animationDurationUpdate: 200, animationEasingUpdate: "exponentialOut", crossStyle: { color: "#999", width: 1, type: "dashed", textStyle: {} } }, textStyle: { color: "#fff", fontSize: 14 } } });
    var vk = f,
        mk = Ho,
        yk = ["", "-webkit-", "-moz-", "-o-"],
        xk = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;";
    gg.prototype = { constructor: gg, _enterable: !0, update: function() { var t = this._container,
                e = t.currentStyle || document.defaultView.getComputedStyle(t),
                n = t.style; "absolute" !== n.position && "absolute" !== e.position && (n.position = "relative") }, show: function(t) { clearTimeout(this._hideTimeout); var e = this.el,
                n = this._styleCoord;
            e.style.cssText = xk + fg(t) + ";left:" + n[0] + "px;top:" + n[1] + "px;" + (t.get("extraCssText") || ""), e.style.display = e.innerHTML ? "block" : "none", e.style.pointerEvents = this._enterable ? "auto" : "none", this._show = !0 }, setContent: function(t) { this.el.innerHTML = null == t ? "" : t }, setEnterable: function(t) { this._enterable = t }, getSize: function() { var t = this.el; return [t.clientWidth, t.clientHeight] }, moveTo: function(t, e) { var n = this._styleCoord;
            pg(n, this._zr, this._appendToBody, t, e); var i = this.el.style;
            i.left = n[0] + "px", i.top = n[1] + "px" }, hide: function() { this.el.style.display = "none", this._show = !1 }, hideLater: function(t) {!this._show || this._inContent && this._enterable || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(y(this.hide, this), t)) : this.hide()) }, isShow: function() { return this._show }, dispose: function() { this.el.parentNode.removeChild(this.el) }, getOuterSize: function() { var t = this.el.clientWidth,
                e = this.el.clientHeight; if (document.defaultView && document.defaultView.getComputedStyle) { var n = document.defaultView.getComputedStyle(this.el);
                n && (t += parseInt(n.borderLeftWidth, 10) + parseInt(n.borderRightWidth, 10), e += parseInt(n.borderTopWidth, 10) + parseInt(n.borderBottomWidth, 10)) } return { width: t, height: e } } }, vg.prototype = { constructor: vg, _enterable: !0, update: function() {}, show: function() { this._hideTimeout && clearTimeout(this._hideTimeout), this.el.attr("show", !0), this._show = !0 }, setContent: function(t, e, n) { this.el && this._zr.remove(this.el); for (var i = {}, r = t, a = "{marker", o = "|}", s = r.indexOf(a); s >= 0;) { var l = r.indexOf(o),
                    u = r.substr(s + a.length, l - s - a.length);
                i["marker" + u] = u.indexOf("sub") > -1 ? { textWidth: 4, textHeight: 4, textBorderRadius: 2, textBackgroundColor: e[u], textOffset: [3, 0] } : { textWidth: 10, textHeight: 10, textBorderRadius: 5, textBackgroundColor: e[u] }, r = r.substr(l + 1), s = r.indexOf("{marker") }
            this.el = new Jw({ style: { rich: i, text: t, textLineHeight: 20, textBackgroundColor: n.get("backgroundColor"), textBorderRadius: n.get("borderRadius"), textFill: n.get("textStyle.color"), textPadding: n.get("padding") }, z: n.get("z") }), this._zr.add(this.el); var h = this;
            this.el.on("mouseover", function() { h._enterable && (clearTimeout(h._hideTimeout), h._show = !0), h._inContent = !0 }), this.el.on("mouseout", function() { h._enterable && h._show && h.hideLater(h._hideDelay), h._inContent = !1 }) }, setEnterable: function(t) { this._enterable = t }, getSize: function() { var t = this.el.getBoundingRect(); return [t.width, t.height] }, moveTo: function(t, e) { this.el && this.el.attr("position", [t, e]) }, hide: function() { this.el && this.el.hide(), this._show = !1 }, hideLater: function(t) {!this._show || this._inContent && this._enterable || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(y(this.hide, this), t)) : this.hide()) }, isShow: function() { return this._show }, getOuterSize: function() { var t = this.getSize(); return { width: t[0], height: t[1] } } };
    var _k = y,
        bk = f,
        wk = So,
        Mk = new cM({ shape: { x: -1, y: -1, width: 2, height: 2 } });
    Ou({ type: "tooltip", init: function(t, e) { if (!Sx.node) { var n = t.getComponent("tooltip"),
                    i = n.get("renderMode");
                this._renderMode = vr(i); var r; "html" === this._renderMode ? (r = new gg(e.getDom(), e, { appendToBody: n.get("appendToBody", !0) }), this._newLine = "<br/>") : (r = new vg(e), this._newLine = "\n"), this._tooltipContent = r } }, render: function(t, e, n) { if (!Sx.node) { this.group.removeAll(), this._tooltipModel = t, this._ecModel = e, this._api = n, this._lastDataByCoordSys = null, this._alwaysShowContent = t.get("alwaysShowContent"); var i = this._tooltipContent;
                i.update(), i.setEnterable(t.get("enterable")), this._initGlobalListener(), this._keepShow() } }, _initGlobalListener: function() { var t = this._tooltipModel,
                e = t.get("triggerOn");
            Gp("itemTooltip", this._api, _k(function(t, n, i) { "none" !== e && (e.indexOf(t) >= 0 ? this._tryShow(n, i) : "leave" === t && this._hide(i)) }, this)) }, _keepShow: function() { var t = this._tooltipModel,
                e = this._ecModel,
                n = this._api; if (null != this._lastX && null != this._lastY && "none" !== t.get("triggerOn")) { var i = this;
                clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {!n.isDisposed() && i.manuallyShowTip(t, e, n, { x: i._lastX, y: i._lastY }) }) } }, manuallyShowTip: function(t, e, n, i) { if (i.from !== this.uid && !Sx.node) { var r = yg(i, n);
                this._ticket = ""; var a = i.dataByCoordSys; if (i.tooltip && null != i.x && null != i.y) { var o = Mk;
                    o.position = [i.x, i.y], o.update(), o.tooltip = i.tooltip, this._tryShow({ offsetX: i.x, offsetY: i.y, target: o }, r) } else if (a) this._tryShow({ offsetX: i.x, offsetY: i.y, position: i.position, dataByCoordSys: i.dataByCoordSys, tooltipOption: i.tooltipOption }, r);
                else if (null != i.seriesIndex) { if (this._manuallyAxisShowTip(t, e, n, i)) return; var s = ik(i, e),
                        l = s.point[0],
                        u = s.point[1];
                    null != l && null != u && this._tryShow({ offsetX: l, offsetY: u, position: i.position, target: s.el }, r) } else null != i.x && null != i.y && (n.dispatchAction({ type: "updateAxisPointer", x: i.x, y: i.y }), this._tryShow({ offsetX: i.x, offsetY: i.y, position: i.position, target: n.getZr().findHover(i.x, i.y).target }, r)) } }, manuallyHideTip: function(t, e, n, i) { var r = this._tooltipContent;!this._alwaysShowContent && this._tooltipModel && r.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = null, i.from !== this.uid && this._hide(yg(i, n)) }, _manuallyAxisShowTip: function(t, e, n, i) { var r = i.seriesIndex,
                a = i.dataIndex,
                o = e.getComponent("axisPointer").coordSysAxesInfo; if (null != r && null != a && null != o) { var s = e.getSeriesByIndex(r); if (s) { var l = s.getData(),
                        t = mg([l.getItemModel(a), s, (s.coordinateSystem || {}).model, t]); if ("axis" === t.get("trigger")) return n.dispatchAction({ type: "updateAxisPointer", seriesIndex: r, dataIndex: a, position: i.position }), !0 } } }, _tryShow: function(t, e) { var n = t.target,
                i = this._tooltipModel; if (i) { this._lastX = t.offsetX, this._lastY = t.offsetY; var r = t.dataByCoordSys;
                r && r.length ? this._showAxisTooltip(r, t) : n && null != n.dataIndex ? (this._lastDataByCoordSys = null, this._showSeriesItemTooltip(t, n, e)) : n && n.tooltip ? (this._lastDataByCoordSys = null, this._showComponentItemTooltip(t, n, e)) : (this._lastDataByCoordSys = null, this._hide(e)) } }, _showOrMove: function(t, e) { var n = t.get("showDelay");
            e = y(e, this), clearTimeout(this._showTimout), n > 0 ? this._showTimout = setTimeout(e, n) : e() }, _showAxisTooltip: function(t, e) { var n = this._ecModel,
                i = this._tooltipModel,
                a = [e.offsetX, e.offsetY],
                o = [],
                s = [],
                l = mg([e.tooltipOption, i]),
                u = this._renderMode,
                h = this._newLine,
                c = {};
            bk(t, function(t) { bk(t.dataByAxis, function(t) { var e = n.getComponent(t.axisDim + "Axis", t.axisIndex),
                        i = t.value,
                        a = []; if (e && null != i) { var l = rg(i, e.axis, n, t.seriesDataIndices, t.valueLabelOpt);
                        f(t.seriesDataIndices, function(o) { var h = n.getSeriesByIndex(o.seriesIndex),
                                d = o.dataIndexInside,
                                f = h && h.getDataParams(d); if (f.axisDim = t.axisDim, f.axisIndex = t.axisIndex, f.axisType = t.axisType, f.axisId = t.axisId, f.axisValue = Uh(e.axis, i), f.axisValueLabel = l, f) { s.push(f); var p, g = h.formatTooltip(d, !0, null, u); if (M(g)) { p = g.html; var v = g.markers;
                                    r(c, v) } else p = g;
                                a.push(p) } }); var d = l;
                        o.push("html" !== u ? a.join(h) : (d ? Go(d) + h : "") + a.join(h)) } }) }, this), o.reverse(), o = o.join(this._newLine + this._newLine); var d = e.position;
            this._showOrMove(l, function() { this._updateContentNotChangedOnAxis(t) ? this._updatePosition(l, d, a[0], a[1], this._tooltipContent, s) : this._showTooltipContent(l, o, s, Math.random(), a[0], a[1], d, void 0, c) }) }, _showSeriesItemTooltip: function(t, e, n) { var i = this._ecModel,
                r = e.seriesIndex,
                a = i.getSeriesByIndex(r),
                o = e.dataModel || a,
                s = e.dataIndex,
                l = e.dataType,
                u = o.getData(),
                h = mg([u.getItemModel(s), o, a && (a.coordinateSystem || {}).model, this._tooltipModel]),
                c = h.get("trigger"); if (null == c || "item" === c) { var d, f, p = o.getDataParams(s, l),
                    g = o.formatTooltip(s, !1, l, this._renderMode);
                M(g) ? (d = g.html, f = g.markers) : (d = g, f = null); var v = "item_" + o.name + "_" + s;
                this._showOrMove(h, function() { this._showTooltipContent(h, d, p, v, t.offsetX, t.offsetY, t.position, t.target, f) }), n({ type: "showTip", dataIndexInside: s, dataIndex: u.getRawIndex(s), seriesIndex: r, from: this.uid }) } }, _showComponentItemTooltip: function(t, e, n) { var i = e.tooltip; if ("string" == typeof i) { var r = i;
                i = { content: r, formatter: r } } var a = new vo(i, this._tooltipModel, this._ecModel),
                o = a.get("content"),
                s = Math.random();
            this._showOrMove(a, function() { this._showTooltipContent(a, o, a.get("formatterParams") || {}, s, t.offsetX, t.offsetY, t.position, e) }), n({ type: "showTip", from: this.uid }) }, _showTooltipContent: function(t, e, n, i, r, a, o, s, l) { if (this._ticket = "", t.get("showContent") && t.get("show")) { var u = this._tooltipContent,
                    h = t.get("formatter");
                o = o || t.get("position"); var c = e; if (h && "string" == typeof h) c = Wo(h, n, !0);
                else if ("function" == typeof h) { var d = _k(function(e, i) { e === this._ticket && (u.setContent(i, l, t), this._updatePosition(t, o, r, a, u, n, s)) }, this);
                    this._ticket = i, c = h(n, i, d) }
                u.setContent(c, l, t), u.show(t), this._updatePosition(t, o, r, a, u, n, s) } }, _updatePosition: function(t, e, n, i, r, a, o) { var s = this._api.getWidth(),
                l = this._api.getHeight();
            e = e || t.get("position"); var u = r.getSize(),
                h = t.get("align"),
                c = t.get("verticalAlign"),
                d = o && o.getBoundingRect().clone(); if (o && d.applyTransform(o.transform), "function" == typeof e && (e = e([n, i], a, r.el, d, { viewSize: [s, l], contentSize: u.slice() })), _(e)) n = wk(e[0], s), i = wk(e[1], l);
            else if (M(e)) { e.width = u[0], e.height = u[1]; var f = Qo(e, { width: s, height: l });
                n = f.x, i = f.y, h = null, c = null } else if ("string" == typeof e && o) { var p = bg(e, d, u);
                n = p[0], i = p[1] } else { var p = xg(n, i, r, s, l, h ? null : 20, c ? null : 20);
                n = p[0], i = p[1] } if (h && (n -= wg(h) ? u[0] / 2 : "right" === h ? u[0] : 0), c && (i -= wg(c) ? u[1] / 2 : "bottom" === c ? u[1] : 0), t.get("confine")) { var p = _g(n, i, r, s, l);
                n = p[0], i = p[1] }
            r.moveTo(n, i) }, _updateContentNotChangedOnAxis: function(t) { var e = this._lastDataByCoordSys,
                n = !!e && e.length === t.length; return n && bk(e, function(e, i) { var r = e.dataByAxis || {},
                    a = t[i] || {},
                    o = a.dataByAxis || [];
                n &= r.length === o.length, n && bk(r, function(t, e) { var i = o[e] || {},
                        r = t.seriesDataIndices || [],
                        a = i.seriesDataIndices || [];
                    n &= t.value === i.value && t.axisType === i.axisType && t.axisId === i.axisId && r.length === a.length, n && bk(r, function(t, e) { var i = a[e];
                        n &= t.seriesIndex === i.seriesIndex && t.dataIndex === i.dataIndex }) }) }), this._lastDataByCoordSys = t, !!n }, _hide: function(t) { this._lastDataByCoordSys = null, t({ type: "hideTip", from: this.uid }) }, dispose: function(t, e) { Sx.node || (this._tooltipContent.dispose(), jp("itemTooltip", e)) } }), Iu({ type: "showTip", event: "showTip", update: "tooltip:manuallyShowTip" }, function() {}), Iu({ type: "hideTip", event: "hideTip", update: "tooltip:manuallyHideTip" }, function() {});
    var Sk = Fo,
        Ik = Go,
        Tk = Lu({ type: "marker", dependencies: ["series", "grid", "polar", "geo"], init: function(t, e, n) { this.mergeDefaultAndTheme(t, n), this._mergeOption(t, n, !1, !0) }, isAnimationEnabled: function() { if (Sx.node) return !1; var t = this.__hostSeries; return this.getShallow("animation") && t && t.isAnimationEnabled() }, mergeOption: function(t, e) { this._mergeOption(t, e, !1, !1) }, _mergeOption: function(t, e, n, i) { var r = this.constructor,
                    a = this.mainType + "Model";
                n || e.eachSeries(function(t) { var n = t.get(this.mainType, !0),
                        s = t[a]; return n && n.data ? (s ? s._mergeOption(n, e, !0) : (i && Mg(n), f(n.data, function(t) { t instanceof Array ? (Mg(t[0]), Mg(t[1])) : Mg(t) }), s = new r(n, this, e), o(s, { mainType: this.mainType, seriesIndex: t.seriesIndex, name: t.name, createdBySelf: !0 }), s.__hostSeries = t), void(t[a] = s)) : void(t[a] = null) }, this) }, formatTooltip: function(t) { var e = this.getData(),
                    n = this.getRawValue(t),
                    i = _(n) ? p(n, Sk).join(", ") : Sk(n),
                    r = e.getName(t),
                    a = Ik(this.name); return (null != n || r) && (a += "<br />"), r && (a += Ik(r), null != n && (a += " : ")), null != n && (a += Ik(i)), a }, getData: function() { return this._data }, setData: function(t) { this._data = t } });
    c(Tk, ZS), Tk.extend({ type: "markPoint", defaultOption: { zlevel: 0, z: 5, symbol: "pin", symbolSize: 50, tooltip: { trigger: "item" }, label: { show: !0, position: "inside" }, itemStyle: { borderWidth: 2 }, emphasis: { label: { show: !0 } } } });
    var Ck = u,
        Ak = x,
        Dk = { min: Ak(Tg, "min"), max: Ak(Tg, "max"), average: Ak(Tg, "average") },
        kk = Ou({ type: "marker", init: function() { this.markerGroupMap = N() }, render: function(t, e, n) { var i = this.markerGroupMap;
                i.each(function(t) { t.__keep = !1 }); var r = this.type + "Model";
                e.eachSeries(function(t) { var i = t[r];
                    i && this.renderSeries(t, i, e, n) }, this), i.each(function(t) {!t.__keep && this.group.remove(t.group) }, this) }, renderSeries: function() {} });
    kk.extend({ type: "markPoint", updateTransform: function(t, e, n) { e.eachSeries(function(t) { var e = t.markPointModel;
                e && (Og(e.getData(), t, n), this.markerGroupMap.get(t.id).updateLayout(e)) }, this) }, renderSeries: function(t, e, n, i) { var r = t.coordinateSystem,
                a = t.id,
                o = t.getData(),
                s = this.markerGroupMap,
                l = s.get(a) || s.set(a, new Id),
                u = zg(r, t, e);
            e.setData(u), Og(e.getData(), t, i), u.each(function(t) { var n = u.getItemModel(t),
                    i = n.getShallow("symbol"),
                    r = n.getShallow("symbolSize"),
                    a = b(i),
                    s = b(r); if (a || s) { var l = e.getRawValue(t),
                        h = e.getDataParams(t);
                    a && (i = i(l, h)), s && (r = r(l, h)) }
                u.setItemVisual(t, { symbol: i, symbolSize: r, color: n.get("itemStyle.color") || o.getVisual("color") }) }), l.updateData(u), this.group.add(l.group), u.eachItemGraphicEl(function(t) { t.traverse(function(t) { t.dataModel = e }) }), l.__keep = !0, l.group.silent = e.get("silent") || t.get("silent") } }), wu(function(t) { t.markPoint = t.markPoint || {} }), Tk.extend({ type: "markLine", defaultOption: { zlevel: 0, z: 5, symbol: ["circle", "arrow"], symbolSize: [8, 16], precision: 2, tooltip: { trigger: "item" }, label: { show: !0, position: "end", distance: 5 }, lineStyle: { type: "dashed" }, emphasis: { label: { show: !0 }, lineStyle: { width: 3 } }, animationEasing: "linear" } });
    var Pk = function(t, e, n, a) { var s = t.getData(),
            l = a.type; if (!_(a) && ("min" === l || "max" === l || "average" === l || "median" === l || null != a.xAxis || null != a.yAxis)) { var u, h; if (null != a.yAxis || null != a.xAxis) u = e.getAxis(null != a.yAxis ? "y" : "x"), h = A(a.yAxis, a.xAxis);
            else { var c = Ag(a, s, e, t);
                u = c.valueAxis; var d = ph(s, c.valueDataDim);
                h = Lg(s, d, l) } var f = "x" === u.dim ? 0 : 1,
                p = 1 - f,
                g = i(a),
                v = {};
            g.type = null, g.coord = [], v.coord = [], g.coord[p] = -1 / 0, v.coord[p] = 1 / 0; var m = n.get("precision");
            m >= 0 && "number" == typeof h && (h = +h.toFixed(Math.min(m, 20))), g.coord[f] = v.coord[f] = h, a = [g, v, { type: l, valueIndex: a.valueIndex, value: h }] } return a = [Cg(t, a[0]), Cg(t, a[1]), o({}, a[2])], a[2].type = a[2].type || "", r(a[2], a[0]), r(a[2], a[1]), a };
    kk.extend({ type: "markLine", updateTransform: function(t, e, n) { e.eachSeries(function(t) { var e = t.markLineModel; if (e) { var i = e.getData(),
                        r = e.__from,
                        a = e.__to;
                    r.each(function(e) { Ng(r, e, !0, t, n), Ng(a, e, !1, t, n) }), i.each(function(t) { i.setItemLayout(t, [r.getItemLayout(t), a.getItemLayout(t)]) }), this.markerGroupMap.get(t.id).updateLayout() } }, this) }, renderSeries: function(t, e, n, i) {
            function r(e, n, r) { var a = e.getItemModel(n);
                Ng(e, n, r, t, i), e.setItemVisual(n, { symbolSize: a.get("symbolSize") || g[r ? 0 : 1], symbol: a.get("symbol", !0) || p[r ? 0 : 1], color: a.get("itemStyle.color") || s.getVisual("color") }) } var a = t.coordinateSystem,
                o = t.id,
                s = t.getData(),
                l = this.markerGroupMap,
                u = l.get(o) || l.set(o, new xf);
            this.group.add(u.group); var h = Vg(a, t, e),
                c = h.from,
                d = h.to,
                f = h.line;
            e.__from = c, e.__to = d, e.setData(f); var p = e.get("symbol"),
                g = e.get("symbolSize");
            _(p) || (p = [p, p]), "number" == typeof g && (g = [g, g]), h.from.each(function(t) { r(c, t, !0), r(d, t, !1) }), f.each(function(t) { var e = f.getItemModel(t).get("lineStyle.color");
                f.setItemVisual(t, { color: e || c.getItemVisual(t, "color") }), f.setItemLayout(t, [c.getItemLayout(t), d.getItemLayout(t)]), f.setItemVisual(t, { fromSymbolSize: c.getItemVisual(t, "symbolSize"), fromSymbol: c.getItemVisual(t, "symbol"), toSymbolSize: d.getItemVisual(t, "symbolSize"), toSymbol: d.getItemVisual(t, "symbol") }) }), u.updateData(f), h.line.eachItemGraphicEl(function(t) { t.traverse(function(t) { t.dataModel = e }) }), u.__keep = !0, u.group.silent = e.get("silent") || t.get("silent") } }), wu(function(t) { t.markLine = t.markLine || {} }), Tk.extend({ type: "markArea", defaultOption: { zlevel: 0, z: 1, tooltip: { trigger: "item" }, animation: !1, label: { show: !0, position: "top" }, itemStyle: { borderWidth: 0 }, emphasis: { label: { show: !0, position: "top" } } } });
    var Lk = function(t, e, n, i) { var r = Cg(t, i[0]),
                o = Cg(t, i[1]),
                s = A,
                l = r.coord,
                u = o.coord;
            l[0] = s(l[0], -1 / 0), l[1] = s(l[1], -1 / 0), u[0] = s(u[0], 1 / 0), u[1] = s(u[1], 1 / 0); var h = a([{}, r, o]); return h.coord = [r.coord, o.coord], h.x0 = r.x, h.y0 = r.y, h.x1 = o.x, h.y1 = o.y, h },
        Ok = [
            ["x0", "y0"],
            ["x1", "y0"],
            ["x1", "y1"],
            ["x0", "y1"]
        ];
    kk.extend({ type: "markArea", updateTransform: function(t, e, n) { e.eachSeries(function(t) { var e = t.markAreaModel; if (e) { var i = e.getData();
                    i.each(function(e) { var r = p(Ok, function(r) { return Wg(i, e, r, t, n) });
                        i.setItemLayout(e, r); var a = i.getItemGraphicEl(e);
                        a.setShape("points", r) }) } }, this) }, renderSeries: function(t, e, n, i) { var r = t.coordinateSystem,
                a = t.id,
                o = t.getData(),
                l = this.markerGroupMap,
                u = l.get(a) || l.set(a, { group: new N_ });
            this.group.add(u.group), u.__keep = !0; var h = Zg(r, t, e);
            e.setData(h), h.each(function(e) { h.setItemLayout(e, p(Ok, function(n) { return Wg(h, e, n, t, i) })), h.setItemVisual(e, { color: o.getVisual("color") }) }), h.diff(u.__data).add(function(t) { var e = new sM({ shape: { points: h.getItemLayout(t) } });
                h.setItemGraphicEl(t, e), u.group.add(e) }).update(function(t, n) { var i = u.__data.getItemGraphicEl(n);
                no(i, { shape: { points: h.getItemLayout(t) } }, e, t), u.group.add(i), h.setItemGraphicEl(t, i) }).remove(function(t) { var e = u.__data.getItemGraphicEl(t);
                u.group.remove(e) }).execute(), h.eachItemGraphicEl(function(t, n) { var i = h.getItemModel(n),
                    r = i.getModel("label"),
                    a = i.getModel("emphasis.label"),
                    o = h.getItemVisual(n, "color");
                t.useStyle(s(i.getModel("itemStyle").getItemStyle(), { fill: un(o, .4), stroke: o })), t.hoverStyle = i.getModel("emphasis.itemStyle").getItemStyle(), Za(t.style, t.hoverStyle, r, a, { labelFetcher: e, labelDataIndex: n, defaultText: h.getName(n) || "", isRectText: !0, autoColor: o }), Fa(t, {}), t.dataModel = e }), u.__data = h, u.group.silent = e.get("silent") || t.get("silent") } }), wu(function(t) { t.markArea = t.markArea || {} });
    var zk = function(t) { var e = t && t.timeline;
        _(e) || (e = e ? [e] : []), f(e, function(t) { t && Ug(t) }) };
    sS.registerSubTypeDefaulter("timeline", function() { return "slider" }), Iu({ type: "timelineChange", event: "timelineChanged", update: "prepareAndUpdate" }, function(t, e) { var n = e.getComponent("timeline"); return n && null != t.currentIndex && (n.setCurrentIndex(t.currentIndex), !n.get("loop", !0) && n.isIndexMax() && n.setPlayState(!1)), e.resetOption("timeline"), s({ currentIndex: n.option.currentIndex }, t) }), Iu({ type: "timelinePlayChange", event: "timelinePlayChanged", update: "update" }, function(t, e) { var n = e.getComponent("timeline");
        n && null != t.playState && n.setPlayState(t.playState) });
    var Ek = sS.extend({ type: "timeline", layoutMode: "box", defaultOption: { zlevel: 0, z: 4, show: !0, axisType: "time", realtime: !0, left: "20%", top: null, right: "20%", bottom: 0, width: null, height: 40, padding: 5, controlPosition: "left", autoPlay: !1, rewind: !1, loop: !0, playInterval: 2e3, currentIndex: 0, itemStyle: {}, label: { color: "#000" }, data: [] }, init: function(t, e, n) { this._data, this._names, this.mergeDefaultAndTheme(t, n), this._initData() }, mergeOption: function() { Ek.superApply(this, "mergeOption", arguments), this._initData() }, setCurrentIndex: function(t) { null == t && (t = this.option.currentIndex); var e = this._data.count();
                this.option.loop ? t = (t % e + e) % e : (t >= e && (t = e - 1), 0 > t && (t = 0)), this.option.currentIndex = t }, getCurrentIndex: function() { return this.option.currentIndex }, isIndexMax: function() { return this.getCurrentIndex() >= this._data.count() - 1 }, setPlayState: function(t) { this.option.autoPlay = !!t }, getPlayState: function() { return !!this.option.autoPlay }, _initData: function() { var t = this.option,
                    e = t.data || [],
                    n = t.axisType,
                    r = this._names = []; if ("category" === n) { var a = [];
                    f(e, function(t, e) { var n, o = ir(t);
                        M(t) ? (n = i(t), n.value = e) : n = e, a.push(n), w(o) || null != o && !isNaN(o) || (o = ""), r.push(o + "") }), e = a } var o = { category: "ordinal", time: "time" }[n] || "number",
                    s = this._data = new PT([{ name: "value", type: o }], this);
                s.initData(e, r) }, getData: function() { return this._data }, getCategories: function() { return "category" === this.get("axisType") ? this._names.slice() : void 0 } }),
        Rk = Ek.extend({ type: "timeline.slider", defaultOption: { backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderWidth: 0, orient: "horizontal", inverse: !1, tooltip: { trigger: "item" }, symbol: "emptyCircle", symbolSize: 10, lineStyle: { show: !0, width: 2, color: "#304654" }, label: { position: "auto", show: !0, interval: "auto", rotate: 0, color: "#304654" }, itemStyle: { color: "#304654", borderWidth: 1 }, checkpointStyle: { symbol: "circle", symbolSize: 13, color: "#c23531", borderWidth: 5, borderColor: "rgba(194,53,49, 0.5)", animation: !0, animationDuration: 300, animationEasing: "quinticInOut" }, controlStyle: { show: !0, showPlayBtn: !0, showPrevBtn: !0, showNextBtn: !0, itemSize: 22, itemGap: 12, position: "left", playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z", stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z", nextIcon: "path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z", prevIcon: "path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z", color: "#304654", borderColor: "#304654", borderWidth: 1 }, emphasis: { label: { show: !0, color: "#c23531" }, itemStyle: { color: "#c23531" }, controlStyle: { color: "#c23531", borderColor: "#c23531", borderWidth: 2 } }, data: [] } });
    c(Rk, ZS);
    var Bk = qS.extend({ type: "timeline" }),
        Nk = function(t, e, n, i) { TC.call(this, t, e, n), this.type = i || "value", this.model = null };
    Nk.prototype = { constructor: Nk, getLabelModel: function() { return this.model.getModel("label") }, isHorizontal: function() { return "horizontal" === this.model.get("orient") } }, h(Nk, TC);
    var Vk = y,
        Fk = f,
        Hk = Math.PI;
    Bk.extend({ type: "timeline.slider", init: function(t, e) { this.api = e, this._axis, this._viewRect, this._timer, this._currentPointer, this._mainGroup, this._labelGroup }, render: function(t, e, n) { if (this.model = t, this.api = n, this.ecModel = e, this.group.removeAll(), t.get("show", !0)) { var i = this._layout(t, n),
                    r = this._createGroup("mainGroup"),
                    a = this._createGroup("labelGroup"),
                    o = this._axis = this._createAxis(i, t);
                t.formatTooltip = function(t) { return Go(o.scale.getLabel(t)) }, Fk(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(e) { this["_render" + e](i, r, o, t) }, this), this._renderAxisLabel(i, a, o, t), this._position(i, t) }
            this._doPlayStop() }, remove: function() { this._clearTimer(), this.group.removeAll() }, dispose: function() { this._clearTimer() }, _layout: function(t, e) { var n = t.get("label.position"),
                i = t.get("orient"),
                r = jg(t, e);
            null == n || "auto" === n ? n = "horizontal" === i ? r.y + r.height / 2 < e.getHeight() / 2 ? "-" : "+" : r.x + r.width / 2 < e.getWidth() / 2 ? "+" : "-" : isNaN(n) && (n = { horizontal: { top: "-", bottom: "+" }, vertical: { left: "-", right: "+" } }[i][n]); var a = { horizontal: "center", vertical: n >= 0 || "+" === n ? "left" : "right" },
                o = { horizontal: n >= 0 || "+" === n ? "top" : "bottom", vertical: "middle" },
                s = { horizontal: 0, vertical: Hk / 2 },
                l = "vertical" === i ? r.height : r.width,
                u = t.getModel("controlStyle"),
                h = u.get("show", !0),
                c = h ? u.get("itemSize") : 0,
                d = h ? u.get("itemGap") : 0,
                f = c + d,
                p = t.get("label.rotate") || 0;
            p = p * Hk / 180; var g, v, m, y, x = u.get("position", !0),
                _ = h && u.get("showPlayBtn", !0),
                b = h && u.get("showPrevBtn", !0),
                w = h && u.get("showNextBtn", !0),
                M = 0,
                S = l; return "left" === x || "bottom" === x ? (_ && (g = [0, 0], M += f), b && (v = [M, 0], M += f), w && (m = [S - c, 0], S -= f)) : (_ && (g = [S - c, 0], S -= f), b && (v = [0, 0], M += f), w && (m = [S - c, 0], S -= f)), y = [M, S], t.get("inverse") && y.reverse(), { viewRect: r, mainLength: l, orient: i, rotation: s[i], labelRotation: p, labelPosOpt: n, labelAlign: t.get("label.align") || a[i], labelBaseline: t.get("label.verticalAlign") || t.get("label.baseline") || o[i], playPosition: g, prevBtnPosition: v, nextBtnPosition: m, axisExtent: y, controlSize: c, controlGap: d } }, _position: function(t) {
            function e(t) { var e = t.position;
                t.origin = [h[0][0] - e[0], h[1][0] - e[1]] }

            function n(t) { return [
                    [t.x, t.x + t.width],
                    [t.y, t.y + t.height]
                ] }

            function i(t, e, n, i, r) { t[i] += n[i][r] - e[i][r] } var r = this._mainGroup,
                a = this._labelGroup,
                o = t.viewRect; if ("vertical" === t.orient) { var s = Oe(),
                    l = o.x,
                    u = o.y + o.height;
                Be(s, s, [-l, -u]), Ne(s, s, -Hk / 2), Be(s, s, [l, u]), o = o.clone(), o.applyTransform(s) } var h = n(o),
                c = n(r.getBoundingRect()),
                d = n(a.getBoundingRect()),
                f = r.position,
                p = a.position;
            p[0] = f[0] = h[0][0]; var g = t.labelPosOpt; if (isNaN(g)) { var v = "+" === g ? 0 : 1;
                i(f, c, h, 1, v), i(p, d, h, 1, 1 - v) } else { var v = g >= 0 ? 0 : 1;
                i(f, c, h, 1, v), p[1] = f[1] + g }
            r.attr("position", f), a.attr("position", p), r.rotation = a.rotation = t.rotation, e(r), e(a) }, _createAxis: function(t, e) { var n = e.getData(),
                i = e.get("axisType"),
                r = Gh(e, i);
            r.getTicks = function() { return n.mapArray(["value"], function(t) { return t }) }; var a = n.getDataExtent("value");
            r.setExtent(a[0], a[1]), r.niceTicks(); var o = new Nk("value", r, t.axisExtent, i); return o.model = e, o }, _createGroup: function(t) { var e = this["_" + t] = new N_; return this.group.add(e), e }, _renderAxisLine: function(t, e, n, i) { var r = n.getExtent();
            i.get("lineStyle.show") && e.add(new fM({ shape: { x1: r[0], y1: 0, x2: r[1], y2: 0 }, style: o({ lineCap: "round" }, i.getModel("lineStyle").getLineStyle()), silent: !0, z2: 1 })) }, _renderAxisTick: function(t, e, n, i) { var r = i.getData(),
                a = n.scale.getTicks();
            Fk(a, function(t) { var a = n.dataToCoord(t),
                    o = r.getItemModel(t),
                    s = o.getModel("itemStyle"),
                    l = o.getModel("emphasis.itemStyle"),
                    u = { position: [a, 0], onclick: Vk(this._changeTimeline, this, t) },
                    h = Kg(o, s, e, u);
                Fa(h, l.getItemStyle()), o.get("tooltip") ? (h.dataIndex = t, h.dataModel = i) : h.dataIndex = h.dataModel = null }, this) }, _renderAxisLabel: function(t, e, n, i) { var r = n.getLabelModel(); if (r.get("show")) { var a = i.getData(),
                    o = n.getViewLabels();
                Fk(o, function(i) { var r = i.tickValue,
                        o = a.getItemModel(r),
                        s = o.getModel("label"),
                        l = o.getModel("emphasis.label"),
                        u = n.dataToCoord(i.tickValue),
                        h = new Jw({ position: [u, 0], rotation: t.labelRotation - t.rotation, onclick: Vk(this._changeTimeline, this, r), silent: !1 });
                    Xa(h.style, s, { text: i.formattedLabel, textAlign: t.labelAlign, textVerticalAlign: t.labelBaseline }), e.add(h), Fa(h, Xa({}, l)) }, this) } }, _renderControl: function(t, e, n, i) {
            function r(t, n, r, h) { if (t) { var c = { position: t, origin: [a / 2, 0], rotation: h ? -o : 0, rectHover: !0, style: s, onclick: r },
                        d = qg(i, n, u, c);
                    e.add(d), Fa(d, l) } } var a = t.controlSize,
                o = t.rotation,
                s = i.getModel("controlStyle").getItemStyle(),
                l = i.getModel("emphasis.controlStyle").getItemStyle(),
                u = [0, -a / 2, a, a],
                h = i.getPlayState(),
                c = i.get("inverse", !0);
            r(t.nextBtnPosition, "controlStyle.nextIcon", Vk(this._changeTimeline, this, c ? "-" : "+")), r(t.prevBtnPosition, "controlStyle.prevIcon", Vk(this._changeTimeline, this, c ? "+" : "-")), r(t.playPosition, "controlStyle." + (h ? "stopIcon" : "playIcon"), Vk(this._handlePlayClick, this, !h), !0) }, _renderCurrentPointer: function(t, e, n, i) { var r = i.getData(),
                a = i.getCurrentIndex(),
                o = r.getItemModel(a).getModel("checkpointStyle"),
                s = this,
                l = { onCreate: function(t) { t.draggable = !0, t.drift = Vk(s._handlePointerDrag, s), t.ondragend = Vk(s._handlePointerDragend, s), $g(t, a, n, i, !0) }, onUpdate: function(t) { $g(t, a, n, i) } };
            this._currentPointer = Kg(o, o, this._mainGroup, {}, this._currentPointer, l) }, _handlePlayClick: function(t) { this._clearTimer(), this.api.dispatchAction({ type: "timelinePlayChange", playState: t, from: this.uid }) }, _handlePointerDrag: function(t, e, n) { this._clearTimer(), this._pointerChangeTimeline([n.offsetX, n.offsetY]) }, _handlePointerDragend: function(t) { this._pointerChangeTimeline([t.offsetX, t.offsetY], !0) }, _pointerChangeTimeline: function(t, e) { var n = this._toAxisCoord(t)[0],
                i = this._axis,
                r = To(i.getExtent().slice());
            n > r[1] && (n = r[1]), n < r[0] && (n = r[0]), this._currentPointer.position[0] = n, this._currentPointer.dirty(); var a = this._findNearestTick(n),
                o = this.model;
            (e || a !== o.getCurrentIndex() && o.get("realtime")) && this._changeTimeline(a) }, _doPlayStop: function() {
            function t() { var t = this.model;
                this._changeTimeline(t.getCurrentIndex() + (t.get("rewind", !0) ? -1 : 1)) }
            this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(Vk(t, this), this.model.get("playInterval"))) }, _toAxisCoord: function(t) { var e = this._mainGroup.getLocalTransform(); return ao(t, e, !0) }, _findNearestTick: function(t) { var e, n = this.model.getData(),
                i = 1 / 0,
                r = this._axis; return n.each(["value"], function(n, a) { var o = r.dataToCoord(n),
                    s = Math.abs(o - t);
                i > s && (i = s, e = a) }), e }, _clearTimer: function() { this._timer && (clearTimeout(this._timer), this._timer = null) }, _changeTimeline: function(t) { var e = this.model.getCurrentIndex(); "+" === t ? t = e + 1 : "-" === t && (t = e - 1), this.api.dispatchAction({ type: "timelineChange", currentIndex: t, from: this.uid }) } }), wu(zk), sS.registerSubTypeDefaulter("dataZoom", function() { return "slider" });
    var Gk = ["x", "y", "z", "radius", "angle", "single"],
        Wk = ["cartesian2d", "polar", "singleAxis"],
        Zk = Jg(Gk, ["axisIndex", "axis", "index", "id"]),
        Uk = function(t, e, n, i, r, a) { t = t || 0; var o = n[1] - n[0]; if (null != r && (r = nv(r, [0, o])), null != a && (a = Math.max(a, null != r ? r : 0)), "all" === i) { var s = Math.abs(e[1] - e[0]);
                s = nv(s, [0, o]), r = a = nv(s, [r, a]), i = 0 }
            e[0] = nv(e[0], n), e[1] = nv(e[1], n); var l = ev(e, i);
            e[i] += t; var u = r || 0,
                h = n.slice();
            l.sign < 0 ? h[0] += u : h[1] -= u, e[i] = nv(e[i], h); var c = ev(e, i);
            null != r && (c.sign !== l.sign || c.span < r) && (e[1 - i] = e[i] + l.sign * r); var c = ev(e, i); return null != a && c.span > a && (e[1 - i] = e[i] + c.sign * a), e },
        Xk = f,
        Yk = To,
        jk = function(t, e, n, i) { this._dimName = t, this._axisIndex = e, this._valueWindow, this._percentWindow, this._dataExtent, this._minMaxSpan, this.ecModel = i, this._dataZoomModel = n };
    jk.prototype = {
        constructor: jk,
        hostedBy: function(t) { return this._dataZoomModel === t },
        getDataValueWindow: function() { return this._valueWindow.slice() },
        getDataPercentWindow: function() { return this._percentWindow.slice() },
        getTargetSeriesModels: function() { var t = [],
                e = this.ecModel; return e.eachSeries(function(n) { if (Qg(n.get("coordinateSystem"))) { var i = this._dimName,
                        r = e.queryComponents({ mainType: i + "Axis", index: n.get(i + "AxisIndex"), id: n.get(i + "AxisId") })[0];
                    this._axisIndex === (r && r.componentIndex) && t.push(n) } }, this), t },
        getAxisModel: function() {
            return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex)
        },
        getOtherAxisModel: function() { var t, e, n = this._dimName,
                i = this.ecModel,
                r = this.getAxisModel(),
                a = "x" === n || "y" === n;
            a ? (e = "gridIndex", t = "x" === n ? "y" : "x") : (e = "polarIndex", t = "angle" === n ? "radius" : "angle"); var o; return i.eachComponent(t + "Axis", function(t) {
                (t.get(e) || 0) === (r.get(e) || 0) && (o = t) }), o },
        getMinMaxSpan: function() { return i(this._minMaxSpan) },
        calculateDataWindow: function(t) {
            function e(t, e, n, i, r) { var o = r ? "Span" : "ValueSpan";
                Uk(0, t, n, "all", h["min" + o], h["max" + o]); for (var s = 0; 2 > s; s++) e[s] = Mo(t[s], n, i, !0), r && (e[s] = a.parse(e[s])) } var n, i = this._dataExtent,
                r = this.getAxisModel(),
                a = r.axis.scale,
                o = this._dataZoomModel.getRangePropMode(),
                s = [0, 100],
                l = [],
                u = [];
            Xk(["start", "end"], function(e, r) { var h = t[e],
                    c = t[e + "Value"]; "percent" === o[r] ? (null == h && (h = s[r]), c = a.parse(Mo(h, s, i))) : (n = !0, c = null == c ? i[r] : a.parse(c), h = Mo(c, i, s)), u[r] = c, l[r] = h }), Yk(u), Yk(l); var h = this._minMaxSpan; return n ? e(u, l, i, s, !1) : e(l, u, s, i, !0), { valueWindow: u, percentWindow: l } },
        reset: function(t) { if (t === this._dataZoomModel) { var e = this.getTargetSeriesModels();
                this._dataExtent = iv(this, this._dimName, e), ov(this); var n = this.calculateDataWindow(t.settledOption);
                this._valueWindow = n.valueWindow, this._percentWindow = n.percentWindow, av(this) } },
        restore: function(t) { t === this._dataZoomModel && (this._valueWindow = this._percentWindow = null, av(this, !0)) },
        filterData: function(t) {
            function e(t) { return t >= a[0] && t <= a[1] } if (t === this._dataZoomModel) { var n = this._dimName,
                    i = this.getTargetSeriesModels(),
                    r = t.get("filterMode"),
                    a = this._valueWindow; "none" !== r && Xk(i, function(t) { var i = t.getData(),
                        o = i.mapDimension(n, !0);
                    o.length && ("weakFilter" === r ? i.filterSelf(function(t) { for (var e, n, r, s = 0; s < o.length; s++) { var l = i.get(o[s], t),
                                u = !isNaN(l),
                                h = l < a[0],
                                c = l > a[1]; if (u && !h && !c) return !0;
                            u && (r = !0), h && (e = !0), c && (n = !0) } return r && e && n }) : Xk(o, function(n) { if ("empty" === r) t.setData(i = i.map(n, function(t) { return e(t) ? t : 0 / 0 }));
                        else { var o = {};
                            o[n] = a, i.selectRange(o) } }), Xk(o, function(t) { i.setApproximateExtent(a, t) })) }) } }
    };
    var qk = f,
        Kk = Zk,
        $k = Lu({ type: "dataZoom", dependencies: ["xAxis", "yAxis", "zAxis", "radiusAxis", "angleAxis", "singleAxis", "series"], defaultOption: { zlevel: 0, z: 4, orient: null, xAxisIndex: null, yAxisIndex: null, filterMode: "filter", throttle: null, start: 0, end: 100, startValue: null, endValue: null, minSpan: null, maxSpan: null, minValueSpan: null, maxValueSpan: null, rangeMode: null }, init: function(t, e, n) { this._dataIntervalByAxis = {}, this._dataInfo = {}, this._axisProxies = {}, this.textStyleModel, this._autoThrottle = !0, this._rangePropMode = ["percent", "percent"]; var i = sv(t);
                this.settledOption = i, this.mergeDefaultAndTheme(t, n), this.doInit(i) }, mergeOption: function(t) { var e = sv(t);
                r(this.option, t, !0), r(this.settledOption, e, !0), this.doInit(e) }, doInit: function(t) { var e = this.option;
                Sx.canvasSupported || (e.realtime = !1), this._setDefaultThrottle(t), lv(this, t); var n = this.settledOption;
                qk([
                    ["start", "startValue"],
                    ["end", "endValue"]
                ], function(t, i) { "value" === this._rangePropMode[i] && (e[t[0]] = n[t[0]] = null) }, this), this.textStyleModel = this.getModel("textStyle"), this._resetTarget(), this._giveAxisProxies() }, _giveAxisProxies: function() { var t = this._axisProxies;
                this.eachTargetAxis(function(e, n, i, r) { var a = this.dependentModels[e.axis][n],
                        o = a.__dzAxisProxy || (a.__dzAxisProxy = new jk(e.name, n, this, r));
                    t[e.name + "_" + n] = o }, this) }, _resetTarget: function() { var t = this.option,
                    e = this._judgeAutoMode();
                Kk(function(e) { var n = e.axisIndex;
                    t[n] = er(t[n]) }, this), "axisIndex" === e ? this._autoSetAxisIndex() : "orient" === e && this._autoSetOrient() }, _judgeAutoMode: function() { var t = this.option,
                    e = !1;
                Kk(function(n) { null != t[n.axisIndex] && (e = !0) }, this); var n = t.orient; return null == n && e ? "orient" : e ? void 0 : (null == n && (t.orient = "horizontal"), "axisIndex") }, _autoSetAxisIndex: function() { var t = !0,
                    e = this.get("orient", !0),
                    n = this.option,
                    i = this.dependentModels; if (t) { var r = "vertical" === e ? "y" : "x";
                    i[r + "Axis"].length ? (n[r + "AxisIndex"] = [0], t = !1) : qk(i.singleAxis, function(i) { t && i.get("orient", !0) === e && (n.singleAxisIndex = [i.componentIndex], t = !1) }) }
                t && Kk(function(e) { if (t) { var i = [],
                            r = this.dependentModels[e.axis]; if (r.length && !i.length)
                            for (var a = 0, o = r.length; o > a; a++) "category" === r[a].get("type") && i.push(a);
                        n[e.axisIndex] = i, i.length && (t = !1) } }, this), t && this.ecModel.eachSeries(function(t) { this._isSeriesHasAllAxesTypeOf(t, "value") && Kk(function(e) { var i = n[e.axisIndex],
                            r = t.get(e.axisIndex),
                            a = t.get(e.axisId),
                            o = t.ecModel.queryComponents({ mainType: e.axis, index: r, id: a })[0];
                        r = o.componentIndex, u(i, r) < 0 && i.push(r) }) }, this) }, _autoSetOrient: function() { var t;
                this.eachTargetAxis(function(e) {!t && (t = e.name) }, this), this.option.orient = "y" === t ? "vertical" : "horizontal" }, _isSeriesHasAllAxesTypeOf: function(t, e) { var n = !0; return Kk(function(i) { var r = t.get(i.axisIndex),
                        a = this.dependentModels[i.axis][r];
                    a && a.get("type") === e || (n = !1) }, this), n }, _setDefaultThrottle: function(t) { if (t.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) { var e = this.ecModel.option;
                    this.option.throttle = e.animation && e.animationDurationUpdate > 0 ? 100 : 20 } }, getFirstTargetAxisModel: function() { var t; return Kk(function(e) { if (null == t) { var n = this.get(e.axisIndex);
                        n.length && (t = this.dependentModels[e.axis][n[0]]) } }, this), t }, eachTargetAxis: function(t, e) { var n = this.ecModel;
                Kk(function(i) { qk(this.get(i.axisIndex), function(r) { t.call(e, i, r, this, n) }, this) }, this) }, getAxisProxy: function(t, e) { return this._axisProxies[t + "_" + e] }, getAxisModel: function(t, e) { var n = this.getAxisProxy(t, e); return n && n.getAxisModel() }, setRawRange: function(t) { var e = this.option,
                    n = this.settledOption;
                qk([
                    ["start", "startValue"],
                    ["end", "endValue"]
                ], function(i) {
                    (null != t[i[0]] || null != t[i[1]]) && (e[i[0]] = n[i[0]] = t[i[0]], e[i[1]] = n[i[1]] = t[i[1]]) }, this), lv(this, t) }, setCalculatedRange: function(t) { var e = this.option;
                qk(["start", "startValue", "end", "endValue"], function(n) { e[n] = t[n] }) }, getPercentRange: function() { var t = this.findRepresentativeAxisProxy(); return t ? t.getDataPercentWindow() : void 0 }, getValueRange: function(t, e) { if (null != t || null != e) return this.getAxisProxy(t, e).getDataValueWindow(); var n = this.findRepresentativeAxisProxy(); return n ? n.getDataValueWindow() : void 0 }, findRepresentativeAxisProxy: function(t) { if (t) return t.__dzAxisProxy; var e = this._axisProxies; for (var n in e)
                    if (e.hasOwnProperty(n) && e[n].hostedBy(this)) return e[n];
                for (var n in e)
                    if (e.hasOwnProperty(n) && !e[n].hostedBy(this)) return e[n] }, getRangePropMode: function() { return this._rangePropMode.slice() } }),
        Qk = qS.extend({ type: "dataZoom", render: function(t, e, n) { this.dataZoomModel = t, this.ecModel = e, this.api = n }, getTargetCoordInfo: function() {
                function t(t, e, n, i) { for (var r, a = 0; a < n.length; a++)
                        if (n[a].model === t) { r = n[a]; break }
                    r || n.push(r = { model: t, axisModels: [], coordIndex: i }), r.axisModels.push(e) } var e = this.dataZoomModel,
                    n = this.ecModel,
                    i = {}; return e.eachTargetAxis(function(e, r) { var a = n.getComponent(e.axis, r); if (a) { var o = a.getCoordSysModel();
                        o && t(o, a, i[o.mainType] || (i[o.mainType] = []), o.componentIndex) } }, this), i } }),
        Jk = ($k.extend({ type: "dataZoom.slider", layoutMode: "box", defaultOption: { show: !0, right: "ph", top: "ph", width: "ph", height: "ph", left: null, bottom: null, backgroundColor: "rgba(47,69,84,0)", dataBackground: { lineStyle: { color: "#2f4554", width: .5, opacity: .3 }, areaStyle: { color: "rgba(47,69,84,0.3)", opacity: .3 } }, borderColor: "#ddd", fillerColor: "rgba(167,183,204,0.4)", handleIcon: "M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z", handleSize: "100%", handleStyle: { color: "#a7b7cc" }, labelPrecision: null, labelFormatter: null, showDetail: !0, showDataShadow: "auto", realtime: !0, zoomLock: !1, textStyle: { color: "#333" } } }), cM),
        tP = Mo,
        eP = To,
        nP = y,
        iP = f,
        rP = 7,
        aP = 1,
        oP = 30,
        sP = "horizontal",
        lP = "vertical",
        uP = 5,
        hP = ["line", "bar", "candlestick", "scatter"],
        cP = Qk.extend({ type: "dataZoom.slider", init: function(t, e) { this._displayables = {}, this._orient, this._range, this._handleEnds, this._size, this._handleWidth, this._handleHeight, this._location, this._dragging, this._dataShadowInfo, this.api = e }, render: function(t, e, n, i) { return cP.superApply(this, "render", arguments), xl(this, "_dispatchZoomAction", this.dataZoomModel.get("throttle"), "fixRate"), this._orient = t.get("orient"), this.dataZoomModel.get("show") === !1 ? void this.group.removeAll() : (i && "dataZoom" === i.type && i.from === this.uid || this._buildView(), void this._updateView()) }, remove: function() { cP.superApply(this, "remove", arguments), _l(this, "_dispatchZoomAction") }, dispose: function() { cP.superApply(this, "dispose", arguments), _l(this, "_dispatchZoomAction") }, _buildView: function() { var t = this.group;
                t.removeAll(), this._resetLocation(), this._resetInterval(); var e = this._displayables.barGroup = new N_;
                this._renderBackground(), this._renderHandle(), this._renderDataShadow(), t.add(e), this._positionGroup() }, _resetLocation: function() { var t = this.dataZoomModel,
                    e = this.api,
                    n = this._findCoordRect(),
                    i = { width: e.getWidth(), height: e.getHeight() },
                    r = this._orient === sP ? { right: i.width - n.x - n.width, top: i.height - oP - rP, width: n.width, height: oP } : { right: rP, top: n.y, width: oP, height: n.height },
                    a = es(t.option);
                f(["right", "top", "width", "height"], function(t) { "ph" === a[t] && (a[t] = r[t]) }); var o = Qo(a, i, t.padding);
                this._location = { x: o.x, y: o.y }, this._size = [o.width, o.height], this._orient === lP && this._size.reverse() }, _positionGroup: function() { var t = this.group,
                    e = this._location,
                    n = this._orient,
                    i = this.dataZoomModel.getFirstTargetAxisModel(),
                    r = i && i.get("inverse"),
                    a = this._displayables.barGroup,
                    o = (this._dataShadowInfo || {}).otherAxisInverse;
                a.attr(n !== sP || r ? n === sP && r ? { scale: o ? [-1, 1] : [-1, -1] } : n !== lP || r ? { scale: o ? [-1, -1] : [-1, 1], rotation: Math.PI / 2 } : { scale: o ? [1, -1] : [1, 1], rotation: Math.PI / 2 } : { scale: o ? [1, 1] : [1, -1] }); var s = t.getBoundingRect([a]);
                t.attr("position", [e.x - s.x, e.y - s.y]) }, _getViewExtent: function() { return [0, this._size[0]] }, _renderBackground: function() { var t = this.dataZoomModel,
                    e = this._size,
                    n = this._displayables.barGroup;
                n.add(new Jk({ silent: !0, shape: { x: 0, y: 0, width: e[0], height: e[1] }, style: { fill: t.get("backgroundColor") }, z2: -40 })), n.add(new Jk({ shape: { x: 0, y: 0, width: e[0], height: e[1] }, style: { fill: "transparent" }, z2: 0, onclick: y(this._onClickPanelClick, this) })) }, _renderDataShadow: function() { var t = this._dataShadowInfo = this._prepareDataShadowInfo(); if (t) { var e = this._size,
                        n = t.series,
                        i = n.getRawData(),
                        r = n.getShadowDim ? n.getShadowDim() : t.otherDim; if (null != r) { var a = i.getDataExtent(r),
                            o = .3 * (a[1] - a[0]);
                        a = [a[0] - o, a[1] + o]; var l, u = [0, e[1]],
                            h = [0, e[0]],
                            c = [
                                [e[0], 0],
                                [0, 0]
                            ],
                            d = [],
                            f = h[1] / (i.count() - 1),
                            p = 0,
                            g = Math.round(i.count() / e[0]);
                        i.each([r], function(t, e) { if (g > 0 && e % g) return void(p += f); var n = null == t || isNaN(t) || "" === t,
                                i = n ? 0 : tP(t, a, u, !0);
                            n && !l && e ? (c.push([c[c.length - 1][0], 0]), d.push([d[d.length - 1][0], 0])) : !n && l && (c.push([p, 0]), d.push([p, 0])), c.push([p, i]), d.push([p, i]), p += f, l = n }); var v = this.dataZoomModel;
                        this._displayables.barGroup.add(new sM({ shape: { points: c }, style: s({ fill: v.get("dataBackgroundColor") }, v.getModel("dataBackground.areaStyle").getAreaStyle()), silent: !0, z2: -20 })), this._displayables.barGroup.add(new lM({ shape: { points: d }, style: v.getModel("dataBackground.lineStyle").getLineStyle(), silent: !0, z2: -19 })) } } }, _prepareDataShadowInfo: function() { var t = this.dataZoomModel,
                    e = t.get("showDataShadow"); if (e !== !1) { var n, i = this.ecModel; return t.eachTargetAxis(function(r, a) { var o = t.getAxisProxy(r.name, a).getTargetSeriesModels();
                        f(o, function(t) { if (!(n || e !== !0 && u(hP, t.get("type")) < 0)) { var o, s = i.getComponent(r.axis, a).axis,
                                    l = uv(r.name),
                                    h = t.coordinateSystem;
                                null != l && h.getOtherAxis && (o = h.getOtherAxis(s).inverse), l = t.getData().mapDimension(l), n = { thisAxis: s, series: t, thisDim: r.name, otherDim: l, otherAxisInverse: o } } }, this) }, this), n } }, _renderHandle: function() { var t = this._displayables,
                    e = t.handles = [],
                    n = t.handleLabels = [],
                    i = this._displayables.barGroup,
                    r = this._size,
                    a = this.dataZoomModel;
                i.add(t.filler = new Jk({ draggable: !0, cursor: hv(this._orient), drift: nP(this._onDragMove, this, "all"), ondragstart: nP(this._showDataInfo, this, !0), ondragend: nP(this._onDragEnd, this), onmouseover: nP(this._showDataInfo, this, !0), onmouseout: nP(this._showDataInfo, this, !1), style: { fill: a.get("fillerColor"), textPosition: "inside" } })), i.add(new Jk({ silent: !0, subPixelOptimize: !0, shape: { x: 0, y: 0, width: r[0], height: r[1] }, style: { stroke: a.get("dataBackgroundColor") || a.get("borderColor"), lineWidth: aP, fill: "rgba(0,0,0,0)" } })), iP([0, 1], function(t) { var r = ho(a.get("handleIcon"), { cursor: hv(this._orient), draggable: !0, drift: nP(this._onDragMove, this, t), ondragend: nP(this._onDragEnd, this), onmouseover: nP(this._showDataInfo, this, !0), onmouseout: nP(this._showDataInfo, this, !1) }, { x: -1, y: 0, width: 2, height: 2 }),
                        o = r.getBoundingRect();
                    this._handleHeight = So(a.get("handleSize"), this._size[1]), this._handleWidth = o.width / o.height * this._handleHeight, r.setStyle(a.getModel("handleStyle").getItemStyle()); var s = a.get("handleColor");
                    null != s && (r.style.fill = s), i.add(e[t] = r); var l = a.textStyleModel;
                    this.group.add(n[t] = new Jw({ silent: !0, invisible: !0, style: { x: 0, y: 0, text: "", textVerticalAlign: "middle", textAlign: "center", textFill: l.getTextColor(), textFont: l.getFont() }, z2: 10 })) }, this) }, _resetInterval: function() { var t = this._range = this.dataZoomModel.getPercentRange(),
                    e = this._getViewExtent();
                this._handleEnds = [tP(t[0], [0, 100], e, !0), tP(t[1], [0, 100], e, !0)] }, _updateInterval: function(t, e) { var n = this.dataZoomModel,
                    i = this._handleEnds,
                    r = this._getViewExtent(),
                    a = n.findRepresentativeAxisProxy().getMinMaxSpan(),
                    o = [0, 100];
                Uk(e, i, r, n.get("zoomLock") ? "all" : t, null != a.minSpan ? tP(a.minSpan, o, r, !0) : null, null != a.maxSpan ? tP(a.maxSpan, o, r, !0) : null); var s = this._range,
                    l = this._range = eP([tP(i[0], r, o, !0), tP(i[1], r, o, !0)]); return !s || s[0] !== l[0] || s[1] !== l[1] }, _updateView: function(t) { var e = this._displayables,
                    n = this._handleEnds,
                    i = eP(n.slice()),
                    r = this._size;
                iP([0, 1], function(t) { var i = e.handles[t],
                        a = this._handleHeight;
                    i.attr({ scale: [a / 2, a / 2], position: [n[t], r[1] / 2 - a / 2] }) }, this), e.filler.setShape({ x: i[0], y: 0, width: i[1] - i[0], height: r[1] }), this._updateDataInfo(t) }, _updateDataInfo: function(t) {
                function e(t) { var e = ro(i.handles[t].parent, this.group),
                        n = oo(0 === t ? "right" : "left", e),
                        s = this._handleWidth / 2 + uP,
                        l = ao([c[t] + (0 === t ? -s : s), this._size[1] / 2], e);
                    r[t].setStyle({ x: l[0], y: l[1], textVerticalAlign: a === sP ? "middle" : n, textAlign: a === sP ? n : "center", text: o[t] }) } var n = this.dataZoomModel,
                    i = this._displayables,
                    r = i.handleLabels,
                    a = this._orient,
                    o = ["", ""]; if (n.get("showDetail")) { var s = n.findRepresentativeAxisProxy(); if (s) { var l = s.getAxisModel().axis,
                            u = this._range,
                            h = t ? s.calculateDataWindow({ start: u[0], end: u[1] }).valueWindow : s.getDataValueWindow();
                        o = [this._formatLabel(h[0], l), this._formatLabel(h[1], l)] } } var c = eP(this._handleEnds.slice());
                e.call(this, 0), e.call(this, 1) }, _formatLabel: function(t, e) { var n = this.dataZoomModel,
                    i = n.get("labelFormatter"),
                    r = n.get("labelPrecision");
                (null == r || "auto" === r) && (r = e.getPixelPrecision()); var a = null == t || isNaN(t) ? "" : "category" === e.type || "time" === e.type ? e.scale.getLabel(Math.round(t)) : t.toFixed(Math.min(r, 20)); return b(i) ? i(t, a) : w(i) ? i.replace("{value}", a) : a }, _showDataInfo: function(t) { t = this._dragging || t; var e = this._displayables.handleLabels;
                e[0].attr("invisible", !t), e[1].attr("invisible", !t) }, _onDragMove: function(t, e, n, i) { this._dragging = !0, Jx(i.event); var r = this._displayables.barGroup.getLocalTransform(),
                    a = ao([e, n], r, !0),
                    o = this._updateInterval(t, a[0]),
                    s = this.dataZoomModel.get("realtime");
                this._updateView(!s), o && s && this._dispatchZoomAction() }, _onDragEnd: function() { this._dragging = !1, this._showDataInfo(!1); var t = this.dataZoomModel.get("realtime");!t && this._dispatchZoomAction() }, _onClickPanelClick: function(t) { var e = this._size,
                    n = this._displayables.barGroup.transformCoordToLocal(t.offsetX, t.offsetY); if (!(n[0] < 0 || n[0] > e[0] || n[1] < 0 || n[1] > e[1])) { var i = this._handleEnds,
                        r = (i[0] + i[1]) / 2,
                        a = this._updateInterval("all", n[0] - r);
                    this._updateView(), a && this._dispatchZoomAction() } }, _dispatchZoomAction: function() { var t = this._range;
                this.api.dispatchAction({ type: "dataZoom", from: this.uid, dataZoomId: this.dataZoomModel.id, start: t[0], end: t[1] }) }, _findCoordRect: function() { var t; if (iP(this.getTargetCoordInfo(), function(e) { if (!t && e.length) { var n = e[0].model.coordinateSystem;
                            t = n.getRect && n.getRect() } }), !t) { var e = this.api.getWidth(),
                        n = this.api.getHeight();
                    t = { x: .2 * e, y: .2 * n, width: .6 * e, height: .6 * n } } return t } });
    Mu({ getTargetSeries: function(t) { var e = N(); return t.eachComponent("dataZoom", function(t) { t.eachTargetAxis(function(t, n, i) { var r = i.getAxisProxy(t.name, n);
                    f(r.getTargetSeriesModels(), function(t) { e.set(t.uid, t) }) }) }), e }, modifyOutputEnd: !0, overallReset: function(t, e) { t.eachComponent("dataZoom", function(t) { t.eachTargetAxis(function(t, n, i) { i.getAxisProxy(t.name, n).reset(i, e) }), t.eachTargetAxis(function(t, n, i) { i.getAxisProxy(t.name, n).filterData(i, e) }) }), t.eachComponent("dataZoom", function(t) { var e = t.findRepresentativeAxisProxy(),
                    n = e.getDataPercentWindow(),
                    i = e.getDataValueWindow();
                t.setCalculatedRange({ start: n[0], end: n[1], startValue: i[0], endValue: i[1] }) }) } }), Iu("dataZoom", function(t, e) { var n = tv(y(e.eachComponent, e, "dataZoom"), Zk, function(t, e) { return t.get(e.axisIndex) }),
            i = [];
        e.eachComponent({ mainType: "dataZoom", query: t }, function(t) { i.push.apply(i, n(t).nodes) }), f(i, function(e) { e.setRawRange({ start: t.start, end: t.end, startValue: t.startValue, endValue: t.endValue }) }) }), $k.extend({ type: "dataZoom.inside", defaultOption: { disabled: !1, zoomLock: !1, zoomOnMouseWheel: !0, moveOnMouseMove: !0, moveOnMouseWheel: !1, preventDefaultMouseMove: !0 } });
    var dP = "\x00_ec_dataZoom_roams",
        fP = y,
        pP = Qk.extend({ type: "dataZoom.inside", init: function() { this._range }, render: function(t, e, n) { pP.superApply(this, "render", arguments), this._range = t.getPercentRange(), f(this.getTargetCoordInfo(), function(e, i) { var r = p(e, function(t) { return fv(t.model) });
                    f(e, function(e) { var a = e.model,
                            o = {};
                        f(["pan", "zoom", "scrollMove"], function(t) { o[t] = fP(gP[t], this, e, i) }, this), cv(n, { coordId: fv(a), allCoordIds: r, containsPoint: function(t, e, n) { return a.coordinateSystem.containPoint([e, n]) }, dataZoomId: t.id, dataZoomModel: t, getRange: o }) }, this) }, this) }, dispose: function() { dv(this.api, this.dataZoomModel.id), pP.superApply(this, "dispose", arguments), this._range = null } }),
        gP = { zoom: function(t, e, n, i) { var r = this._range,
                    a = r.slice(),
                    o = t.axisModels[0]; if (o) { var s = vP[e](null, [i.originX, i.originY], o, n, t),
                        l = (s.signal > 0 ? s.pixelStart + s.pixelLength - s.pixel : s.pixel - s.pixelStart) / s.pixelLength * (a[1] - a[0]) + a[0],
                        u = Math.max(1 / i.scale, 0);
                    a[0] = (a[0] - l) * u + l, a[1] = (a[1] - l) * u + l; var h = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan(); return Uk(0, a, [0, 100], 0, h.minSpan, h.maxSpan), this._range = a, r[0] !== a[0] || r[1] !== a[1] ? a : void 0 } }, pan: xv(function(t, e, n, i, r, a) { var o = vP[i]([a.oldX, a.oldY], [a.newX, a.newY], e, r, n); return o.signal * (t[1] - t[0]) * o.pixel / o.pixelLength }), scrollMove: xv(function(t, e, n, i, r, a) { var o = vP[i]([0, 0], [a.scrollDelta, a.scrollDelta], e, r, n); return o.signal * (t[1] - t[0]) * a.scrollDelta }) },
        vP = { grid: function(t, e, n, i, r) { var a = n.axis,
                    o = {},
                    s = r.model.coordinateSystem.getRect(); return t = t || [0, 0], "x" === a.dim ? (o.pixel = e[0] - t[0], o.pixelLength = s.width, o.pixelStart = s.x, o.signal = a.inverse ? 1 : -1) : (o.pixel = e[1] - t[1], o.pixelLength = s.height, o.pixelStart = s.y, o.signal = a.inverse ? -1 : 1), o }, polar: function(t, e, n, i, r) { var a = n.axis,
                    o = {},
                    s = r.model.coordinateSystem,
                    l = s.getRadiusAxis().getExtent(),
                    u = s.getAngleAxis().getExtent(); return t = t ? s.pointToCoord(t) : [0, 0], e = s.pointToCoord(e), "radiusAxis" === n.mainType ? (o.pixel = e[0] - t[0], o.pixelLength = l[1] - l[0], o.pixelStart = l[0], o.signal = a.inverse ? 1 : -1) : (o.pixel = e[1] - t[1], o.pixelLength = u[1] - u[0], o.pixelStart = u[0], o.signal = a.inverse ? -1 : 1), o }, singleAxis: function(t, e, n, i, r) { var a = n.axis,
                    o = r.model.coordinateSystem.getRect(),
                    s = {}; return t = t || [0, 0], "horizontal" === a.orient ? (s.pixel = e[0] - t[0], s.pixelLength = o.width, s.pixelStart = o.x, s.signal = a.inverse ? 1 : -1) : (s.pixel = e[1] - t[1], s.pixelLength = o.height, s.pixelStart = o.y, s.signal = a.inverse ? -1 : 1), s } },
        mP = ["rect", "polygon", "keep", "clear"],
        yP = function(t, e) { var n = t && t.brush; if (_(n) || (n = n ? [n] : []), n.length) { var i = [];
                f(n, function(t) { var e = t.hasOwnProperty("toolbox") ? t.toolbox : [];
                    e instanceof Array && (i = i.concat(e)) }); var r = t && t.toolbox;
                _(r) && (r = r[0]), r || (r = { feature: {} }, t.toolbox = [r]); var a = r.feature || (r.feature = {}),
                    o = a.brush || (a.brush = {}),
                    s = o.type || (o.type = []);
                s.push.apply(s, i), _v(s), e && !s.length && s.push.apply(s, mP) } },
        xP = f,
        _P = M,
        bP = -1,
        wP = function(t) { var e = t.mappingMethod,
                n = t.type,
                r = this.option = i(t);
            this.type = n, this.mappingMethod = e, this._normalizeData = SP[e]; var a = MP[n];
            this.applyVisual = a.applyVisual, this.getColorMapper = a.getColorMapper, this._doMap = a._doMap[e], "piecewise" === e ? (Mv(r), bv(r)) : "category" === e ? r.categories ? wv(r) : Mv(r, !0) : (O("linear" !== e || r.dataExtent), Mv(r)) };
    wP.prototype = { constructor: wP, mapValueToVisual: function(t) { var e = this._normalizeData(t); return this._doMap(e, t) }, getNormalizer: function() { return y(this._normalizeData, this) } };
    var MP = wP.visualHandlers = { color: { applyVisual: Tv("color"), getColorMapper: function() { var t = this.option; return y("category" === t.mappingMethod ? function(t, e) { return !e && (t = this._normalizeData(t)), Cv.call(this, t) } : function(e, n, i) { var r = !!i; return !n && (e = this._normalizeData(e)), i = on(e, t.parsedVisual, i), r ? i : hn(i, "rgba") }, this) }, _doMap: { linear: function(t) { return hn(on(t, this.option.parsedVisual), "rgba") }, category: Cv, piecewise: function(t, e) { var n = kv.call(this, e); return null == n && (n = hn(on(t, this.option.parsedVisual), "rgba")), n }, fixed: Av } }, colorHue: Sv(function(t, e) { return ln(t, e) }), colorSaturation: Sv(function(t, e) { return ln(t, null, e) }), colorLightness: Sv(function(t, e) { return ln(t, null, null, e) }), colorAlpha: Sv(function(t, e) { return un(t, e) }), opacity: { applyVisual: Tv("opacity"), _doMap: Dv([0, 1]) }, liftZ: { applyVisual: Tv("liftZ"), _doMap: { linear: Av, category: Av, piecewise: Av, fixed: Av } }, symbol: { applyVisual: function(t, e, n) { var i = this.mapValueToVisual(t); if (w(i)) n("symbol", i);
                    else if (_P(i))
                        for (var r in i) i.hasOwnProperty(r) && n(r, i[r]) }, _doMap: { linear: Iv, category: Cv, piecewise: function(t, e) { var n = kv.call(this, e); return null == n && (n = Iv.call(this, t)), n }, fixed: Av } }, symbolSize: { applyVisual: Tv("symbolSize"), _doMap: Dv([0, 1]) } },
        SP = { linear: function(t) { return Mo(t, this.option.dataExtent, [0, 1], !0) }, piecewise: function(t) { var e = this.option.pieceList,
                    n = wP.findPieceIndex(t, e, !0); return null != n ? Mo(n, [0, e.length - 1], [0, 1], !0) : void 0 }, category: function(t) { var e = this.option.categories ? this.option.categoryMap[t] : t; return null == e ? bP : e }, fixed: F };
    wP.listVisualTypes = function() { var t = []; return f(MP, function(e, n) { t.push(n) }), t }, wP.addVisualHandler = function(t, e) { MP[t] = e }, wP.isValidType = function(t) { return MP.hasOwnProperty(t) }, wP.eachVisual = function(t, e, n) { M(t) ? f(t, e, n) : e.call(n, t) }, wP.mapVisual = function(t, e, n) { var i, r = _(t) ? [] : M(t) ? {} : (i = !0, null); return wP.eachVisual(t, function(t, a) { var o = e.call(n, t, a);
            i ? r = o : r[a] = o }), r }, wP.retrieveVisuals = function(t) { var e, n = {}; return t && xP(MP, function(i, r) { t.hasOwnProperty(r) && (n[r] = t[r], e = !0) }), e ? n : null }, wP.prepareVisualTypes = function(t) { if (_P(t)) { var e = [];
            xP(t, function(t, n) { e.push(n) }), t = e } else { if (!_(t)) return [];
            t = t.slice() } return t.sort(function(t, e) { return "color" === e && "color" !== t && 0 === t.indexOf("color") ? 1 : -1 }), t }, wP.dependsOn = function(t, e) { return "color" === e ? !(!t || 0 !== t.indexOf(e)) : t === e }, wP.findPieceIndex = function(t, e, n) {
        function i(e, n) { var i = Math.abs(e - t);
            a > i && (a = i, r = n) } for (var r, a = 1 / 0, o = 0, s = e.length; s > o; o++) { var l = e[o].value; if (null != l) { if (l === t || "string" == typeof l && l === t + "") return o;
                n && i(l, o) } } for (var o = 0, s = e.length; s > o; o++) { var u = e[o],
                h = u.interval,
                c = u.close; if (h) { if (h[0] === -1 / 0) { if (Lv(c[1], t, h[1])) return o } else if (1 / 0 === h[1]) { if (Lv(c[0], h[0], t)) return o } else if (Lv(c[0], h[0], t) && Lv(c[1], t, h[1])) return o;
                n && i(h[0], o), n && i(h[1], o) } } return n ? 1 / 0 === t ? e.length - 1 : t === -1 / 0 ? 0 : r : void 0 };
    var IP = f,
        TP = { lineX: Nv(0), lineY: Nv(1), rect: { point: function(t, e, n) { return t && n.boundingRect.contain(t[0], t[1]) }, rect: function(t, e, n) { return t && n.boundingRect.intersect(t) } }, polygon: { point: function(t, e, n) { return t && n.boundingRect.contain(t[0], t[1]) && nc(n.range, t[0], t[1]) }, rect: function(t, e, n) { var i = n.range; if (!t || i.length <= 1) return !1; var r = t.x,
                        a = t.y,
                        o = t.width,
                        s = t.height,
                        l = i[0]; return nc(i, r, a) || nc(i, r + o, a) || nc(i, r, a + s) || nc(i, r + o, a + s) || Cn.create(t).contain(l[0], l[1]) || co(r, a, r + o, a, i) || co(r, a, r, a + s, i) || co(r + o, a, r + o, a + s, i) || co(r, a + s, r + o, a + s, i) ? !0 : void 0 } } },
        CP = f,
        AP = u,
        DP = x,
        kP = ["dataToPoint", "pointToData"],
        PP = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"],
        LP = Zv.prototype;
    LP.setOutputRanges = function(t, e) { this.matchOutputRanges(t, e, function(t, e, n) { if ((t.coordRanges || (t.coordRanges = [])).push(e), !t.coordRange) { t.coordRange = e; var i = RP[t.brushType](0, n, e);
                t.__rangeOffset = { offset: BP[t.brushType](i.values, t.range, [1, 1]), xyMinMax: i.xyMinMax } } }) }, LP.matchOutputRanges = function(t, e, n) { CP(t, function(t) { var i = this.findTargetInfo(t, e);
            i && i !== !0 && f(i.coordSyses, function(i) { var r = RP[t.brushType](1, i, t.range);
                n(t, r.values, i, e) }) }, this) }, LP.setInputRanges = function(t, e) { CP(t, function(t) { var n = this.findTargetInfo(t, e); if (t.range = t.range || [], n && n !== !0) { t.panelId = n.panelId; var i = RP[t.brushType](0, n.coordSys, t.coordRange),
                    r = t.__rangeOffset;
                t.range = r ? BP[t.brushType](i.values, r.offset, qv(i.xyMinMax, r.xyMinMax)) : i.values } }, this) }, LP.makePanelOpts = function(t, e) { return p(this._targetInfoList, function(n) { var i = n.getPanelRect(); return { panelId: n.panelId, defaultBrushType: e && e(n), clipPath: Fv(i), isTargetByCursor: Gv(i, t, n.coordSysModel), getLinearBrushOtherExtent: Hv(i) } }) }, LP.controlSeries = function(t, e, n) { var i = this.findTargetInfo(t, n); return i === !0 || i && AP(i.coordSyses, e.coordinateSystem) >= 0 }, LP.findTargetInfo = function(t, e) { for (var n = this._targetInfoList, i = Xv(e, t), r = 0; r < n.length; r++) { var a = n[r],
                o = t.panelId; if (o) { if (a.panelId === o) return a } else
                for (var r = 0; r < zP.length; r++)
                    if (zP[r](i, a)) return a } return !0 };
    var OP = { grid: function(t, e) { var n = t.xAxisModels,
                    i = t.yAxisModels,
                    r = t.gridModels,
                    a = N(),
                    o = {},
                    s = {};
                (n || i || r) && (CP(n, function(t) { var e = t.axis.grid.model;
                    a.set(e.id, e), o[e.id] = !0 }), CP(i, function(t) { var e = t.axis.grid.model;
                    a.set(e.id, e), s[e.id] = !0 }), CP(r, function(t) { a.set(t.id, t), o[t.id] = !0, s[t.id] = !0 }), a.each(function(t) { var r = t.coordinateSystem,
                        a = [];
                    CP(r.getCartesians(), function(t) {
                        (AP(n, t.getAxis("x").model) >= 0 || AP(i, t.getAxis("y").model) >= 0) && a.push(t) }), e.push({ panelId: "grid--" + t.id, gridModel: t, coordSysModel: t, coordSys: a[0], coordSyses: a, getPanelRect: EP.grid, xAxisDeclared: o[t.id], yAxisDeclared: s[t.id] }) })) }, geo: function(t, e) { CP(t.geoModels, function(t) { var n = t.coordinateSystem;
                    e.push({ panelId: "geo--" + t.id, geoModel: t, coordSysModel: t, coordSys: n, coordSyses: [n], getPanelRect: EP.geo }) }) } },
        zP = [function(t, e) { var n = t.xAxisModel,
                i = t.yAxisModel,
                r = t.gridModel; return !r && n && (r = n.axis.grid.model), !r && i && (r = i.axis.grid.model), r && r === e.gridModel }, function(t, e) { var n = t.geoModel; return n && n === e.geoModel }],
        EP = { grid: function() { return this.coordSys.grid.getRect().clone() }, geo: function() { var t = this.coordSys,
                    e = t.getBoundingRect().clone(); return e.applyTransform(ro(t)), e } },
        RP = { lineX: DP(Yv, 0), lineY: DP(Yv, 1), rect: function(t, e, n) { var i = e[kP[t]]([n[0][0], n[1][0]]),
                    r = e[kP[t]]([n[0][1], n[1][1]]),
                    a = [Uv([i[0], r[0]]), Uv([i[1], r[1]])]; return { values: a, xyMinMax: a } }, polygon: function(t, e, n) { var i = [
                        [1 / 0, -1 / 0],
                        [1 / 0, -1 / 0]
                    ],
                    r = p(n, function(n) { var r = e[kP[t]](n); return i[0][0] = Math.min(i[0][0], r[0]), i[1][0] = Math.min(i[1][0], r[1]), i[0][1] = Math.max(i[0][1], r[0]), i[1][1] = Math.max(i[1][1], r[1]), r }); return { values: r, xyMinMax: i } } },
        BP = { lineX: DP(jv, 0), lineY: DP(jv, 1), rect: function(t, e, n) { return [
                    [t[0][0] - n[0] * e[0][0], t[0][1] - n[0] * e[0][1]],
                    [t[1][0] - n[1] * e[1][0], t[1][1] - n[1] * e[1][1]]
                ] }, polygon: function(t, e, n) { return p(t, function(t, i) { return [t[0] - n[0] * e[i][0], t[1] - n[1] * e[i][1]] }) } },
        NP = ["inBrush", "outOfBrush"],
        VP = "__ecBrushSelect",
        FP = "__ecInBrushSelectEvent",
        HP = QI.VISUAL.BRUSH;
    Au(HP, function(t, e, n) { t.eachComponent({ mainType: "brush" }, function(t) { n && "takeGlobalCursor" === n.type && t.setBrushOption("brush" === n.key ? n.brushOption : { brushType: !1 }) }), $v(t) }), Du(HP, function(t, e, n) { var r, a, o = [];
        t.eachComponent({ mainType: "brush" }, function(e, n) {
            function l(t) { return "all" === v || m[t] }

            function u(t) { return !!t.length }

            function h(t, e) { var n = t.coordinateSystem;
                b |= n.hasAxisBrushed(), l(e) && n.eachActiveState(t.getData(), function(t, e) { "active" === t && (y[e] = 1) }) }

            function c(n, i, r) { var a = em(n); if (a && !nm(e, i) && (f(w, function(i) { a[i.brushType] && e.brushTargetManager.controlSeries(i, n, t) && r.push(i), b |= u(r) }), l(i) && u(r))) { var o = n.getData();
                    o.each(function(t) { tm(a, r, o, t) && (y[t] = 1) }) } } var d = { brushId: e.id, brushIndex: n, brushName: e.name, areas: i(e.areas), selected: [] };
            o.push(d); var g = e.option,
                v = g.brushLink,
                m = [],
                y = [],
                x = [],
                b = 0;
            n || (r = g.throttleType, a = g.throttleDelay); var w = p(e.areas, function(t) { return im(s({ boundingRect: GP[t.brushType](t) }, t)) }),
                M = zv(e.option, NP, function(t) { t.mappingMethod = "fixed" });
            _(v) && f(v, function(t) { m[t] = 1 }), t.eachSeries(function(t, e) { var n = x[e] = []; "parallel" === t.subType ? h(t, e, n) : c(t, e, n) }), t.eachSeries(function(t, e) { var n = { seriesId: t.id, seriesIndex: e, seriesName: t.name, dataIndex: [] };
                d.selected.push(n); var i = em(t),
                    r = x[e],
                    a = t.getData(),
                    o = l(e) ? function(t) { return y[t] ? (n.dataIndex.push(a.getRawIndex(t)), "inBrush") : "outOfBrush" } : function(t) { return tm(i, r, a, t) ? (n.dataIndex.push(a.getRawIndex(t)), "inBrush") : "outOfBrush" };
                (l(e) ? b : u(r)) && Rv(NP, M, a, o) }) }), Qv(e, r, a, o, n) });
    var GP = { lineX: F, lineY: F, rect: function(t) { return rm(t.range) }, polygon: function(t) { for (var e, n = t.range, i = 0, r = n.length; r > i; i++) { e = e || [
                        [1 / 0, -1 / 0],
                        [1 / 0, -1 / 0]
                    ]; var a = n[i];
                    a[0] < e[0][0] && (e[0][0] = a[0]), a[0] > e[0][1] && (e[0][1] = a[0]), a[1] < e[1][0] && (e[1][0] = a[1]), a[1] > e[1][1] && (e[1][1] = a[1]) } return e && rm(e) } },
        WP = ["#ddd"],
        ZP = (Lu({ type: "brush", dependencies: ["geo", "grid", "xAxis", "yAxis", "parallel", "series"], defaultOption: { toolbox: null, brushLink: null, seriesIndex: "all", geoIndex: null, xAxisIndex: null, yAxisIndex: null, brushType: "rect", brushMode: "single", transformable: !0, brushStyle: { borderWidth: 1, color: "rgba(120,140,180,0.3)", borderColor: "rgba(120,140,180,0.8)" }, throttleType: "fixRate", throttleDelay: 0, removeOnClick: !0, z: 1e4 }, areas: [], brushType: null, brushOption: {}, coordInfoList: [], optionUpdated: function(t, e) { var n = this.option;!e && Ev(n, t, ["inBrush", "outOfBrush"]); var i = n.inBrush = n.inBrush || {};
                n.outOfBrush = n.outOfBrush || { color: WP }, i.hasOwnProperty("liftZ") || (i.liftZ = 5) }, setAreas: function(t) { t && (this.areas = p(t, function(t) { return am(this.option, t) }, this)) }, setBrushOption: function(t) { this.brushOption = am(this.option, t), this.brushType = this.brushOption.brushType } }), x),
        UP = f,
        XP = p,
        YP = Math.min,
        jP = Math.max,
        qP = Math.pow,
        KP = 1e4,
        $P = 6,
        QP = 6,
        JP = "globalPan",
        tL = { w: [0, 0], e: [0, 1], n: [1, 0], s: [1, 1] },
        eL = { w: "ew", e: "ew", n: "ns", s: "ns", ne: "nesw", sw: "nesw", nw: "nwse", se: "nwse" },
        nL = { brushStyle: { lineWidth: 2, stroke: "rgba(0,0,0,0.3)", fill: "rgba(0,0,0,0.1)" }, transformable: !0, brushMode: "single", removeOnClick: !1 },
        iL = 0;
    om.prototype = { constructor: om, enableBrush: function(t) { return this._brushType && lm(this), t.brushType && sm(this, t), this }, setPanels: function(t) { if (t && t.length) { var e = this._panels = {};
                f(t, function(t) { e[t.panelId] = i(t) }) } else this._panels = null; return this }, mount: function(t) { t = t || {}, this._enableGlobalPan = t.enableGlobalPan; var e = this.group; return this._zr.add(e), e.attr({ position: t.position || [0, 0], rotation: t.rotation || 0, scale: t.scale || [1, 1] }), this._transform = e.getLocalTransform(), this }, eachCover: function(t, e) { UP(this._covers, t, e) }, updateCovers: function(t) {
            function e(t, e) { return (null != t.id ? t.id : s + e) + "-" + t.brushType }

            function n(t, n) { return e(t.__brushOption, n) }

            function a(e, n) { var i = t[e]; if (null != n && l[n] === c) u[e] = l[n];
                else { var r = u[e] = null != n ? (l[n].__brushOption = i, l[n]) : dm(h, cm(h, i));
                    gm(h, r) } }

            function o(t) { l[t] !== c && h.group.remove(l[t]) }
            t = p(t, function(t) { return r(i(nL), t, !0) }); var s = "\x00-brush-index-",
                l = this._covers,
                u = this._covers = [],
                h = this,
                c = this._creatingCover; return new Fu(l, t, n, e).add(a).update(a).remove(o).execute(), this }, unmount: function() { return this.enableBrush(!1), xm(this), this._zr.remove(this.group), this }, dispose: function() { this.unmount(), this.off() } }, c(om, Xx);
    var rL = { mousedown: function(t) { if (this._dragging) Hm(this, t);
                else if (!t.target || !t.target.draggable) { Bm(t); var e = this.group.transformCoordToLocal(t.offsetX, t.offsetY);
                    this._creatingCover = null; var n = this._creatingPanel = mm(this, t, e);
                    n && (this._dragging = !0, this._track = [e.slice()]) } }, mousemove: function(t) { var e = t.offsetX,
                    n = t.offsetY,
                    i = this.group.transformCoordToLocal(e, n); if (Rm(this, t, i), this._dragging) { Bm(t); var r = Vm(this, t, i, !1);
                    r && _m(this, r) } }, mouseup: function(t) { Hm(this, t) } },
        aL = {
            lineX: Wm(0),
            lineY: Wm(1),
            rect: { createCover: function(t, e) { return Mm(ZP(Pm, function(t) { return t }, function(t) { return t }), t, e, ["w", "e", "n", "s", "se", "sw", "ne", "nw"]) }, getCreatingRange: function(t) { var e = wm(t); return Am(e[1][0], e[1][1], e[0][0], e[0][1]) }, updateCoverShape: function(t, e, n, i) { Sm(t, e, n, i) }, updateCommon: Im, contain: Nm },
            polygon: {
                createCover: function(t, e) {
                    var n = new N_;
                    return n.add(new lM({ name: "main", style: Cm(e), silent: !0 })), n
                },
                getCreatingRange: function(t) { return t },
                endCreating: function(t, e) { e.remove(e.childAt(0)), e.add(new sM({ name: "main", draggable: !0, drift: ZP(Lm, t, e), ondragend: ZP(_m, t, { isEnd: !0 }) })) },
                updateCoverShape: function(t, e, n) { e.childAt(0).setShape({ points: zm(t, e, n) }) },
                updateCommon: Im,
                contain: Nm
            }
        };
    Ou({ type: "brush", init: function(t, e) { this.ecModel = t, this.api = e, this.model, (this._brushController = new om(e.getZr())).on("brush", y(this._onBrush, this)).mount() }, render: function(t) { return this.model = t, Zm.apply(this, arguments) }, updateTransform: function(t, e) { return $v(e), Zm.apply(this, arguments) }, updateView: Zm, dispose: function() { this._brushController.dispose() }, _onBrush: function(t, e) { var n = this.model.id;
            this.model.brushTargetManager.setOutputRanges(t, this.ecModel), (!e.isEnd || e.removeOnClick) && this.api.dispatchAction({ type: "brush", brushId: n, areas: i(t), $from: n }), e.isEnd && this.api.dispatchAction({ type: "brushEnd", brushId: n, areas: i(t), $from: n }) } }), Iu({ type: "brush", event: "brush" }, function(t, e) { e.eachComponent({ mainType: "brush", query: t }, function(e) { e.setAreas(t.areas) }) }), Iu({ type: "brushSelect", event: "brushSelected", update: "none" }, function() {}), Iu({ type: "brushEnd", event: "brushEnd", update: "none" }, function() {});
    var oL = {},
        sL = oI.toolbox.brush;
    Ym.defaultOption = { show: !0, type: ["rect", "polygon", "lineX", "lineY", "keep", "clear"], icon: { rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13", polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2", lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4", lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4", keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z", clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2" }, title: i(sL.title) };
    var lL = Ym.prototype;
    lL.render = lL.updateView = function(t, e) { var n, i, r;
        e.eachComponent({ mainType: "brush" }, function(t) { n = t.brushType, i = t.brushOption.brushMode || "single", r |= t.areas.length }), this._brushType = n, this._brushMode = i, f(t.get("type", !0), function(e) { t.setIconStatus(e, ("keep" === e ? "multiple" === i : "clear" === e ? r : e === n) ? "emphasis" : "normal") }) }, lL.getIcons = function() { var t = this.model,
            e = t.get("icon", !0),
            n = {}; return f(t.get("type", !0), function(t) { e[t] && (n[t] = e[t]) }), n }, lL.onclick = function(t, e, n) { var i = this._brushType,
            r = this._brushMode; "clear" === n ? (e.dispatchAction({ type: "axisAreaSelect", intervals: [] }), e.dispatchAction({ type: "brush", command: "clear", areas: [] })) : e.dispatchAction({ type: "takeGlobalCursor", key: "brush", brushOption: { brushType: "keep" === n ? i : i === n ? !1 : n, brushMode: "keep" === n ? "multiple" === r ? "single" : "multiple" : r } }) }, Um("brush", Ym), wu(yP);
    var uL = f,
        hL = function(t) { var e = t && t.visualMap;
            _(e) || (e = e ? [e] : []), uL(e, function(t) { if (t) { jm(t, "splitList") && !jm(t, "pieces") && (t.pieces = t.splitList, delete t.splitList); var e = t.pieces;
                    e && _(e) && uL(e, function(t) { M(t) && (jm(t, "start") && !jm(t, "min") && (t.min = t.start), jm(t, "end") && !jm(t, "max") && (t.max = t.end)) }) } }) };
    sS.registerSubTypeDefaulter("visualMap", function(t) { return t.categories || (t.pieces ? t.pieces.length > 0 : t.splitNumber > 0) && !t.calculable ? "piecewise" : "continuous" });
    var cL = QI.VISUAL.COMPONENT;
    Du(cL, { createOnAllSeries: !0, reset: function(t, e) { var n = []; return e.eachComponent("visualMap", function(e) { var i = t.pipelineContext;!e.isTargetSeries(t) || i && i.large || n.push(Bv(e.stateList, e.targetVisuals, y(e.getValueState, e), e.getDataDimension(t.getData()))) }), n } }), Du(cL, { createOnAllSeries: !0, reset: function(t, e) { var n = t.getData(),
                i = [];
            e.eachComponent("visualMap", function(e) { if (e.isTargetSeries(t)) { var r = e.getVisualMeta(y(qm, null, t, e)) || { stops: [], outerColors: [] },
                        a = e.getDataDimension(n),
                        o = n.getDimensionInfo(a);
                    null != o && (r.dimension = o.index, i.push(r)) } }), t.getData().setVisual("visualMeta", i) } });
    var dL = { get: function(t, e, n) { var r = i((fL[t] || {})[e]); return n && _(r) ? r[r.length - 1] : r } },
        fL = { color: { active: ["#006edd", "#e0ffff"], inactive: ["rgba(0,0,0,0)"] }, colorHue: { active: [0, 360], inactive: [0, 0] }, colorSaturation: { active: [.3, 1], inactive: [0, 0] }, colorLightness: { active: [.9, .5], inactive: [0, 0] }, colorAlpha: { active: [.3, 1], inactive: [0, 0] }, opacity: { active: [.3, 1], inactive: [0, 0] }, symbol: { active: ["circle", "roundRect", "diamond"], inactive: ["none"] }, symbolSize: { active: [10, 50], inactive: [0, 0] } },
        pL = wP.mapVisual,
        gL = wP.eachVisual,
        vL = _,
        mL = f,
        yL = To,
        xL = Mo,
        _L = F,
        bL = Lu({ type: "visualMap", dependencies: ["series"], stateList: ["inRange", "outOfRange"], replacableOptionKeys: ["inRange", "outOfRange", "target", "controller", "color"], dataBound: [-1 / 0, 1 / 0], layoutMode: { type: "box", ignoreSize: !0 }, defaultOption: { show: !0, zlevel: 0, z: 4, seriesIndex: "all", min: 0, max: 200, dimension: null, inRange: null, outOfRange: null, left: 0, right: null, top: null, bottom: 0, itemWidth: null, itemHeight: null, inverse: !1, orient: "vertical", backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", contentColor: "#5793f3", inactiveColor: "#aaa", borderWidth: 0, padding: 5, textGap: 10, precision: 0, color: null, formatter: null, text: null, textStyle: { color: "#333" } }, init: function(t, e, n) { this._dataExtent, this.targetVisuals = {}, this.controllerVisuals = {}, this.textStyleModel, this.itemSize, this.mergeDefaultAndTheme(t, n) }, optionUpdated: function(t, e) { var n = this.option;
                Sx.canvasSupported || (n.realtime = !1), !e && Ev(n, t, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption() }, resetVisual: function(t) { var e = this.stateList;
                t = y(t, this), this.controllerVisuals = zv(this.option.controller, e, t), this.targetVisuals = zv(this.option.target, e, t) }, getTargetSeriesIndices: function() { var t = this.option.seriesIndex,
                    e = []; return null == t || "all" === t ? this.ecModel.eachSeries(function(t, n) { e.push(n) }) : e = er(t), e }, eachTargetSeries: function(t, e) { f(this.getTargetSeriesIndices(), function(n) { t.call(e, this.ecModel.getSeriesByIndex(n)) }, this) }, isTargetSeries: function(t) { var e = !1; return this.eachTargetSeries(function(n) { n === t && (e = !0) }), e }, formatValueText: function(t, e, n) {
                function i(t) { return t === l[0] ? "min" : t === l[1] ? "max" : (+t).toFixed(Math.min(s, 20)) } var r, a, o = this.option,
                    s = o.precision,
                    l = this.dataBound,
                    u = o.formatter; return n = n || ["<", ">"], _(t) && (t = t.slice(), r = !0), a = e ? t : r ? [i(t[0]), i(t[1])] : i(t), w(u) ? u.replace("{value}", r ? a[0] : a).replace("{value2}", r ? a[1] : a) : b(u) ? r ? u(t[0], t[1]) : u(t) : r ? t[0] === l[0] ? n[0] + " " + a[1] : t[1] === l[1] ? n[1] + " " + a[0] : a[0] + " - " + a[1] : a }, resetExtent: function() { var t = this.option,
                    e = yL([t.min, t.max]);
                this._dataExtent = e }, getDataDimension: function(t) { var e = this.option.dimension,
                    n = t.dimensions; if (null != e || n.length) { if (null != e) return t.getDimension(e); for (var i = t.dimensions, r = i.length - 1; r >= 0; r--) { var a = i[r],
                            o = t.getDimensionInfo(a); if (!o.isCalculationCoord) return a } } }, getExtent: function() { return this._dataExtent.slice() }, completeVisualOption: function() {
                function t(t) { vL(o.color) && !t.inRange && (t.inRange = { color: o.color.slice().reverse() }), t.inRange = t.inRange || { color: a.get("gradientColor") }, mL(this.stateList, function(e) { var n = t[e]; if (w(n)) { var i = dL.get(n, "active", h);
                            i ? (t[e] = {}, t[e][n] = i) : delete t[e] } }, this) }

                function e(t, e, n) { var i = t[e],
                        r = t[n];
                    i && !r && (r = t[n] = {}, mL(i, function(t, e) { if (wP.isValidType(e)) { var n = dL.get(e, "inactive", h);
                            null != n && (r[e] = n, "color" !== e || r.hasOwnProperty("opacity") || r.hasOwnProperty("colorAlpha") || (r.opacity = [0, 0])) } })) }

                function n(t) { var e = (t.inRange || {}).symbol || (t.outOfRange || {}).symbol,
                        n = (t.inRange || {}).symbolSize || (t.outOfRange || {}).symbolSize,
                        r = this.get("inactiveColor");
                    mL(this.stateList, function(a) { var o = this.itemSize,
                            s = t[a];
                        s || (s = t[a] = { color: h ? r : [r] }), null == s.symbol && (s.symbol = e && i(e) || (h ? "roundRect" : ["roundRect"])), null == s.symbolSize && (s.symbolSize = n && i(n) || (h ? o[0] : [o[0], o[0]])), s.symbol = pL(s.symbol, function(t) { return "none" === t || "square" === t ? "roundRect" : t }); var l = s.symbolSize; if (null != l) { var u = -1 / 0;
                            gL(l, function(t) { t > u && (u = t) }), s.symbolSize = pL(l, function(t) { return xL(t, [0, u], [0, o[0]], !0) }) } }, this) } var a = this.ecModel,
                    o = this.option,
                    s = { inRange: o.inRange, outOfRange: o.outOfRange },
                    l = o.target || (o.target = {}),
                    u = o.controller || (o.controller = {});
                r(l, s), r(u, s); var h = this.isCategory();
                t.call(this, l), t.call(this, u), e.call(this, l, "inRange", "outOfRange"), n.call(this, u) }, resetItemSize: function() { this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))] }, isCategory: function() { return !!this.option.categories }, setSelected: _L, getValueState: _L, getVisualMeta: _L }),
        wL = [20, 140],
        ML = bL.extend({ type: "visualMap.continuous", defaultOption: { align: "auto", calculable: !1, range: null, realtime: !0, itemHeight: null, itemWidth: null, hoverLink: !0, hoverLinkDataSize: null, hoverLinkOnHandle: null }, optionUpdated: function() { ML.superApply(this, "optionUpdated", arguments), this.resetExtent(), this.resetVisual(function(t) { t.mappingMethod = "linear", t.dataExtent = this.getExtent() }), this._resetRange() }, resetItemSize: function() { ML.superApply(this, "resetItemSize", arguments); var t = this.itemSize; "horizontal" === this._orient && t.reverse(), (null == t[0] || isNaN(t[0])) && (t[0] = wL[0]), (null == t[1] || isNaN(t[1])) && (t[1] = wL[1]) }, _resetRange: function() { var t = this.getExtent(),
                    e = this.option.range;!e || e.auto ? (t.auto = 1, this.option.range = t) : _(e) && (e[0] > e[1] && e.reverse(), e[0] = Math.max(e[0], t[0]), e[1] = Math.min(e[1], t[1])) }, completeVisualOption: function() { bL.prototype.completeVisualOption.apply(this, arguments), f(this.stateList, function(t) { var e = this.option.controller[t].symbolSize;
                    e && e[0] !== e[1] && (e[0] = 0) }, this) }, setSelected: function(t) { this.option.range = t.slice(), this._resetRange() }, getSelected: function() { var t = this.getExtent(),
                    e = To((this.get("range") || []).slice()); return e[0] > t[1] && (e[0] = t[1]), e[1] > t[1] && (e[1] = t[1]), e[0] < t[0] && (e[0] = t[0]), e[1] < t[0] && (e[1] = t[0]), e }, getValueState: function(t) { var e = this.option.range,
                    n = this.getExtent(); return (e[0] <= n[0] || e[0] <= t) && (e[1] >= n[1] || t <= e[1]) ? "inRange" : "outOfRange" }, findTargetDataIndices: function(t) { var e = []; return this.eachTargetSeries(function(n) { var i = [],
                        r = n.getData();
                    r.each(this.getDataDimension(r), function(e, n) { t[0] <= e && e <= t[1] && i.push(n) }, this), e.push({ seriesId: n.id, dataIndex: i }) }, this), e }, getVisualMeta: function(t) {
                function e(e, n) { r.push({ value: e, color: t(e, n) }) } for (var n = Km(this, "outOfRange", this.getExtent()), i = Km(this, "inRange", this.option.range.slice()), r = [], a = 0, o = 0, s = i.length, l = n.length; l > o && (!i.length || n[o] <= i[0]); o++) n[o] < i[a] && e(n[o], "outOfRange"); for (var u = 1; s > a; a++, u = 0) u && r.length && e(i[a], "outOfRange"), e(i[a], "inRange"); for (var u = 1; l > o; o++)(!i.length || i[i.length - 1] < n[o]) && (u && (r.length && e(r[r.length - 1].value, "outOfRange"), u = 0), e(n[o], "outOfRange")); var h = r.length; return { stops: r, outerColors: [h ? r[0].color : "transparent", h ? r[h - 1].color : "transparent"] } } }),
        SL = Ou({ type: "visualMap", autoPositionValues: { left: 1, right: 1, top: 1, bottom: 1 }, init: function(t, e) { this.ecModel = t, this.api = e, this.visualMapModel }, render: function(t) { return this.visualMapModel = t, t.get("show") === !1 ? void this.group.removeAll() : void this.doRender.apply(this, arguments) }, renderBackground: function(t) { var e = this.visualMapModel,
                    n = jM(e.get("padding") || 0),
                    i = t.getBoundingRect();
                t.add(new cM({ z2: -1, silent: !0, shape: { x: i.x - n[3], y: i.y - n[0], width: i.width + n[3] + n[1], height: i.height + n[0] + n[2] }, style: { fill: e.get("backgroundColor"), stroke: e.get("borderColor"), lineWidth: e.get("borderWidth") } })) }, getControllerVisual: function(t, e, n) {
                function i(t) { return s[t] }

                function r(t, e) { s[t] = e }
                n = n || {}; var a = n.forceState,
                    o = this.visualMapModel,
                    s = {}; if ("symbol" === e && (s.symbol = o.get("itemSymbol")), "color" === e) { var l = o.get("contentColor");
                    s.color = l } var u = o.controllerVisuals[a || o.getValueState(t)],
                    h = wP.prepareVisualTypes(u); return f(h, function(a) { var o = u[a];
                    n.convertOpacityToAlpha && "opacity" === a && (a = "colorAlpha", o = u.__alphaForOpacity), wP.dependsOn(a, e) && o && o.applyVisual(t, i, r) }), s[e] }, positionGroup: function(t) { var e = this.visualMapModel,
                    n = this.api;
                Jo(t, e.getBoxLayoutParams(), { width: n.getWidth(), height: n.getHeight() }) }, doRender: F }),
        IL = Mo,
        TL = f,
        CL = Math.min,
        AL = Math.max,
        DL = 12,
        kL = 6,
        PL = SL.extend({ type: "visualMap.continuous", init: function() { PL.superApply(this, "init", arguments), this._shapes = {}, this._dataInterval = [], this._handleEnds = [], this._orient, this._useHandle, this._hoverLinkDataIndices = [], this._dragging, this._hovering }, doRender: function(t, e, n, i) { i && "selectDataRange" === i.type && i.from === this.uid || this._buildView() }, _buildView: function() { this.group.removeAll(); var t = this.visualMapModel,
                    e = this.group;
                this._orient = t.get("orient"), this._useHandle = t.get("calculable"), this._resetInterval(), this._renderBar(e); var n = t.get("text");
                this._renderEndsText(e, n, 0), this._renderEndsText(e, n, 1), this._updateView(!0), this.renderBackground(e), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(e) }, _renderEndsText: function(t, e, n) { if (e) { var i = e[1 - n];
                    i = null != i ? i + "" : ""; var r = this.visualMapModel,
                        a = r.get("textGap"),
                        o = r.itemSize,
                        s = this._shapes.barGroup,
                        l = this._applyTransform([o[0] / 2, 0 === n ? -a : o[1] + a], s),
                        u = this._applyTransform(0 === n ? "bottom" : "top", s),
                        h = this._orient,
                        c = this.visualMapModel.textStyleModel;
                    this.group.add(new Jw({ style: { x: l[0], y: l[1], textVerticalAlign: "horizontal" === h ? "middle" : u, textAlign: "horizontal" === h ? u : "center", text: i, textFont: c.getFont(), textFill: c.getTextColor() } })) } }, _renderBar: function(t) { var e = this.visualMapModel,
                    n = this._shapes,
                    i = e.itemSize,
                    r = this._orient,
                    a = this._useHandle,
                    o = $m(e, this.api, i),
                    s = n.barGroup = this._createBarGroup(o);
                s.add(n.outOfRange = Jm()), s.add(n.inRange = Jm(null, a ? ry(this._orient) : null, y(this._dragHandle, this, "all", !1), y(this._dragHandle, this, "all", !0))); var l = e.textStyleModel.getTextRect("国"),
                    u = AL(l.width, l.height);
                a && (n.handleThumbs = [], n.handleLabels = [], n.handleLabelPoints = [], this._createHandle(s, 0, i, u, r, o), this._createHandle(s, 1, i, u, r, o)), this._createIndicator(s, i, u, r), t.add(s) }, _createHandle: function(t, e, n, i, r) { var a = y(this._dragHandle, this, e, !1),
                    o = y(this._dragHandle, this, e, !0),
                    s = Jm(ty(e, i), ry(this._orient), a, o);
                s.position[0] = n[0], t.add(s); var l = this.visualMapModel.textStyleModel,
                    u = new Jw({ draggable: !0, drift: a, onmousemove: function(t) { Jx(t.event) }, ondragend: o, style: { x: 0, y: 0, text: "", textFont: l.getFont(), textFill: l.getTextColor() } });
                this.group.add(u); var h = ["horizontal" === r ? i / 2 : 1.5 * i, "horizontal" === r ? 0 === e ? -(1.5 * i) : 1.5 * i : 0 === e ? -i / 2 : i / 2],
                    c = this._shapes;
                c.handleThumbs[e] = s, c.handleLabelPoints[e] = h, c.handleLabels[e] = u }, _createIndicator: function(t, e, n, i) { var r = Jm([
                    [0, 0]
                ], "move");
                r.position[0] = e[0], r.attr({ invisible: !0, silent: !0 }), t.add(r); var a = this.visualMapModel.textStyleModel,
                    o = new Jw({ silent: !0, invisible: !0, style: { x: 0, y: 0, text: "", textFont: a.getFont(), textFill: a.getTextColor() } });
                this.group.add(o); var s = ["horizontal" === i ? n / 2 : kL + 3, 0],
                    l = this._shapes;
                l.indicator = r, l.indicatorLabel = o, l.indicatorLabelPoint = s }, _dragHandle: function(t, e, n, i) { if (this._useHandle) { if (this._dragging = !e, !e) { var r = this._applyTransform([n, i], this._shapes.barGroup, !0);
                        this._updateInterval(t, r[1]), this._updateView() }
                    e === !this.visualMapModel.get("realtime") && this.api.dispatchAction({ type: "selectDataRange", from: this.uid, visualMapId: this.visualMapModel.id, selected: this._dataInterval.slice() }), e ? !this._hovering && this._clearHoverLinkToSeries() : iy(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[t], !1) } }, _resetInterval: function() { var t = this.visualMapModel,
                    e = this._dataInterval = t.getSelected(),
                    n = t.getExtent(),
                    i = [0, t.itemSize[1]];
                this._handleEnds = [IL(e[0], n, i, !0), IL(e[1], n, i, !0)] }, _updateInterval: function(t, e) { e = e || 0; var n = this.visualMapModel,
                    i = this._handleEnds,
                    r = [0, n.itemSize[1]];
                Uk(e, i, r, t, 0); var a = n.getExtent();
                this._dataInterval = [IL(i[0], r, a, !0), IL(i[1], r, a, !0)] }, _updateView: function(t) { var e = this.visualMapModel,
                    n = e.getExtent(),
                    i = this._shapes,
                    r = [0, e.itemSize[1]],
                    a = t ? r : this._handleEnds,
                    o = this._createBarVisual(this._dataInterval, n, a, "inRange"),
                    s = this._createBarVisual(n, n, r, "outOfRange");
                i.inRange.setStyle({ fill: o.barColor, opacity: o.opacity }).setShape("points", o.barPoints), i.outOfRange.setStyle({ fill: s.barColor, opacity: s.opacity }).setShape("points", s.barPoints), this._updateHandle(a, o) }, _createBarVisual: function(t, e, n, i) { var r = { forceState: i, convertOpacityToAlpha: !0 },
                    a = this._makeColorGradient(t, r),
                    o = [this.getControllerVisual(t[0], "symbolSize", r), this.getControllerVisual(t[1], "symbolSize", r)],
                    s = this._createBarPoints(n, o); return { barColor: new xM(0, 0, 0, 1, a), barPoints: s, handlesColor: [a[0].color, a[a.length - 1].color] } }, _makeColorGradient: function(t, e) { var n = 100,
                    i = [],
                    r = (t[1] - t[0]) / n;
                i.push({ color: this.getControllerVisual(t[0], "color", e), offset: 0 }); for (var a = 1; n > a; a++) { var o = t[0] + r * a; if (o > t[1]) break;
                    i.push({ color: this.getControllerVisual(o, "color", e), offset: a / n }) } return i.push({ color: this.getControllerVisual(t[1], "color", e), offset: 1 }), i }, _createBarPoints: function(t, e) { var n = this.visualMapModel.itemSize; return [
                    [n[0] - e[0], t[0]],
                    [n[0], t[0]],
                    [n[0], t[1]],
                    [n[0] - e[1], t[1]]
                ] }, _createBarGroup: function(t) { var e = this._orient,
                    n = this.visualMapModel.get("inverse"); return new N_("horizontal" !== e || n ? "horizontal" === e && n ? { scale: "bottom" === t ? [-1, 1] : [1, 1], rotation: -Math.PI / 2 } : "vertical" !== e || n ? { scale: "left" === t ? [1, 1] : [-1, 1] } : { scale: "left" === t ? [1, -1] : [-1, -1] } : { scale: "bottom" === t ? [1, 1] : [-1, 1], rotation: Math.PI / 2 }) }, _updateHandle: function(t, e) { if (this._useHandle) { var n = this._shapes,
                        i = this.visualMapModel,
                        r = n.handleThumbs,
                        a = n.handleLabels;
                    TL([0, 1], function(o) { var s = r[o];
                        s.setStyle("fill", e.handlesColor[o]), s.position[1] = t[o]; var l = ao(n.handleLabelPoints[o], ro(s, this.group));
                        a[o].setStyle({ x: l[0], y: l[1], text: i.formatValueText(this._dataInterval[o]), textVerticalAlign: "middle", textAlign: this._applyTransform("horizontal" === this._orient ? 0 === o ? "bottom" : "top" : "left", n.barGroup) }) }, this) } }, _showIndicator: function(t, e, n, i) { var r = this.visualMapModel,
                    a = r.getExtent(),
                    o = r.itemSize,
                    s = [0, o[1]],
                    l = IL(t, a, s, !0),
                    u = this._shapes,
                    h = u.indicator; if (h) { h.position[1] = l, h.attr("invisible", !1), h.setShape("points", ey(!!n, i, l, o[1])); var c = { convertOpacityToAlpha: !0 },
                        d = this.getControllerVisual(t, "color", c);
                    h.setStyle("fill", d); var f = ao(u.indicatorLabelPoint, ro(h, this.group)),
                        p = u.indicatorLabel;
                    p.attr("invisible", !1); var g = this._applyTransform("left", u.barGroup),
                        v = this._orient;
                    p.setStyle({ text: (n ? n : "") + r.formatValueText(e), textVerticalAlign: "horizontal" === v ? g : "middle", textAlign: "horizontal" === v ? "center" : g, x: f[0], y: f[1] }) } }, _enableHoverLinkToSeries: function() { var t = this;
                this._shapes.barGroup.on("mousemove", function(e) { if (t._hovering = !0, !t._dragging) { var n = t.visualMapModel.itemSize,
                            i = t._applyTransform([e.offsetX, e.offsetY], t._shapes.barGroup, !0, !0);
                        i[1] = CL(AL(0, i[1]), n[1]), t._doHoverLinkToSeries(i[1], 0 <= i[0] && i[0] <= n[0]) } }).on("mouseout", function() { t._hovering = !1, !t._dragging && t._clearHoverLinkToSeries() }) }, _enableHoverLinkFromSeries: function() { var t = this.api.getZr();
                this.visualMapModel.option.hoverLink ? (t.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), t.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries() }, _doHoverLinkToSeries: function(t, e) { var n = this.visualMapModel,
                    i = n.itemSize; if (n.option.hoverLink) { var r = [0, i[1]],
                        a = n.getExtent();
                    t = CL(AL(r[0], t), r[1]); var o = ny(n, a, r),
                        s = [t - o, t + o],
                        l = IL(t, r, a, !0),
                        u = [IL(s[0], r, a, !0), IL(s[1], r, a, !0)];
                    s[0] < r[0] && (u[0] = -1 / 0), s[1] > r[1] && (u[1] = 1 / 0), e && (u[0] === -1 / 0 ? this._showIndicator(l, u[1], "< ", o) : 1 / 0 === u[1] ? this._showIndicator(l, u[0], "> ", o) : this._showIndicator(l, l, "≈ ", o)); var h = this._hoverLinkDataIndices,
                        c = [];
                    (e || iy(n)) && (c = this._hoverLinkDataIndices = n.findTargetDataIndices(u)); var d = ur(h, c);
                    this._dispatchHighDown("downplay", Qm(d[0], n)), this._dispatchHighDown("highlight", Qm(d[1], n)) } }, _hoverLinkFromSeriesMouseOver: function(t) { var e = t.target,
                    n = this.visualMapModel; if (e && null != e.dataIndex) { var i = this.ecModel.getSeriesByIndex(e.seriesIndex); if (n.isTargetSeries(i)) { var r = i.getData(e.dataType),
                            a = r.get(n.getDataDimension(r), e.dataIndex, !0);
                        isNaN(a) || this._showIndicator(a, a) } } }, _hideIndicator: function() { var t = this._shapes;
                t.indicator && t.indicator.attr("invisible", !0), t.indicatorLabel && t.indicatorLabel.attr("invisible", !0) }, _clearHoverLinkToSeries: function() { this._hideIndicator(); var t = this._hoverLinkDataIndices;
                this._dispatchHighDown("downplay", Qm(t, this.visualMapModel)), t.length = 0 }, _clearHoverLinkFromSeries: function() { this._hideIndicator(); var t = this.api.getZr();
                t.off("mouseover", this._hoverLinkFromSeriesMouseOver), t.off("mouseout", this._hideIndicator) }, _applyTransform: function(t, e, n, i) { var r = ro(e, i ? null : this.group); return RM[_(t) ? "applyTransform" : "transformDirection"](t, r, n) }, _dispatchHighDown: function(t, e) { e && e.length && this.api.dispatchAction({ type: t, batch: e }) }, dispose: function() { this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries() }, remove: function() { this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries() } }),
        LL = { type: "selectDataRange", event: "dataRangeSelected", update: "update" };
    Iu(LL, function(t, e) { e.eachComponent({ mainType: "visualMap", query: t }, function(e) { e.setSelected(t.selected) }) }), wu(hL); { var OL = bL.extend({ type: "visualMap.piecewise", defaultOption: { selected: null, minOpen: !1, maxOpen: !1, align: "auto", itemWidth: 20, itemHeight: 14, itemSymbol: "roundRect", pieceList: null, categories: null, splitNumber: 5, selectedMode: "multiple", itemGap: 10, hoverLink: !0, showLabel: null }, optionUpdated: function(t, e) { OL.superApply(this, "optionUpdated", arguments), this._pieceList = [], this.resetExtent(); var n = this._mode = this._determineMode();
                    zL[this._mode].call(this), this._resetSelected(t, e); var r = this.option.categories;
                    this.resetVisual(function(t, e) { "categories" === n ? (t.mappingMethod = "category", t.categories = i(r)) : (t.dataExtent = this.getExtent(), t.mappingMethod = "piecewise", t.pieceList = p(this._pieceList, function(t) { var t = i(t); return "inRange" !== e && (t.visual = null), t })) }) }, completeVisualOption: function() {
                    function t(t, e, n) { return t && t[e] && (M(t[e]) ? t[e].hasOwnProperty(n) : t[e] === n) } var e = this.option,
                        n = {},
                        i = wP.listVisualTypes(),
                        r = this.isCategory();
                    f(e.pieces, function(t) { f(i, function(e) { t.hasOwnProperty(e) && (n[e] = 1) }) }), f(n, function(n, i) { var a = 0;
                        f(this.stateList, function(n) { a |= t(e, n, i) || t(e.target, n, i) }, this), !a && f(this.stateList, function(t) {
                            (e[t] || (e[t] = {}))[i] = dL.get(i, "inRange" === t ? "active" : "inactive", r) }) }, this), bL.prototype.completeVisualOption.apply(this, arguments) }, _resetSelected: function(t, e) { var n = this.option,
                        i = this._pieceList,
                        r = (e ? n : t).selected || {}; if (n.selected = r, f(i, function(t) { var e = this.getSelectedMapKey(t);
                            r.hasOwnProperty(e) || (r[e] = !0) }, this), "single" === n.selectedMode) { var a = !1;
                        f(i, function(t) { var e = this.getSelectedMapKey(t);
                            r[e] && (a ? r[e] = !1 : a = !0) }, this) } }, getSelectedMapKey: function(t) { return "categories" === this._mode ? t.value + "" : t.index + "" }, getPieceList: function() { return this._pieceList }, _determineMode: function() { var t = this.option; return t.pieces && t.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber" }, setSelected: function(t) { this.option.selected = i(t) }, getValueState: function(t) { var e = wP.findPieceIndex(t, this._pieceList); return null != e && this.option.selected[this.getSelectedMapKey(this._pieceList[e])] ? "inRange" : "outOfRange" }, findTargetDataIndices: function(t) { var e = []; return this.eachTargetSeries(function(n) { var i = [],
                            r = n.getData();
                        r.each(this.getDataDimension(r), function(e, n) { var r = wP.findPieceIndex(e, this._pieceList);
                            r === t && i.push(n) }, this), e.push({ seriesId: n.id, dataIndex: i }) }, this), e }, getRepresentValue: function(t) { var e; if (this.isCategory()) e = t.value;
                    else if (null != t.value) e = t.value;
                    else { var n = t.interval || [];
                        e = n[0] === -1 / 0 && 1 / 0 === n[1] ? 0 : (n[0] + n[1]) / 2 } return e }, getVisualMeta: function(t) {
                    function e(e, a) { var o = r.getRepresentValue({ interval: e });
                        a || (a = r.getValueState(o)); var s = t(o, a);
                        e[0] === -1 / 0 ? i[0] = s : 1 / 0 === e[1] ? i[1] = s : n.push({ value: e[0], color: s }, { value: e[1], color: s }) } if (!this.isCategory()) { var n = [],
                            i = [],
                            r = this,
                            a = this._pieceList.slice(); if (a.length) { var o = a[0].interval[0];
                            o !== -1 / 0 && a.unshift({ interval: [-1 / 0, o] }), o = a[a.length - 1].interval[1], 1 / 0 !== o && a.push({ interval: [o, 1 / 0] }) } else a.push({ interval: [-1 / 0, 1 / 0] }); var s = -1 / 0; return f(a, function(t) { var n = t.interval;
                            n && (n[0] > s && e([s, n[0]], "outOfRange"), e(n.slice()), s = n[1]) }, this), { stops: n, outerColors: i } } } }),
            zL = { splitNumber: function() { var t = this.option,
                        e = this._pieceList,
                        n = Math.min(t.precision, 20),
                        i = this.getExtent(),
                        r = t.splitNumber;
                    r = Math.max(parseInt(r, 10), 1), t.splitNumber = r; for (var a = (i[1] - i[0]) / r; + a.toFixed(n) !== a && 5 > n;) n++;
                    t.precision = n, a = +a.toFixed(n); var o = 0;
                    t.minOpen && e.push({ index: o++, interval: [-1 / 0, i[0]], close: [0, 0] }); for (var s = i[0], l = o + r; l > o; s += a) { var u = o === r - 1 ? i[1] : s + a;
                        e.push({ index: o++, interval: [s, u], close: [1, 1] }) }
                    t.maxOpen && e.push({ index: o++, interval: [i[1], 1 / 0], close: [0, 0] }), No(e), f(e, function(t) { t.text = this.formatValueText(t.interval) }, this) }, categories: function() { var t = this.option;
                    f(t.categories, function(t) { this._pieceList.push({ text: this.formatValueText(t, !0), value: t }) }, this), ay(t, this._pieceList) }, pieces: function() { var t = this.option,
                        e = this._pieceList;
                    f(t.pieces, function(t, n) { M(t) || (t = { value: t }); var i = { text: "", index: n }; if (null != t.label && (i.text = t.label), t.hasOwnProperty("value")) { var r = i.value = t.value;
                            i.interval = [r, r], i.close = [1, 1] } else { for (var a = i.interval = [], o = i.close = [0, 0], s = [1, 0, 1], l = [-1 / 0, 1 / 0], u = [], h = 0; 2 > h; h++) { for (var c = [
                                        ["gte", "gt", "min"],
                                        ["lte", "lt", "max"]
                                    ][h], d = 0; 3 > d && null == a[h]; d++) a[h] = t[c[d]], o[h] = s[d], u[h] = 2 === d;
                                null == a[h] && (a[h] = l[h]) }
                            u[0] && 1 / 0 === a[1] && (o[0] = 0), u[1] && a[0] === -1 / 0 && (o[1] = 0), a[0] === a[1] && o[0] && o[1] && (i.value = a[0]) }
                        i.visual = wP.retrieveVisuals(t), e.push(i) }, this), ay(t, e), No(e), f(e, function(t) { var e = t.close,
                            n = [
                                ["<", "≤"][e[1]],
                                [">", "≥"][e[0]]
                            ];
                        t.text = t.text || this.formatValueText(null != t.value ? t.value : t.interval, !1, n) }, this) } };
        SL.extend({ type: "visualMap.piecewise", doRender: function() {
                function t(t) { var r = t.piece,
                        u = new N_;
                    u.onclick = y(this._onItemClick, this, r), this._enableHoverLink(u, t.indexInModelPieceList); var h = n.getRepresentValue(r); if (this._createItemSymbol(u, h, [0, 0, l[0], l[1]]), c) { var d = this.visualMapModel.getValueState(h);
                        u.add(new Jw({ style: { x: "right" === s ? -i : l[0] + i, y: l[1] / 2, text: r.text, textVerticalAlign: "middle", textAlign: s, textFont: a, textFill: o, opacity: "outOfRange" === d ? .5 : 1 } })) }
                    e.add(u) } var e = this.group;
                e.removeAll(); var n = this.visualMapModel,
                    i = n.get("textGap"),
                    r = n.textStyleModel,
                    a = r.getFont(),
                    o = r.getTextColor(),
                    s = this._getItemAlign(),
                    l = n.itemSize,
                    u = this._getViewData(),
                    h = u.endsText,
                    c = A(n.get("showLabel", !0), !h);
                h && this._renderEndsText(e, h[0], l, c, s), f(u.viewPieceList, t, this), h && this._renderEndsText(e, h[1], l, c, s), rS(n.get("orient"), e, n.get("itemGap")), this.renderBackground(e), this.positionGroup(e) }, _enableHoverLink: function(t, e) {
                function n(t) { var n = this.visualMapModel;
                    n.option.hoverLink && this.api.dispatchAction({ type: t, batch: Qm(n.findTargetDataIndices(e), n) }) }
                t.on("mouseover", y(n, this, "highlight")).on("mouseout", y(n, this, "downplay")) }, _getItemAlign: function() { var t = this.visualMapModel,
                    e = t.option; if ("vertical" === e.orient) return $m(t, this.api, t.itemSize); var n = e.align; return n && "auto" !== n || (n = "left"), n }, _renderEndsText: function(t, e, n, i, r) { if (e) { var a = new N_,
                        o = this.visualMapModel.textStyleModel;
                    a.add(new Jw({ style: { x: i ? "right" === r ? n[0] : 0 : n[0] / 2, y: n[1] / 2, textVerticalAlign: "middle", textAlign: i ? r : "center", text: e, textFont: o.getFont(), textFill: o.getTextColor() } })), t.add(a) } }, _getViewData: function() { var t = this.visualMapModel,
                    e = p(t.getPieceList(), function(t, e) { return { piece: t, indexInModelPieceList: e } }),
                    n = t.get("text"),
                    i = t.get("orient"),
                    r = t.get("inverse"); return ("horizontal" === i ? r : !r) ? e.reverse() : n && (n = n.slice().reverse()), { viewPieceList: e, endsText: n } }, _createItemSymbol: function(t, e, n) { t.add($h(this.getControllerVisual(e, "symbol"), n[0], n[1], n[2], n[3], this.getControllerVisual(e, "color"))) }, _onItemClick: function(t) { var e = this.visualMapModel,
                    n = e.option,
                    r = i(n.selected),
                    a = e.getSelectedMapKey(t); "single" === n.selectedMode ? (r[a] = !0, f(r, function(t, e) { r[e] = e === a })) : r[a] = !r[a], this.api.dispatchAction({ type: "selectDataRange", from: this.uid, visualMapId: this.visualMapModel.id, selected: r }) } }) }
    wu(hL);
    var EL = Lu({ type: "toolbox", layoutMode: { type: "box", ignoreSize: !0 }, optionUpdated: function() { EL.superApply(this, "optionUpdated", arguments), f(this.option.feature, function(t, e) { var n = Xm(e);
                n && r(t, n.defaultOption) }) }, defaultOption: { show: !0, z: 6, zlevel: 0, orient: "horizontal", left: "right", top: "top", backgroundColor: "transparent", borderColor: "#ccc", borderRadius: 0, borderWidth: 0, padding: 5, itemSize: 15, itemGap: 8, showTitle: !0, iconStyle: { borderColor: "#666", color: "none" }, emphasis: { iconStyle: { borderColor: "#3E98C5" } }, tooltip: { show: !1 } } });
    Ou({ type: "toolbox", render: function(t, e, n, i) {
            function r(r, o) { var s, l = c[r],
                    d = c[o],
                    f = u[l],
                    p = new vo(f, t, t.ecModel); if (i && null != i.newTitle && (f.title = i.newTitle), l && !d) { if (oy(l)) s = { model: p, onclick: p.option.onclick, featureName: l };
                    else { var g = Xm(l); if (!g) return;
                        s = new g(p, e, n) }
                    h[l] = s } else { if (s = h[d], !s) return;
                    s.model = p, s.ecModel = e, s.api = n } return !l && d ? void(s.dispose && s.dispose(e, n)) : !p.get("show") || s.unusable ? void(s.remove && s.remove(e, n)) : (a(p, s, l), p.setIconStatus = function(t, e) { var n = this.option,
                        i = this.iconPaths;
                    n.iconStatus = n.iconStatus || {}, n.iconStatus[t] = e, i[t] && i[t].trigger(e) }, void(s.render && s.render(p, e, n, i))) }

            function a(i, r, a) { var u = i.getModel("iconStyle"),
                    h = i.getModel("emphasis.iconStyle"),
                    c = r.getIcons ? r.getIcons() : i.get("icon"),
                    d = i.get("title") || {}; if ("string" == typeof c) { var p = c,
                        g = d;
                    c = {}, d = {}, c[a] = p, d[a] = g } var v = i.iconPaths = {};
                f(c, function(a, c) { var f = ho(a, {}, { x: -l / 2, y: -l / 2, width: l, height: l });
                    f.setStyle(u.getItemStyle()), f.hoverStyle = h.getItemStyle(), f.setStyle({ text: d[c], textAlign: h.get("textAlign"), textBorderRadius: h.get("textBorderRadius"), textPadding: h.get("textPadding"), textFill: null }); var p = t.getModel("tooltip");
                    p && p.get("show") && f.attr("tooltip", o({ content: d[c], formatter: p.get("formatter", !0) || function() { return d[c] }, formatterParams: { componentType: "toolbox", name: c, title: d[c], $vars: ["name", "title"] }, position: p.get("position", !0) || "bottom" }, p.option)), Fa(f), t.get("showTitle") && (f.__title = d[c], f.on("mouseover", function() { var e = h.getItemStyle(),
                            n = "vertical" === t.get("orient") ? null == t.get("right") ? "right" : "left" : null == t.get("bottom") ? "bottom" : "top";
                        f.setStyle({ textFill: h.get("textFill") || e.fill || e.stroke || "#000", textBackgroundColor: h.get("textBackgroundColor"), textPosition: h.get("textPosition") || n }) }).on("mouseout", function() { f.setStyle({ textFill: null, textBackgroundColor: null }) })), f.trigger(i.get("iconStatus." + c) || "normal"), s.add(f), f.on("click", y(r.onclick, r, e, n, c)), v[c] = f }) } var s = this.group; if (s.removeAll(), t.get("show")) { var l = +t.get("itemSize"),
                    u = t.get("feature") || {},
                    h = this._features || (this._features = {}),
                    c = [];
                f(u, function(t, e) { c.push(e) }), new Fu(this._featureNames || [], c).add(r).update(r).remove(x(r, null)).execute(), this._featureNames = c, Ip(s, t, n), s.add(Tp(s.getBoundingRect(), t)), s.eachChild(function(t) { var e = t.__title,
                        i = t.hoverStyle; if (i && e) { var r = Yn(e, li(i)),
                            a = t.position[0] + s.position[0],
                            o = t.position[1] + s.position[1] + l,
                            u = !1;
                        o + r.height > n.getHeight() && (i.textPosition = "top", u = !0); var h = u ? -5 - r.height : l + 8;
                        a + r.width / 2 > n.getWidth() ? (i.textPosition = ["100%", h], i.textAlign = "right") : a - r.width / 2 < 0 && (i.textPosition = [0, h], i.textAlign = "left") } }) } }, updateView: function(t, e, n, i) { f(this._features, function(t) { t.updateView && t.updateView(t.model, e, n, i) }) }, remove: function(t, e) { f(this._features, function(n) { n.remove && n.remove(t, e) }), this.group.removeAll() }, dispose: function(t, e) { f(this._features, function(n) { n.dispose && n.dispose(t, e) }) } });
    var RL = oI.toolbox.saveAsImage;
    sy.defaultOption = { show: !0, icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0", title: RL.title, type: "png", connectedBackgroundColor: "#fff", name: "", excludeComponents: ["toolbox"], pixelRatio: 1, lang: RL.lang.slice() }, sy.prototype.unusable = !Sx.canvasSupported;
    var BL = sy.prototype;
    BL.onclick = function(t, e) { var n = this.model,
            i = n.get("name") || t.get("title.0.text") || "echarts",
            r = n.get("type", !0) || "png",
            a = e.getConnectedDataURL({ type: r, backgroundColor: n.get("backgroundColor", !0) || t.get("backgroundColor") || "#fff", connectedBackgroundColor: n.get("connectedBackgroundColor"), excludeComponents: n.get("excludeComponents"), pixelRatio: n.get("pixelRatio") }); if ("function" != typeof MouseEvent || Sx.browser.ie || Sx.browser.edge)
            if (window.navigator.msSaveOrOpenBlob) { for (var o = atob(a.split(",")[1]), s = o.length, l = new Uint8Array(s); s--;) l[s] = o.charCodeAt(s); var u = new Blob([l]);
                window.navigator.msSaveOrOpenBlob(u, i + "." + r) } else { var h = n.get("lang"),
                    c = '<body style="margin:0;"><img src="' + a + '" style="max-width:100%;" title="' + (h && h[0] || "") + '" /></body>',
                    d = window.open();
                d.document.write(c) }
        else { var f = document.createElement("a");
            f.download = i + "." + r, f.target = "_blank", f.href = a; var p = new MouseEvent("click", { view: window, bubbles: !0, cancelable: !1 });
            f.dispatchEvent(p) } }, Um("saveAsImage", sy);
    var NL = oI.toolbox.magicType,
        VL = "__ec_magicType_stack__";
    ly.defaultOption = { show: !0, type: [], icon: { line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4", bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7", stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z" }, title: i(NL.title), option: {}, seriesIndex: {} };
    var FL = ly.prototype;
    FL.getIcons = function() { var t = this.model,
            e = t.get("icon"),
            n = {}; return f(t.get("type"), function(t) { e[t] && (n[t] = e[t]) }), n };
    var HL = { line: function(t, e, n, i) { return "bar" === t ? r({ id: e, type: "line", data: n.get("data"), stack: n.get("stack"), markPoint: n.get("markPoint"), markLine: n.get("markLine") }, i.get("option.line") || {}, !0) : void 0 }, bar: function(t, e, n, i) { return "line" === t ? r({ id: e, type: "bar", data: n.get("data"), stack: n.get("stack"), markPoint: n.get("markPoint"), markLine: n.get("markLine") }, i.get("option.bar") || {}, !0) : void 0 }, stack: function(t, e, n, i) { var a = n.get("stack") === VL; return "line" === t || "bar" === t ? (i.setIconStatus("stack", a ? "normal" : "emphasis"), r({ id: e, stack: a ? "" : VL }, i.get("option.stack") || {}, !0)) : void 0 } },
        GL = [
            ["line", "bar"],
            ["stack"]
        ];
    FL.onclick = function(t, e, n) { var a = this.model,
            o = a.get("seriesIndex." + n); if (HL[n]) { var l = { series: [] },
                h = function(e) { var i = e.subType,
                        r = e.id,
                        o = HL[n](i, r, e, a);
                    o && (s(o, e.option), l.series.push(o)); var u = e.coordinateSystem; if (u && "cartesian2d" === u.type && ("line" === n || "bar" === n)) { var h = u.getAxesByScale("ordinal")[0]; if (h) { var c = h.dim,
                                d = c + "Axis",
                                f = t.queryComponents({ mainType: d, index: e.get(name + "Index"), id: e.get(name + "Id") })[0],
                                p = f.componentIndex;
                            l[d] = l[d] || []; for (var g = 0; p >= g; g++) l[d][p] = l[d][p] || {};
                            l[d][p].boundaryGap = "bar" === n } } };
            f(GL, function(t) { u(t, n) >= 0 && f(t, function(t) { a.setIconStatus(t, "normal") }) }), a.setIconStatus(n, "emphasis"), t.eachComponent({ mainType: "series", query: null == o ? null : { seriesIndex: o } }, h); var c; if ("stack" === n) { var d = l.series && l.series[0] && l.series[0].stack === VL;
                c = d ? r({ stack: NL.title.tiled }, NL.title) : i(NL.title) }
            e.dispatchAction({ type: "changeMagicType", currentType: n, newOption: l, newTitle: c }) } }, Iu({ type: "changeMagicType", event: "magicTypeChanged", update: "prepareAndUpdate" }, function(t, e) { e.mergeOption(t.newOption) }), Um("magicType", ly);
    var WL = oI.toolbox.dataView,
        ZL = new Array(60).join("-"),
        UL = "    ",
        XL = new RegExp("[" + UL + "]+", "g");
    yy.defaultOption = { show: !0, readOnly: !1, optionToContent: null, contentToOption: null, icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28", title: i(WL.title), lang: i(WL.lang), backgroundColor: "#fff", textColor: "#000", textareaColor: "#fff", textareaBorderColor: "#333", buttonColor: "#c23531", buttonTextColor: "#fff" }, yy.prototype.onclick = function(t, e) {
        function n() { i.removeChild(a), x._dom = null } var i = e.getDom(),
            r = this.model;
        this._dom && i.removeChild(this._dom); var a = document.createElement("div");
        a.style.cssText = "position:absolute;left:5px;top:5px;bottom:5px;right:5px;", a.style.backgroundColor = r.get("backgroundColor") || "#fff"; var o = document.createElement("h4"),
            s = r.get("lang") || [];
        o.innerHTML = s[0] || r.get("title"), o.style.cssText = "margin: 10px 20px;", o.style.color = r.get("textColor"); var l = document.createElement("div"),
            u = document.createElement("textarea");
        l.style.cssText = "display:block;width:100%;overflow:auto;"; var h = r.get("optionToContent"),
            c = r.get("contentToOption"),
            d = dy(t); if ("function" == typeof h) { var f = h(e.getOption()); "string" == typeof f ? l.innerHTML = f : T(f) && l.appendChild(f) } else l.appendChild(u), u.readOnly = r.get("readOnly"), u.style.cssText = "width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;", u.style.color = r.get("textColor"), u.style.borderColor = r.get("textareaBorderColor"), u.style.backgroundColor = r.get("textareaColor"), u.value = d.value; var p = d.meta,
            g = document.createElement("div");
        g.style.cssText = "position:absolute;bottom:0;left:0;right:0;"; var v = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px",
            m = document.createElement("div"),
            y = document.createElement("div");
        v += ";background-color:" + r.get("buttonColor"), v += ";color:" + r.get("buttonTextColor"); var x = this;
        Me(m, "click", n), Me(y, "click", function() { var t; try { t = "function" == typeof c ? c(l, e.getOption()) : my(u.value, p) } catch (i) { throw n(), new Error("Data view format error " + i) }
            t && e.dispatchAction({ type: "changeDataView", newOption: t }), n() }), m.innerHTML = s[1], y.innerHTML = s[2], y.style.cssText = v, m.style.cssText = v, !r.get("readOnly") && g.appendChild(y), g.appendChild(m), a.appendChild(o), a.appendChild(l), a.appendChild(g), l.style.height = i.clientHeight - 80 + "px", i.appendChild(a), this._dom = a }, yy.prototype.remove = function(t, e) { this._dom && e.getDom().removeChild(this._dom) }, yy.prototype.dispose = function(t, e) { this.remove(t, e) }, Um("dataView", yy), Iu({ type: "changeDataView", event: "dataViewChanged", update: "prepareAndUpdate" }, function(t, e) { var n = [];
        f(t.newOption.series, function(t) { var i = e.getSeriesByName(t.name)[0]; if (i) { var r = i.get("data");
                n.push({ name: t.name, data: xy(t.data, r) }) } else n.push(o({ type: "scatter" }, t)) }), e.mergeOption(s({ series: n }, t.newOption)) });
    var YL = f,
        jL = "\x00_ec_hist_store";
    $k.extend({ type: "dataZoom.select" }), Qk.extend({ type: "dataZoom.select" });
    var qL = oI.toolbox.dataZoom,
        KL = f,
        $L = "\x00_ec_\x00toolbox-dataZoom_";
    Iy.defaultOption = { show: !0, filterMode: "filter", icon: { zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1", back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26" }, title: i(qL.title) };
    var QL = Iy.prototype;
    QL.render = function(t, e, n, i) { this.model = t, this.ecModel = e, this.api = n, Ay(t, e, this, i, n), Cy(t, e) }, QL.onclick = function(t, e, n) { JL[n].call(this) }, QL.remove = function() { this._brushController.unmount() }, QL.dispose = function() { this._brushController.dispose() };
    var JL = { zoom: function() { var t = !this._isZoomActive;
            this.api.dispatchAction({ type: "takeGlobalCursor", key: "dataZoomSelect", dataZoomSelectActive: t }) }, back: function() { this._dispatchZoomAction(by(this.ecModel)) } };
    QL._onBrush = function(t, e) {
        function n(t, e, n) { var o = e.getAxis(t),
                s = o.model,
                l = i(t, s, a),
                u = l.findRepresentativeAxisProxy(s).getMinMaxSpan();
            (null != u.minValueSpan || null != u.maxValueSpan) && (n = Uk(0, n.slice(), o.scale.getExtent(), 0, u.minValueSpan, u.maxValueSpan)), l && (r[l.id] = { dataZoomId: l.id, startValue: n[0], endValue: n[1] }) }

        function i(t, e, n) { var i; return n.eachComponent({ mainType: "dataZoom", subType: "select" }, function(n) { var r = n.getAxisModel(t, e.componentIndex);
                r && (i = n) }), i } if (e.isEnd && t.length) { var r = {},
                a = this.ecModel;
            this._brushController.updateCovers([]); var o = new Zv(Ty(this.model.option), a, { include: ["grid"] });
            o.matchOutputRanges(t, a, function(t, e, i) { if ("cartesian2d" === i.type) { var r = t.brushType; "rect" === r ? (n("x", i, e[0]), n("y", i, e[1])) : n({ lineX: "x", lineY: "y" }[r], i, e) } }), _y(a, r), this._dispatchZoomAction(r) } }, QL._dispatchZoomAction = function(t) { var e = [];
        KL(t, function(t) { e.push(i(t)) }), e.length && this.api.dispatchAction({ type: "dataZoom", from: this.uid, batch: e }) }, Um("dataZoom", Iy), wu(function(t) {
        function e(t, e) { if (e) { var r = t + "Index",
                    a = e[r];
                null == a || "all" === a || _(a) || (a = a === !1 || "none" === a ? [] : [a]), n(t, function(n, o) { if (null == a || "all" === a || -1 !== u(a, o)) { var s = { type: "select", $fromToolbox: !0, filterMode: e.filterMode || "filter", id: $L + t + o };
                        s[r] = o, i.push(s) } }) } }

        function n(e, n) { var i = t[e];
            _(i) || (i = i ? [i] : []), KL(i, n) } if (t) { var i = t.dataZoom || (t.dataZoom = []);
            _(i) || (t.dataZoom = i = [i]); var r = t.toolbox; if (r && (_(r) && (r = r[0]), r && r.feature)) { var a = r.feature.dataZoom;
                e("xAxis", a), e("yAxis", a) } } });
    var tO = oI.toolbox.restore;
    Dy.defaultOption = { show: !0, icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5", title: tO.title };
    var eO = Dy.prototype;
    eO.onclick = function(t, e) { wy(t), e.dispatchAction({ type: "restore", from: this.uid }) }, Um("restore", Dy), Iu({ type: "restore", event: "restore", update: "prepareAndUpdate" }, function(t, e) { e.resetOption("recreate") });
    var nO = { path: null, compoundPath: null, group: N_, image: Di, text: Jw };
    wu(function(t) { var e = t.graphic;
        _(e) ? t.graphic = e[0] && e[0].elements ? [t.graphic[0]] : [{ elements: e }] : e && !e.elements && (t.graphic = [{ elements: [e] }]) });
    var iO = Lu({ type: "graphic", defaultOption: { elements: [], parentId: null }, _elOptionsToUpdate: null, mergeOption: function() { var t = this.option.elements;
            this.option.elements = null, iO.superApply(this, "mergeOption", arguments), this.option.elements = t }, optionUpdated: function(t, e) { var n = this.option,
                i = (e ? n : t).elements,
                r = n.elements = e ? [] : n.elements,
                a = [];
            this._flatten(i, a); var o = ar(r, a);
            or(o); var s = this._elOptionsToUpdate = [];
            f(o, function(t, e) { var n = t.option;
                n && (s.push(n), zy(t, n), Ey(r, e, n), Ry(r[e], n)) }, this); for (var l = r.length - 1; l >= 0; l--) null == r[l] ? r.splice(l, 1) : delete r[l].$action }, _flatten: function(t, e, n) { f(t, function(t) { if (t) { n && (t.parentOption = n), e.push(t); var i = t.children; "group" === t.type && i && this._flatten(i, e, t), delete t.children } }, this) }, useElOptionsToUpdate: function() { var t = this._elOptionsToUpdate; return this._elOptionsToUpdate = null, t } });
    Ou({ type: "graphic", init: function() { this._elMap = N(), this._lastGraphicModel }, render: function(t, e, n) { t !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = t, this._updateElements(t), this._relocate(t, n) }, _updateElements: function(t) { var e = t.useElOptionsToUpdate(); if (e) { var n = this._elMap,
                    i = this.group;
                f(e, function(e) { var r = e.$action,
                        a = e.id,
                        o = n.get(a),
                        s = e.parentId,
                        l = null != s ? n.get(s) : i,
                        u = e.style; "text" === e.type && u && (e.hv && e.hv[1] && (u.textVerticalAlign = u.textBaseline = null), !u.hasOwnProperty("textFill") && u.fill && (u.textFill = u.fill), !u.hasOwnProperty("textStroke") && u.stroke && (u.textStroke = u.stroke)); var h = Ly(e);
                    r && "merge" !== r ? "replace" === r ? (Py(o, n), ky(a, l, h, n)) : "remove" === r && Py(o, n) : o ? o.attr(h) : ky(a, l, h, n); var c = n.get(a);
                    c && (c.__ecGraphicWidthOption = e.width, c.__ecGraphicHeightOption = e.height, By(c, t, e)) }) } }, _relocate: function(t, e) { for (var n = t.option.elements, i = this.group, r = this._elMap, a = e.getWidth(), o = e.getHeight(), s = 0; s < n.length; s++) { var l = n[s],
                    u = r.get(l.id); if (u && u.isGroup) { var h = u.parent,
                        c = h === i;
                    u.__ecGraphicWidth = So(u.__ecGraphicWidthOption, c ? a : h.__ecGraphicWidth) || 0, u.__ecGraphicHeight = So(u.__ecGraphicHeightOption, c ? o : h.__ecGraphicHeight) || 0 } } for (var s = n.length - 1; s >= 0; s--) { var l = n[s],
                    u = r.get(l.id); if (u) { var h = u.parent,
                        d = h === i ? { width: a, height: o } : { width: h.__ecGraphicWidth, height: h.__ecGraphicHeight };
                    Jo(u, l, d, null, { hv: l.hv, boundingMode: l.bounding }) } } }, _clear: function() { var t = this._elMap;
            t.each(function(e) { Py(e, t) }), this._elMap = N() }, dispose: function() { this._clear() } });
    var rO, aO = "urn:schemas-microsoft-com:vml",
        oO = "undefined" == typeof window ? null : window,
        sO = !1,
        lO = oO && oO.document;
    if (lO && !Sx.canvasSupported) try {!lO.namespaces.zrvml && lO.namespaces.add("zrvml", aO), rO = function(t) { return lO.createElement("<zrvml:" + t + ' class="zrvml">') } } catch (uO) { rO = function(t) { return lO.createElement("<" + t + ' xmlns="' + aO + '" class="zrvml">') } }
    var hO = Aw.CMD,
        cO = Math.round,
        dO = Math.sqrt,
        fO = Math.abs,
        pO = Math.cos,
        gO = Math.sin,
        vO = Math.max;
    if (!Sx.canvasSupported) { var mO = ",",
            yO = "progid:DXImageTransform.Microsoft",
            xO = 21600,
            _O = xO / 2,
            bO = 1e5,
            wO = 1e3,
            MO = function(t) { t.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px;", t.coordsize = xO + "," + xO, t.coordorigin = "0,0" },
            SO = function(t) { return String(t).replace(/&/g, "&amp;").replace(/"/g, "&quot;") },
            IO = function(t, e, n) { return "rgb(" + [t, e, n].join(",") + ")" },
            TO = function(t, e) { e && t && e.parentNode !== t && t.appendChild(e) },
            CO = function(t, e) { e && t && e.parentNode === t && t.removeChild(e) },
            AO = function(t, e, n) { return (parseFloat(t) || 0) * bO + (parseFloat(e) || 0) * wO + n },
            DO = Ii,
            kO = function(t, e, n) { var i = tn(e);
                n = +n, isNaN(n) && (n = 1), i && (t.color = IO(i[0], i[1], i[2]), t.opacity = n * i[3]) },
            PO = function(t) { var e = tn(t); return [IO(e[0], e[1], e[2]), e[3]] },
            LO = function(t, e, n) { var i = e.fill; if (null != i)
                    if (i instanceof yM) { var r, a = 0,
                            o = [0, 0],
                            s = 0,
                            l = 1,
                            u = n.getBoundingRect(),
                            h = u.width,
                            c = u.height; if ("linear" === i.type) { r = "gradient"; var d = n.transform,
                                f = [i.x * h, i.y * c],
                                p = [i.x2 * h, i.y2 * c];
                            d && (ae(f, f, d), ae(p, p, d)); var g = p[0] - f[0],
                                v = p[1] - f[1];
                            a = 180 * Math.atan2(g, v) / Math.PI, 0 > a && (a += 360), 1e-6 > a && (a = 0) } else { r = "gradientradial"; var f = [i.x * h, i.y * c],
                                d = n.transform,
                                m = n.scale,
                                y = h,
                                x = c;
                            o = [(f[0] - u.x) / y, (f[1] - u.y) / x], d && ae(f, f, d), y /= m[0] * xO, x /= m[1] * xO; var _ = vO(y, x);
                            s = 0 / _, l = 2 * i.r / _ - s } var b = i.colorStops.slice();
                        b.sort(function(t, e) { return t.offset - e.offset }); for (var w = b.length, M = [], S = [], I = 0; w > I; I++) { var T = b[I],
                                C = PO(T.color);
                            S.push(T.offset * l + s + " " + C[0]), (0 === I || I === w - 1) && M.push(C) } if (w >= 2) { var A = M[0][0],
                                D = M[1][0],
                                k = M[0][1] * e.opacity,
                                P = M[1][1] * e.opacity;
                            t.type = r, t.method = "none", t.focus = "100%", t.angle = a, t.color = A, t.color2 = D, t.colors = S.join(","), t.opacity = P, t.opacity2 = k } "radial" === r && (t.focusposition = o.join(",")) } else kO(t, i, e.opacity) },
            OO = function(t, e) { e.lineDash && (t.dashstyle = e.lineDash.join(" ")), null == e.stroke || e.stroke instanceof yM || kO(t, e.stroke, e.opacity) },
            zO = function(t, e, n, i) { var r = "fill" === e,
                    a = t.getElementsByTagName(e)[0];
                null != n[e] && "none" !== n[e] && (r || !r && n.lineWidth) ? (t[r ? "filled" : "stroked"] = "true", n[e] instanceof yM && CO(t, a), a || (a = Ny(e)), r ? LO(a, n, i) : OO(a, n), TO(t, a)) : (t[r ? "filled" : "stroked"] = "false", CO(t, a)) },
            EO = [
                [],
                [],
                []
            ],
            RO = function(t, e) { var n, i, r, a, o, s, l = hO.M,
                    u = hO.C,
                    h = hO.L,
                    c = hO.A,
                    d = hO.Q,
                    f = [],
                    p = t.data,
                    g = t.len(); for (a = 0; g > a;) { switch (r = p[a++], i = "", n = 0, r) {
                        case l:
                            i = " m ", n = 1, o = p[a++], s = p[a++], EO[0][0] = o, EO[0][1] = s; break;
                        case h:
                            i = " l ", n = 1, o = p[a++], s = p[a++], EO[0][0] = o, EO[0][1] = s; break;
                        case d:
                        case u:
                            i = " c ", n = 3; var v, m, y = p[a++],
                                x = p[a++],
                                _ = p[a++],
                                b = p[a++];
                            r === d ? (v = _, m = b, _ = (_ + 2 * y) / 3, b = (b + 2 * x) / 3, y = (o + 2 * y) / 3, x = (s + 2 * x) / 3) : (v = p[a++], m = p[a++]), EO[0][0] = y, EO[0][1] = x, EO[1][0] = _, EO[1][1] = b, EO[2][0] = v, EO[2][1] = m, o = v, s = m; break;
                        case c:
                            var w = 0,
                                M = 0,
                                S = 1,
                                I = 1,
                                T = 0;
                            e && (w = e[4], M = e[5], S = dO(e[0] * e[0] + e[1] * e[1]), I = dO(e[2] * e[2] + e[3] * e[3]), T = Math.atan2(-e[1] / I, e[0] / S)); var C = p[a++],
                                A = p[a++],
                                D = p[a++],
                                k = p[a++],
                                P = p[a++] + T,
                                L = p[a++] + P + T;
                            a++; var O = p[a++],
                                z = C + pO(P) * D,
                                E = A + gO(P) * k,
                                y = C + pO(L) * D,
                                x = A + gO(L) * k,
                                R = O ? " wa " : " at ";
                            Math.abs(z - y) < 1e-4 && (Math.abs(L - P) > .01 ? O && (z += 270 / xO) : Math.abs(E - A) < 1e-4 ? O && C > z || !O && z > C ? x -= 270 / xO : x += 270 / xO : O && A > E || !O && E > A ? y += 270 / xO : y -= 270 / xO), f.push(R, cO(((C - D) * S + w) * xO - _O), mO, cO(((A - k) * I + M) * xO - _O), mO, cO(((C + D) * S + w) * xO - _O), mO, cO(((A + k) * I + M) * xO - _O), mO, cO((z * S + w) * xO - _O), mO, cO((E * I + M) * xO - _O), mO, cO((y * S + w) * xO - _O), mO, cO((x * I + M) * xO - _O)), o = y, s = x; break;
                        case hO.R:
                            var B = EO[0],
                                N = EO[1];
                            B[0] = p[a++], B[1] = p[a++], N[0] = B[0] + p[a++], N[1] = B[1] + p[a++], e && (ae(B, B, e), ae(N, N, e)), B[0] = cO(B[0] * xO - _O), N[0] = cO(N[0] * xO - _O), B[1] = cO(B[1] * xO - _O), N[1] = cO(N[1] * xO - _O), f.push(" m ", B[0], mO, B[1], " l ", N[0], mO, B[1], " l ", N[0], mO, N[1], " l ", B[0], mO, N[1]); break;
                        case hO.Z:
                            f.push(" x ") } if (n > 0) { f.push(i); for (var V = 0; n > V; V++) { var F = EO[V];
                            e && ae(F, F, e), f.push(cO(F[0] * xO - _O), mO, cO(F[1] * xO - _O), n - 1 > V ? mO : "") } } } return f.join("") };
        ia.prototype.brushVML = function(t) { var e = this.style,
                n = this._vmlEl;
            n || (n = Ny("shape"), MO(n), this._vmlEl = n), zO(n, "fill", e, this), zO(n, "stroke", e, this); var i = this.transform,
                r = null != i,
                a = n.getElementsByTagName("stroke")[0]; if (a) { var o = e.lineWidth; if (r && !e.strokeNoScale) { var s = i[0] * i[3] - i[1] * i[2];
                    o *= dO(fO(s)) }
                a.weight = o + "px" } var l = this.path || (this.path = new Aw);
            this.__dirtyPath && (l.beginPath(), l.subPixelOptimize = !1, this.buildPath(l, this.shape), l.toStatic(), this.__dirtyPath = !1), n.path = RO(l, this.transform), n.style.zIndex = AO(this.zlevel, this.z, this.z2), TO(t, n), null != e.text ? this.drawRectText(t, this.getBoundingRect()) : this.removeRectText(t) }, ia.prototype.onRemove = function(t) { CO(t, this._vmlEl), this.removeRectText(t) }, ia.prototype.onAdd = function(t) { TO(t, this._vmlEl), this.appendRectText(t) }; var BO = function(t) { return "object" == typeof t && t.tagName && "IMG" === t.tagName.toUpperCase() };
        Di.prototype.brushVML = function(t) { var e, n, i = this.style,
                r = i.image; if (BO(r)) { var a = r.src; if (a === this._imageSrc) e = this._imageWidth, n = this._imageHeight;
                else { var o = r.runtimeStyle,
                        s = o.width,
                        l = o.height;
                    o.width = "auto", o.height = "auto", e = r.width, n = r.height, o.width = s, o.height = l, this._imageSrc = a, this._imageWidth = e, this._imageHeight = n }
                r = a } else r === this._imageSrc && (e = this._imageWidth, n = this._imageHeight); if (r) { var u = i.x || 0,
                    h = i.y || 0,
                    c = i.width,
                    d = i.height,
                    f = i.sWidth,
                    p = i.sHeight,
                    g = i.sx || 0,
                    v = i.sy || 0,
                    m = f && p,
                    y = this._vmlEl;
                y || (y = lO.createElement("div"), MO(y), this._vmlEl = y); var x, _ = y.style,
                    b = !1,
                    w = 1,
                    M = 1; if (this.transform && (x = this.transform, w = dO(x[0] * x[0] + x[1] * x[1]), M = dO(x[2] * x[2] + x[3] * x[3]), b = x[1] || x[2]), b) { var S = [u, h],
                        I = [u + c, h],
                        T = [u, h + d],
                        C = [u + c, h + d];
                    ae(S, S, x), ae(I, I, x), ae(T, T, x), ae(C, C, x); var A = vO(S[0], I[0], T[0], C[0]),
                        D = vO(S[1], I[1], T[1], C[1]),
                        k = [];
                    k.push("M11=", x[0] / w, mO, "M12=", x[2] / M, mO, "M21=", x[1] / w, mO, "M22=", x[3] / M, mO, "Dx=", cO(u * w + x[4]), mO, "Dy=", cO(h * M + x[5])), _.padding = "0 " + cO(A) + "px " + cO(D) + "px 0", _.filter = yO + ".Matrix(" + k.join("") + ", SizingMethod=clip)" } else x && (u = u * w + x[4], h = h * M + x[5]), _.filter = "", _.left = cO(u) + "px", _.top = cO(h) + "px"; var P = this._imageEl,
                    L = this._cropEl;
                P || (P = lO.createElement("div"), this._imageEl = P); var O = P.style; if (m) { if (e && n) O.width = cO(w * e * c / f) + "px", O.height = cO(M * n * d / p) + "px";
                    else { var z = new Image,
                            E = this;
                        z.onload = function() { z.onload = null, e = z.width, n = z.height, O.width = cO(w * e * c / f) + "px", O.height = cO(M * n * d / p) + "px", E._imageWidth = e, E._imageHeight = n, E._imageSrc = r }, z.src = r }
                    L || (L = lO.createElement("div"), L.style.overflow = "hidden", this._cropEl = L); var R = L.style;
                    R.width = cO((c + g * c / f) * w), R.height = cO((d + v * d / p) * M), R.filter = yO + ".Matrix(Dx=" + -g * c / f * w + ",Dy=" + -v * d / p * M + ")", L.parentNode || y.appendChild(L), P.parentNode !== L && L.appendChild(P) } else O.width = cO(w * c) + "px", O.height = cO(M * d) + "px", y.appendChild(P), L && L.parentNode && (y.removeChild(L), this._cropEl = null); var B = "",
                    N = i.opacity;
                1 > N && (B += ".Alpha(opacity=" + cO(100 * N) + ") "), B += yO + ".AlphaImageLoader(src=" + r + ", SizingMethod=scale)", O.filter = B, y.style.zIndex = AO(this.zlevel, this.z, this.z2), TO(t, y), null != i.text && this.drawRectText(t, this.getBoundingRect()) } }, Di.prototype.onRemove = function(t) { CO(t, this._vmlEl), this._vmlEl = null, this._cropEl = null, this._imageEl = null, this.removeRectText(t) }, Di.prototype.onAdd = function(t) { TO(t, this._vmlEl), this.appendRectText(t) }; var NO, VO = "normal",
            FO = {},
            HO = 0,
            GO = 100,
            WO = document.createElement("div"),
            ZO = function(t) { var e = FO[t]; if (!e) { HO > GO && (HO = 0, FO = {}); var n, i = WO.style; try { i.font = t, n = i.fontFamily.split(",")[0] } catch (r) {}
                    e = { style: i.fontStyle || VO, variant: i.fontVariant || VO, weight: i.fontWeight || VO, size: 0 | parseFloat(i.fontSize || 12), family: n || "Microsoft YaHei" }, FO[t] = e, HO++ } return e };
        Un("measureText", function(t, e) { var n = lO;
            NO || (NO = n.createElement("div"), NO.style.cssText = "position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;", lO.body.appendChild(NO)); try { NO.style.font = e } catch (i) {} return NO.innerHTML = "", NO.appendChild(n.createTextNode(t)), { width: NO.offsetWidth } }); for (var UO = new Cn, XO = function(t, e, n, i) { var r = this.style;
                this.__dirty && hi(r, !0); var a = r.text; if (null != a && (a += ""), a) { if (r.rich) { var o = oi(a, r);
                        a = []; for (var s = 0; s < o.lines.length; s++) { for (var l = o.lines[s].tokens, u = [], h = 0; h < l.length; h++) u.push(l[h].text);
                            a.push(u.join("")) }
                        a = a.join("\n") } var c, d, f = r.textAlign,
                        p = r.textVerticalAlign,
                        g = ZO(r.font),
                        v = g.style + " " + g.variant + " " + g.weight + " " + g.size + 'px "' + g.family + '"';
                    n = n || Yn(a, v, f, p, r.textPadding, r.textLineHeight); var m = this.transform; if (m && !i && (UO.copy(e), UO.applyTransform(m), e = UO), i) c = e.x, d = e.y;
                    else { var y = r.textPosition; if (y instanceof Array) c = e.x + DO(y[0], e.width), d = e.y + DO(y[1], e.height), f = f || "left";
                        else { var x = this.calculateTextPosition ? this.calculateTextPosition({}, r, e) : Qn({}, r, e);
                            c = x.x, d = x.y, f = f || x.textAlign, p = p || x.textVerticalAlign } }
                    c = Kn(c, n.width, f), d = $n(d, n.height, p), d += n.height / 2; var _, b, w, M = Ny,
                        S = this._textVmlEl;
                    S ? (w = S.firstChild, _ = w.nextSibling, b = _.nextSibling) : (S = M("line"), _ = M("path"), b = M("textpath"), w = M("skew"), b.style["v-text-align"] = "left", MO(S), _.textpathok = !0, b.on = !0, S.from = "0 0", S.to = "1000 0.05", TO(S, w), TO(S, _), TO(S, b), this._textVmlEl = S); var I = [c, d],
                        T = S.style;
                    m && i ? (ae(I, I, m), w.on = !0, w.matrix = m[0].toFixed(3) + mO + m[2].toFixed(3) + mO + m[1].toFixed(3) + mO + m[3].toFixed(3) + ",0,0", w.offset = (cO(I[0]) || 0) + "," + (cO(I[1]) || 0), w.origin = "0 0", T.left = "0px", T.top = "0px") : (w.on = !1, T.left = cO(c) + "px", T.top = cO(d) + "px"), b.string = SO(a); try { b.style.font = v } catch (C) {}
                    zO(S, "fill", { fill: r.textFill, opacity: r.opacity }, this), zO(S, "stroke", { stroke: r.textStroke, opacity: r.opacity, lineDash: r.lineDash || null }, this), S.style.zIndex = AO(this.zlevel, this.z, this.z2), TO(t, S) } }, YO = function(t) { CO(t, this._textVmlEl), this._textVmlEl = null }, jO = function(t) { TO(t, this._textVmlEl) }, qO = [pb, Ai, Di, ia, Jw], KO = 0; KO < qO.length; KO++) { var $O = qO[KO].prototype;
            $O.drawRectText = XO, $O.removeRectText = YO, $O.appendRectText = jO }
        Jw.prototype.brushVML = function(t) { var e = this.style;
            null != e.text ? this.drawRectText(t, { x: e.x || 0, y: e.y || 0, width: 0, height: 0 }, this.getBoundingRect(), !0) : this.removeRectText(t) }, Jw.prototype.onRemove = function(t) { this.removeRectText(t) }, Jw.prototype.onAdd = function(t) { this.appendRectText(t) } }
    Hy.prototype = { constructor: Hy, getType: function() { return "vml" }, getViewportRoot: function() { return this._vmlViewport }, getViewportRootOffset: function() { var t = this.getViewportRoot(); return t ? { offsetLeft: t.offsetLeft || 0, offsetTop: t.offsetTop || 0 } : void 0 }, refresh: function() { var t = this.storage.getDisplayList(!0, !0);
            this._paintList(t) }, _paintList: function(t) { for (var e = this._vmlRoot, n = 0; n < t.length; n++) { var i = t[n];
                i.invisible || i.ignore ? (i.__alreadyNotVisible || i.onRemove(e), i.__alreadyNotVisible = !0) : (i.__alreadyNotVisible && i.onAdd(e), i.__alreadyNotVisible = !1, i.__dirty && (i.beforeBrush && i.beforeBrush(), (i.brushVML || i.brush).call(i, e), i.afterBrush && i.afterBrush())), i.__dirty = !1 }
            this._firstPaint && (this._vmlViewport.appendChild(e), this._firstPaint = !1) }, resize: function(t, e) { var t = null == t ? this._getWidth() : t,
                e = null == e ? this._getHeight() : e; if (this._width !== t || this._height !== e) { this._width = t, this._height = e; var n = this._vmlViewport.style;
                n.width = t + "px", n.height = e + "px" } }, dispose: function() { this.root.innerHTML = "", this._vmlRoot = this._vmlViewport = this.storage = null }, getWidth: function() { return this._width }, getHeight: function() { return this._height }, clear: function() { this._vmlViewport && this.root.removeChild(this._vmlViewport) }, _getWidth: function() { var t = this.root,
                e = t.currentStyle; return (t.clientWidth || Fy(e.width)) - Fy(e.paddingLeft) - Fy(e.paddingRight) | 0 }, _getHeight: function() { var t = this.root,
                e = t.currentStyle; return (t.clientHeight || Fy(e.height)) - Fy(e.paddingTop) - Fy(e.paddingBottom) | 0 } }, f(["getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"], function(t) { Hy.prototype[t] = Gy(t) }), Ji("vml", Hy);
    var QO = "http://www.w3.org/2000/svg",
        JO = Aw.CMD,
        tz = Array.prototype.join,
        ez = "none",
        nz = Math.round,
        iz = Math.sin,
        rz = Math.cos,
        az = Math.PI,
        oz = 2 * Math.PI,
        sz = 180 / az,
        lz = 1e-4,
        uz = {};
    uz.brush = function(t) { var e = t.style,
            n = t.__svgEl;
        n || (n = Wy("path"), t.__svgEl = n), t.path || t.createPathProxy(); var i = t.path; if (t.__dirtyPath) { i.beginPath(), i.subPixelOptimize = !1, t.buildPath(i, t.shape), t.__dirtyPath = !1; var r = Qy(i);
            r.indexOf("NaN") < 0 && qy(n, "d", r) }
        $y(n, e, !1, t), jy(n, t.transform), null != e.text ? vz(t, t.getBoundingRect()) : nx(t) };
    var hz = {};
    hz.brush = function(t) { var e = t.style,
            n = e.image; if (n instanceof HTMLImageElement) { var i = n.src;
            n = i } if (n) { var r = e.x || 0,
                a = e.y || 0,
                o = e.width,
                s = e.height,
                l = t.__svgEl;
            l || (l = Wy("image"), t.__svgEl = l), n !== t.__imageSrc && (Ky(l, "href", n), t.__imageSrc = n), qy(l, "width", o), qy(l, "height", s), qy(l, "x", r), qy(l, "y", a), jy(l, t.transform), null != e.text ? vz(t, t.getBoundingRect()) : nx(t) } };
    var cz = {},
        dz = new Cn,
        fz = {},
        pz = [],
        gz = { left: "start", right: "end", center: "middle", middle: "middle" },
        vz = function(t, e) { var n = t.style,
                i = t.transform,
                r = t instanceof Jw || n.transformText;
            t.__dirty && hi(n, !0); var a = n.text; if (null != a && (a += ""), Ci(a, n)) { null == a && (a = ""), !r && i && (dz.copy(e), dz.applyTransform(i), e = dz); var o = t.__textSvgEl;
                o || (o = Wy("text"), t.__textSvgEl = o); var s = o.style,
                    l = n.font || ab,
                    u = o.__computedFont;
                l !== o.__styleFont && (s.font = o.__styleFont = l, u = o.__computedFont = s.font); var h = n.textPadding,
                    c = n.textLineHeight,
                    d = t.__textCotentBlock;
                (!d || t.__dirtyText) && (d = t.__textCotentBlock = ai(a, u, h, c, n.truncate)); var f = d.outerHeight,
                    p = d.lineHeight;
                bi(fz, t, n, e); var g = fz.baseX,
                    v = fz.baseY,
                    m = fz.textAlign || "left",
                    y = fz.textVerticalAlign;
                Jy(o, r, i, n, e, g, v); var x = $n(v, f, y),
                    _ = g,
                    b = x;
                h && (_ = tx(g, m, h), b += h[0]), b += p / 2, $y(o, n, !0, t); var w = d.canCacheByTextString,
                    M = t.__tspanList || (t.__tspanList = []),
                    S = M.length; if (w && t.__canCacheByTextString && t.__text === a) { if (t.__dirtyText && S)
                        for (var I = 0; S > I; ++I) ex(M[I], m, _, b + I * p) } else { t.__text = a, t.__canCacheByTextString = w; for (var T = d.lines, C = T.length, I = 0; C > I; I++) { var A = M[I],
                            D = T[I];
                        A ? A.__zrText !== D && (A.innerHTML = "", A.appendChild(document.createTextNode(D))) : (A = M[I] = Wy("tspan"), o.appendChild(A), A.appendChild(document.createTextNode(D))), ex(A, m, _, b + I * p) } if (S > C) { for (; S > I; I++) o.removeChild(M[I]);
                        M.length = C } } } };
    cz.drawRectText = vz, cz.brush = function(t) { var e = t.style;
        null != e.text ? vz(t, !1) : nx(t) }, ix.prototype = { diff: function(t, e, n) {
            function i() { for (var n = -1 * s; s >= n; n += 2) { var i, l = u[n - 1],
                        h = u[n + 1],
                        c = (h ? h.newPos : 0) - n;
                    l && (u[n - 1] = void 0); var d = l && l.newPos + 1 < a,
                        f = h && c >= 0 && o > c; if (d || f) { if (!d || f && l.newPos < h.newPos ? (i = ax(h), r.pushComponent(i.components, void 0, !0)) : (i = l, i.newPos++, r.pushComponent(i.components, !0, void 0)), c = r.extractCommon(i, e, t, n), i.newPos + 1 >= a && c + 1 >= o) return rx(r, i.components, e, t);
                        u[n] = i } else u[n] = void 0 }
                s++ }
            n || (n = function(t, e) { return t === e }), this.equals = n; var r = this;
            t = t.slice(), e = e.slice(); var a = e.length,
                o = t.length,
                s = 1,
                l = a + o,
                u = [{ newPos: -1, components: [] }],
                h = this.extractCommon(u[0], e, t, 0); if (u[0].newPos + 1 >= a && h + 1 >= o) { for (var c = [], d = 0; d < e.length; d++) c.push(d); return [{ indices: c, count: e.length }] } for (; l >= s;) { var f = i(); if (f) return f } }, pushComponent: function(t, e, n) { var i = t[t.length - 1];
            i && i.added === e && i.removed === n ? t[t.length - 1] = { count: i.count + 1, added: e, removed: n } : t.push({ count: 1, added: e, removed: n }) }, extractCommon: function(t, e, n, i) { for (var r = e.length, a = n.length, o = t.newPos, s = o - i, l = 0; r > o + 1 && a > s + 1 && this.equals(e[o + 1], n[s + 1]);) o++, s++, l++; return l && t.components.push({ count: l }), t.newPos = o, s }, tokenize: function(t) { return t.slice() }, join: function(t) { return t.slice() } };
    var mz = new ix,
        yz = function(t, e, n) { return mz.diff(t, e, n) },
        xz = "0",
        _z = "1";
    ox.prototype.createElement = Wy, ox.prototype.getDefs = function(t) { var e = this._svgRoot,
            n = this._svgRoot.getElementsByTagName("defs"); return 0 === n.length ? t ? (n = e.insertBefore(this.createElement("defs"), e.firstChild), n.contains || (n.contains = function(t) { var e = n.children; if (!e) return !1; for (var i = e.length - 1; i >= 0; --i)
                if (e[i] === t) return !0;
            return !1 }), n) : null : n[0] }, ox.prototype.update = function(t, e) { if (t) { var n = this.getDefs(!1); if (t[this._domName] && n.contains(t[this._domName])) "function" == typeof e && e(t);
            else { var i = this.add(t);
                i && (t[this._domName] = i) } } }, ox.prototype.addDom = function(t) { var e = this.getDefs(!0);
        e.appendChild(t) }, ox.prototype.removeDom = function(t) { var e = this.getDefs(!1);
        e && t[this._domName] && (e.removeChild(t[this._domName]), t[this._domName] = null) }, ox.prototype.getDoms = function() { var t = this.getDefs(!1); if (!t) return []; var e = []; return f(this._tagNames, function(n) { var i = t.getElementsByTagName(n);
            e = e.concat([].slice.call(i)) }), e }, ox.prototype.markAllUnused = function() { var t = this.getDoms(),
            e = this;
        f(t, function(t) { t[e._markLabel] = xz }) }, ox.prototype.markUsed = function(t) { t && (t[this._markLabel] = _z) }, ox.prototype.removeUnused = function() { var t = this.getDefs(!1); if (t) { var e = this.getDoms(),
                n = this;
            f(e, function(e) { e[n._markLabel] !== _z && t.removeChild(e) }) } }, ox.prototype.getSvgProxy = function(t) { return t instanceof ia ? uz : t instanceof Di ? hz : t instanceof Jw ? cz : uz }, ox.prototype.getTextSvgElement = function(t) { return t.__textSvgEl }, ox.prototype.getSvgElement = function(t) { return t.__svgEl }, h(sx, ox), sx.prototype.addWithoutUpdate = function(t, e) { if (e && e.style) { var n = this;
            f(["fill", "stroke"], function(i) { if (e.style[i] && ("linear" === e.style[i].type || "radial" === e.style[i].type)) { var r, a = e.style[i],
                        o = n.getDefs(!0);
                    a._dom ? (r = a._dom, o.contains(a._dom) || n.addDom(r)) : r = n.add(a), n.markUsed(e); var s = r.getAttribute("id");
                    t.setAttribute(i, "url(#" + s + ")") } }) } }, sx.prototype.add = function(t) { var e; if ("linear" === t.type) e = this.createElement("linearGradient");
        else { if ("radial" !== t.type) return L_("Illegal gradient type."), null;
            e = this.createElement("radialGradient") } return t.id = t.id || this.nextId++, e.setAttribute("id", "zr" + this._zrId + "-gradient-" + t.id), this.updateDom(t, e), this.addDom(e), e }, sx.prototype.update = function(t) { var e = this;
        ox.prototype.update.call(this, t, function() { var n = t.type,
                i = t._dom.tagName; "linear" === n && "linearGradient" === i || "radial" === n && "radialGradient" === i ? e.updateDom(t, t._dom) : (e.removeDom(t), e.add(t)) }) }, sx.prototype.updateDom = function(t, e) { if ("linear" === t.type) e.setAttribute("x1", t.x), e.setAttribute("y1", t.y), e.setAttribute("x2", t.x2), e.setAttribute("y2", t.y2);
        else { if ("radial" !== t.type) return void L_("Illegal gradient type.");
            e.setAttribute("cx", t.x), e.setAttribute("cy", t.y), e.setAttribute("r", t.r) }
        t.global ? e.setAttribute("gradientUnits", "userSpaceOnUse") : e.setAttribute("gradientUnits", "objectBoundingBox"), e.innerHTML = ""; for (var n = t.colorStops, i = 0, r = n.length; r > i; ++i) { var a = this.createElement("stop");
            a.setAttribute("offset", 100 * n[i].offset + "%"); var o = n[i].color; if (o.indexOf(!1)) { var s = tn(o)[3],
                    l = an(o);
                a.setAttribute("stop-color", "#" + l), a.setAttribute("stop-opacity", s) } else a.setAttribute("stop-color", n[i].color);
            e.appendChild(a) }
        t._dom = e }, sx.prototype.markUsed = function(t) { if (t.style) { var e = t.style.fill;
            e && e._dom && ox.prototype.markUsed.call(this, e._dom), e = t.style.stroke, e && e._dom && ox.prototype.markUsed.call(this, e._dom) } }, h(lx, ox), lx.prototype.update = function(t) { var e = this.getSvgElement(t);
        e && this.updateDom(e, t.__clipPaths, !1); var n = this.getTextSvgElement(t);
        n && this.updateDom(n, t.__clipPaths, !0), this.markUsed(t) }, lx.prototype.updateDom = function(t, e, n) { if (e && e.length > 0) { var i, r, a = this.getDefs(!0),
                o = e[0],
                s = n ? "_textDom" : "_dom";
            o[s] ? (r = o[s].getAttribute("id"), i = o[s], a.contains(i) || a.appendChild(i)) : (r = "zr" + this._zrId + "-clip-" + this.nextId, ++this.nextId, i = this.createElement("clipPath"), i.setAttribute("id", r), a.appendChild(i), o[s] = i); var l = this.getSvgProxy(o); if (o.transform && o.parent.invTransform && !n) { var u = Array.prototype.slice.call(o.transform);
                Re(o.transform, o.parent.invTransform, o.transform), l.brush(o), o.transform = u } else l.brush(o); var h = this.getSvgElement(o);
            i.innerHTML = "", i.appendChild(h.cloneNode()), t.setAttribute("clip-path", "url(#" + r + ")"), e.length > 1 && this.updateDom(i, e.slice(1), n) } else t && t.setAttribute("clip-path", "none") }, lx.prototype.markUsed = function(t) { var e = this;
        t.__clipPaths && f(t.__clipPaths, function(t) { t._dom && ox.prototype.markUsed.call(e, t._dom), t._textDom && ox.prototype.markUsed.call(e, t._textDom) }) }, h(ux, ox), ux.prototype.addWithoutUpdate = function(t, e) { if (e && hx(e.style)) { var n; if (e._shadowDom) { n = e._shadowDom; var i = this.getDefs(!0);
                i.contains(e._shadowDom) || this.addDom(n) } else n = this.add(e);
            this.markUsed(e); var r = n.getAttribute("id");
            t.style.filter = "url(#" + r + ")" } }, ux.prototype.add = function(t) { var e = this.createElement("filter"); return t._shadowDomId = t._shadowDomId || this.nextId++, e.setAttribute("id", "zr" + this._zrId + "-shadow-" + t._shadowDomId), this.updateDom(t, e), this.addDom(e), e }, ux.prototype.update = function(t, e) {
        var n = e.style;
        if (hx(n)) { var i = this;
            ox.prototype.update.call(this, e, function() { i.updateDom(e, e._shadowDom) }) } else this.remove(t, e)
    }, ux.prototype.remove = function(t, e) { null != e._shadowDomId && (this.removeDom(t), t.style.filter = "") }, ux.prototype.updateDom = function(t, e) { var n = e.getElementsByTagName("feDropShadow");
        n = 0 === n.length ? this.createElement("feDropShadow") : n[0]; var i, r, a, o, s = t.style,
            l = t.scale ? t.scale[0] || 1 : 1,
            u = t.scale ? t.scale[1] || 1 : 1; if (s.shadowBlur || s.shadowOffsetX || s.shadowOffsetY) i = s.shadowOffsetX || 0, r = s.shadowOffsetY || 0, a = s.shadowBlur, o = s.shadowColor;
        else { if (!s.textShadowBlur) return void this.removeDom(e, s);
            i = s.textShadowOffsetX || 0, r = s.textShadowOffsetY || 0, a = s.textShadowBlur, o = s.textShadowColor }
        n.setAttribute("dx", i / l), n.setAttribute("dy", r / u), n.setAttribute("flood-color", o); var h = a / 2 / l,
            c = a / 2 / u,
            d = h + " " + c;
        n.setAttribute("stdDeviation", d), e.setAttribute("x", "-100%"), e.setAttribute("y", "-100%"), e.setAttribute("width", Math.ceil(a / 2 * 200) + "%"), e.setAttribute("height", Math.ceil(a / 2 * 200) + "%"), e.appendChild(n), t._shadowDom = e }, ux.prototype.markUsed = function(t) { t._shadowDom && ox.prototype.markUsed.call(this, t._shadowDom) };
    var bz = function(t, e, n, i) { this.root = t, this.storage = e, this._opts = n = o({}, n || {}); var r = Wy("svg");
        r.setAttribute("xmlns", "http://www.w3.org/2000/svg"), r.setAttribute("version", "1.1"), r.setAttribute("baseProfile", "full"), r.style.cssText = "user-select:none;position:absolute;left:0;top:0;", this.gradientManager = new sx(i, r), this.clipPathManager = new lx(i, r), this.shadowManager = new ux(i, r); var a = document.createElement("div");
        a.style.cssText = "overflow:hidden;position:relative", this._svgRoot = r, this._viewport = a, t.appendChild(a), a.appendChild(r), this.resize(n.width, n.height), this._visibleList = [] };
    bz.prototype = { constructor: bz, getType: function() { return "svg" }, getViewportRoot: function() { return this._viewport }, getViewportRootOffset: function() { var t = this.getViewportRoot(); return t ? { offsetLeft: t.offsetLeft || 0, offsetTop: t.offsetTop || 0 } : void 0 }, refresh: function() { var t = this.storage.getDisplayList(!0);
            this._paintList(t) }, setBackgroundColor: function(t) { this._viewport.style.background = t }, _paintList: function(t) { this.gradientManager.markAllUnused(), this.clipPathManager.markAllUnused(), this.shadowManager.markAllUnused(); var e, n = this._svgRoot,
                i = this._visibleList,
                r = t.length,
                a = []; for (e = 0; r > e; e++) { var o = t[e],
                    s = dx(o),
                    l = yx(o) || mx(o);
                o.invisible || (o.__dirty && (s && s.brush(o), this.clipPathManager.update(o), o.style && (this.gradientManager.update(o.style.fill), this.gradientManager.update(o.style.stroke), this.shadowManager.update(l, o)), o.__dirty = !1), a.push(o)) } var u, h = yz(i, a); for (e = 0; e < h.length; e++) { var c = h[e]; if (c.removed)
                    for (var d = 0; d < c.count; d++) { var o = i[c.indices[d]],
                            l = yx(o),
                            f = mx(o);
                        vx(n, l), vx(n, f) } } for (e = 0; e < h.length; e++) { var c = h[e]; if (c.added)
                    for (var d = 0; d < c.count; d++) { var o = a[c.indices[d]],
                            l = yx(o),
                            f = mx(o);
                        u ? px(n, l, u) : gx(n, l), l ? px(n, f, l) : u ? px(n, f, u) : gx(n, f), px(n, f, l), u = f || l || u, this.gradientManager.addWithoutUpdate(l || f, o), this.shadowManager.addWithoutUpdate(l || f, o), this.clipPathManager.markUsed(o) } else if (!c.removed)
                        for (var d = 0; d < c.count; d++) { var o = a[c.indices[d]],
                                l = yx(o),
                                f = mx(o),
                                l = yx(o),
                                f = mx(o);
                            this.gradientManager.markUsed(o), this.gradientManager.addWithoutUpdate(l || f, o), this.shadowManager.markUsed(o), this.shadowManager.addWithoutUpdate(l || f, o), this.clipPathManager.markUsed(o), f && px(n, f, l), u = l || f || u } }
            this.gradientManager.removeUnused(), this.clipPathManager.removeUnused(), this.shadowManager.removeUnused(), this._visibleList = a }, _getDefs: function(t) { var e = this._svgRoot,
                n = this._svgRoot.getElementsByTagName("defs"); if (0 === n.length) { if (t) { var n = e.insertBefore(Wy("defs"), e.firstChild); return n.contains || (n.contains = function(t) { var e = n.children; if (!e) return !1; for (var i = e.length - 1; i >= 0; --i)
                            if (e[i] === t) return !0;
                        return !1 }), n } return null } return n[0] }, resize: function(t, e) { var n = this._viewport;
            n.style.display = "none"; var i = this._opts; if (null != t && (i.width = t), null != e && (i.height = e), t = this._getSize(0), e = this._getSize(1), n.style.display = "", this._width !== t || this._height !== e) { this._width = t, this._height = e; var r = n.style;
                r.width = t + "px", r.height = e + "px"; var a = this._svgRoot;
                a.setAttribute("width", t), a.setAttribute("height", e) } }, getWidth: function() { return this._width }, getHeight: function() { return this._height }, _getSize: function(t) { var e = this._opts,
                n = ["width", "height"][t],
                i = ["clientWidth", "clientHeight"][t],
                r = ["paddingLeft", "paddingTop"][t],
                a = ["paddingRight", "paddingBottom"][t]; if (null != e[n] && "auto" !== e[n]) return parseFloat(e[n]); var o = this.root,
                s = document.defaultView.getComputedStyle(o); return (o[i] || cx(s[n]) || cx(o.style[n])) - (cx(s[r]) || 0) - (cx(s[a]) || 0) | 0 }, dispose: function() { this.root.innerHTML = "", this._svgRoot = this._viewport = this.storage = null }, clear: function() { this._viewport && this.root.removeChild(this._viewport) }, pathToDataUrl: function() { this.refresh(); var t = this._svgRoot.outerHTML; return "data:image/svg+xml;charset=UTF-8," + t } }, f(["getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"], function(t) { bz.prototype[t] = xx(t) }), Ji("svg", bz), t.version = NI, t.dependencies = VI, t.PRIORITY = QI, t.init = gu, t.connect = vu, t.disConnect = mu, t.disconnect = yT, t.dispose = yu, t.getInstanceByDom = xu, t.getInstanceById = _u, t.registerTheme = bu, t.registerPreprocessor = wu, t.registerProcessor = Mu, t.registerPostUpdate = Su, t.registerAction = Iu, t.registerCoordinateSystem = Tu, t.getCoordinateSystemDimensions = Cu, t.registerLayout = Au, t.registerVisual = Du, t.registerLoading = Pu, t.extendComponentModel = Lu, t.extendComponentView = Ou, t.extendSeriesModel = zu, t.extendChartView = Eu, t.setCanvasCreator = Ru, t.registerMap = Bu, t.getMap = Nu, t.dataTool = xT, t.zrender = Rb, t.number = YM, t.format = tS, t.throttle = yl, t.helper = bC, t.matrix = o_, t.vector = Zx, t.color = I_, t.parseGeoJSON = MC, t.parseGeoJson = CC, t.util = AC, t.graphic = DC, t.List = PT, t.Model = vo, t.Axis = TC, t.env = Sx
});